(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function $v(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
var Ug = { exports: {} },
  Ec = {},
  Og = { exports: {} },
  nt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ra = Symbol.for("react.element"),
  Qv = Symbol.for("react.portal"),
  Jv = Symbol.for("react.fragment"),
  ey = Symbol.for("react.strict_mode"),
  ty = Symbol.for("react.profiler"),
  ny = Symbol.for("react.provider"),
  iy = Symbol.for("react.context"),
  ry = Symbol.for("react.forward_ref"),
  sy = Symbol.for("react.suspense"),
  oy = Symbol.for("react.memo"),
  ay = Symbol.for("react.lazy"),
  Rh = Symbol.iterator;
function ly(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (Rh && n[Rh]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Fg = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  kg = Object.assign,
  Bg = {};
function xo(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Bg),
    (this.updater = t || Fg);
}
xo.prototype.isReactComponent = {};
xo.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
xo.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function zg() {}
zg.prototype = xo.prototype;
function dd(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Bg),
    (this.updater = t || Fg);
}
var hd = (dd.prototype = new zg());
hd.constructor = dd;
kg(hd, xo.prototype);
hd.isPureReactComponent = !0;
var bh = Array.isArray,
  Hg = Object.prototype.hasOwnProperty,
  pd = { current: null },
  Vg = { key: !0, ref: !0, __self: !0, __source: !0 };
function Gg(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      Hg.call(e, i) && !Vg.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
    r.children = l;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: Ra,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: pd.current,
  };
}
function cy(n, e) {
  return {
    $$typeof: Ra,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function md(n) {
  return typeof n == "object" && n !== null && n.$$typeof === Ra;
}
function uy(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var Ch = /\/+/g;
function Wc(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? uy("" + n.key)
    : e.toString(36);
}
function Ll(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case Ra:
          case Qv:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (r = r(o)),
      (n = i === "" ? "." + Wc(o, 0) : i),
      bh(r)
        ? ((t = ""),
          n != null && (t = n.replace(Ch, "$&/") + "/"),
          Ll(r, e, t, "", function (c) {
            return c;
          }))
        : r != null &&
          (md(r) &&
            (r = cy(
              r,
              t +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(Ch, "$&/") + "/") +
                n
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), bh(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = i + Wc(s, a);
      o += Ll(s, e, t, l, r);
    }
  else if (((l = ly(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (l = i + Wc(s, a++)), (o += Ll(s, e, t, l, r));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function Fa(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    Ll(n, i, "", "", function (s) {
      return e.call(t, s, r++);
    }),
    i
  );
}
function fy(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var _n = { current: null },
  Pl = { transition: null },
  dy = {
    ReactCurrentDispatcher: _n,
    ReactCurrentBatchConfig: Pl,
    ReactCurrentOwner: pd,
  };
nt.Children = {
  map: Fa,
  forEach: function (n, e, t) {
    Fa(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Fa(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Fa(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!md(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
nt.Component = xo;
nt.Fragment = Jv;
nt.Profiler = ty;
nt.PureComponent = dd;
nt.StrictMode = ey;
nt.Suspense = sy;
nt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = dy;
nt.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var i = kg({}, n.props),
    r = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = pd.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      Hg.call(e, l) &&
        !Vg.hasOwnProperty(l) &&
        (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
    i.children = a;
  }
  return { $$typeof: Ra, type: n.type, key: r, ref: s, props: i, _owner: o };
};
nt.createContext = function (n) {
  return (
    (n = {
      $$typeof: iy,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: ny, _context: n }),
    (n.Consumer = n)
  );
};
nt.createElement = Gg;
nt.createFactory = function (n) {
  var e = Gg.bind(null, n);
  return (e.type = n), e;
};
nt.createRef = function () {
  return { current: null };
};
nt.forwardRef = function (n) {
  return { $$typeof: ry, render: n };
};
nt.isValidElement = md;
nt.lazy = function (n) {
  return { $$typeof: ay, _payload: { _status: -1, _result: n }, _init: fy };
};
nt.memo = function (n, e) {
  return { $$typeof: oy, type: n, compare: e === void 0 ? null : e };
};
nt.startTransition = function (n) {
  var e = Pl.transition;
  Pl.transition = {};
  try {
    n();
  } finally {
    Pl.transition = e;
  }
};
nt.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
nt.useCallback = function (n, e) {
  return _n.current.useCallback(n, e);
};
nt.useContext = function (n) {
  return _n.current.useContext(n);
};
nt.useDebugValue = function () {};
nt.useDeferredValue = function (n) {
  return _n.current.useDeferredValue(n);
};
nt.useEffect = function (n, e) {
  return _n.current.useEffect(n, e);
};
nt.useId = function () {
  return _n.current.useId();
};
nt.useImperativeHandle = function (n, e, t) {
  return _n.current.useImperativeHandle(n, e, t);
};
nt.useInsertionEffect = function (n, e) {
  return _n.current.useInsertionEffect(n, e);
};
nt.useLayoutEffect = function (n, e) {
  return _n.current.useLayoutEffect(n, e);
};
nt.useMemo = function (n, e) {
  return _n.current.useMemo(n, e);
};
nt.useReducer = function (n, e, t) {
  return _n.current.useReducer(n, e, t);
};
nt.useRef = function (n) {
  return _n.current.useRef(n);
};
nt.useState = function (n) {
  return _n.current.useState(n);
};
nt.useSyncExternalStore = function (n, e, t) {
  return _n.current.useSyncExternalStore(n, e, t);
};
nt.useTransition = function () {
  return _n.current.useTransition();
};
nt.version = "18.2.0";
Og.exports = nt;
var jt = Og.exports;
const hy = $v(jt);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var py = jt,
  my = Symbol.for("react.element"),
  gy = Symbol.for("react.fragment"),
  _y = Object.prototype.hasOwnProperty,
  vy = py.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  yy = { key: !0, ref: !0, __self: !0, __source: !0 };
function Wg(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (i in e) _y.call(e, i) && !yy.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: my,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: vy.current,
  };
}
Ec.Fragment = gy;
Ec.jsx = Wg;
Ec.jsxs = Wg;
Ug.exports = Ec;
var Ln = Ug.exports,
  nf = {},
  Xg = { exports: {} },
  Fn = {},
  jg = { exports: {} },
  Yg = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(W, K) {
    var G = W.length;
    W.push(K);
    e: for (; 0 < G; ) {
      var z = (G - 1) >>> 1,
        V = W[z];
      if (0 < r(V, K)) (W[z] = K), (W[G] = V), (G = z);
      else break e;
    }
  }
  function t(W) {
    return W.length === 0 ? null : W[0];
  }
  function i(W) {
    if (W.length === 0) return null;
    var K = W[0],
      G = W.pop();
    if (G !== K) {
      W[0] = G;
      e: for (var z = 0, V = W.length, _e = V >>> 1; z < _e; ) {
        var ve = 2 * (z + 1) - 1,
          we = W[ve],
          ye = ve + 1,
          ke = W[ye];
        if (0 > r(we, G))
          ye < V && 0 > r(ke, we)
            ? ((W[z] = ke), (W[ye] = G), (z = ye))
            : ((W[z] = we), (W[ve] = G), (z = ve));
        else if (ye < V && 0 > r(ke, G)) (W[z] = ke), (W[ye] = G), (z = ye);
        else break e;
      }
    }
    return K;
  }
  function r(W, K) {
    var G = W.sortIndex - K.sortIndex;
    return G !== 0 ? G : W.id - K.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    f = null,
    d = 3,
    p = !1,
    v = !1,
    x = !1,
    m = typeof setTimeout == "function" ? setTimeout : null,
    h = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function g(W) {
    for (var K = t(c); K !== null; ) {
      if (K.callback === null) i(c);
      else if (K.startTime <= W)
        i(c), (K.sortIndex = K.expirationTime), e(l, K);
      else break;
      K = t(c);
    }
  }
  function E(W) {
    if (((x = !1), g(W), !v))
      if (t(l) !== null) (v = !0), ie(w);
      else {
        var K = t(c);
        K !== null && te(E, K.startTime - W);
      }
  }
  function w(W, K) {
    (v = !1), x && ((x = !1), h(U), (U = -1)), (p = !0);
    var G = d;
    try {
      for (
        g(K), f = t(l);
        f !== null && (!(f.expirationTime > K) || (W && !$()));

      ) {
        var z = f.callback;
        if (typeof z == "function") {
          (f.callback = null), (d = f.priorityLevel);
          var V = z(f.expirationTime <= K);
          (K = n.unstable_now()),
            typeof V == "function" ? (f.callback = V) : f === t(l) && i(l),
            g(K);
        } else i(l);
        f = t(l);
      }
      if (f !== null) var _e = !0;
      else {
        var ve = t(c);
        ve !== null && te(E, ve.startTime - K), (_e = !1);
      }
      return _e;
    } finally {
      (f = null), (d = G), (p = !1);
    }
  }
  var L = !1,
    A = null,
    U = -1,
    M = 5,
    b = -1;
  function $() {
    return !(n.unstable_now() - b < M);
  }
  function J() {
    if (A !== null) {
      var W = n.unstable_now();
      b = W;
      var K = !0;
      try {
        K = A(!0, W);
      } finally {
        K ? se() : ((L = !1), (A = null));
      }
    } else L = !1;
  }
  var se;
  if (typeof _ == "function")
    se = function () {
      _(J);
    };
  else if (typeof MessageChannel < "u") {
    var H = new MessageChannel(),
      Q = H.port2;
    (H.port1.onmessage = J),
      (se = function () {
        Q.postMessage(null);
      });
  } else
    se = function () {
      m(J, 0);
    };
  function ie(W) {
    (A = W), L || ((L = !0), se());
  }
  function te(W, K) {
    U = m(function () {
      W(n.unstable_now());
    }, K);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (W) {
      W.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      v || p || ((v = !0), ie(w));
    }),
    (n.unstable_forceFrameRate = function (W) {
      0 > W || 125 < W
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (M = 0 < W ? Math.floor(1e3 / W) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return d;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (W) {
      switch (d) {
        case 1:
        case 2:
        case 3:
          var K = 3;
          break;
        default:
          K = d;
      }
      var G = d;
      d = K;
      try {
        return W();
      } finally {
        d = G;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (W, K) {
      switch (W) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          W = 3;
      }
      var G = d;
      d = W;
      try {
        return K();
      } finally {
        d = G;
      }
    }),
    (n.unstable_scheduleCallback = function (W, K, G) {
      var z = n.unstable_now();
      switch (
        (typeof G == "object" && G !== null
          ? ((G = G.delay), (G = typeof G == "number" && 0 < G ? z + G : z))
          : (G = z),
        W)
      ) {
        case 1:
          var V = -1;
          break;
        case 2:
          V = 250;
          break;
        case 5:
          V = 1073741823;
          break;
        case 4:
          V = 1e4;
          break;
        default:
          V = 5e3;
      }
      return (
        (V = G + V),
        (W = {
          id: u++,
          callback: K,
          priorityLevel: W,
          startTime: G,
          expirationTime: V,
          sortIndex: -1,
        }),
        G > z
          ? ((W.sortIndex = G),
            e(c, W),
            t(l) === null &&
              W === t(c) &&
              (x ? (h(U), (U = -1)) : (x = !0), te(E, G - z)))
          : ((W.sortIndex = V), e(l, W), v || p || ((v = !0), ie(w))),
        W
      );
    }),
    (n.unstable_shouldYield = $),
    (n.unstable_wrapCallback = function (W) {
      var K = d;
      return function () {
        var G = d;
        d = K;
        try {
          return W.apply(this, arguments);
        } finally {
          d = G;
        }
      };
    });
})(Yg);
jg.exports = Yg;
var xy = jg.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var qg = jt,
  On = xy;
function ue(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var Kg = new Set(),
  la = {};
function us(n, e) {
  no(n, e), no(n + "Capture", e);
}
function no(n, e) {
  for (la[n] = e, n = 0; n < e.length; n++) Kg.add(e[n]);
}
var Hi = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  rf = Object.prototype.hasOwnProperty,
  Sy =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Lh = {},
  Ph = {};
function Ey(n) {
  return rf.call(Ph, n)
    ? !0
    : rf.call(Lh, n)
    ? !1
    : Sy.test(n)
    ? (Ph[n] = !0)
    : ((Lh[n] = !0), !1);
}
function My(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function Ty(n, e, t, i) {
  if (e === null || typeof e > "u" || My(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function vn(n, e, t, i, r, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var nn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    nn[n] = new vn(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  nn[e] = new vn(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  nn[n] = new vn(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  nn[n] = new vn(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    nn[n] = new vn(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  nn[n] = new vn(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  nn[n] = new vn(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  nn[n] = new vn(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  nn[n] = new vn(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var gd = /[\-:]([a-z])/g;
function _d(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(gd, _d);
    nn[e] = new vn(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(gd, _d);
    nn[e] = new vn(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(gd, _d);
  nn[e] = new vn(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  nn[n] = new vn(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
nn.xlinkHref = new vn(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  nn[n] = new vn(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function vd(n, e, t, i) {
  var r = nn.hasOwnProperty(e) ? nn[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (Ty(e, t, r, i) && (t = null),
    i || r === null
      ? Ey(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
      ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((r = r.type),
            (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
            i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var ji = qg.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  ka = Symbol.for("react.element"),
  Ds = Symbol.for("react.portal"),
  Us = Symbol.for("react.fragment"),
  yd = Symbol.for("react.strict_mode"),
  sf = Symbol.for("react.profiler"),
  Zg = Symbol.for("react.provider"),
  $g = Symbol.for("react.context"),
  xd = Symbol.for("react.forward_ref"),
  of = Symbol.for("react.suspense"),
  af = Symbol.for("react.suspense_list"),
  Sd = Symbol.for("react.memo"),
  rr = Symbol.for("react.lazy"),
  Qg = Symbol.for("react.offscreen"),
  Ih = Symbol.iterator;
function bo(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (Ih && n[Ih]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Lt = Object.assign,
  Xc;
function Wo(n) {
  if (Xc === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      Xc = (e && e[1]) || "";
    }
  return (
    `
` +
    Xc +
    n
  );
}
var jc = !1;
function Yc(n, e) {
  if (!n || jc) return "";
  jc = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var i = c;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          i = c;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        i = c;
      }
      n();
    }
  } catch (c) {
    if (c && i && typeof c.stack == "string") {
      for (
        var r = c.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var l =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (jc = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? Wo(n) : "";
}
function wy(n) {
  switch (n.tag) {
    case 5:
      return Wo(n.type);
    case 16:
      return Wo("Lazy");
    case 13:
      return Wo("Suspense");
    case 19:
      return Wo("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = Yc(n.type, !1)), n;
    case 11:
      return (n = Yc(n.type.render, !1)), n;
    case 1:
      return (n = Yc(n.type, !0)), n;
    default:
      return "";
  }
}
function lf(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case Us:
      return "Fragment";
    case Ds:
      return "Portal";
    case sf:
      return "Profiler";
    case yd:
      return "StrictMode";
    case of:
      return "Suspense";
    case af:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case $g:
        return (n.displayName || "Context") + ".Consumer";
      case Zg:
        return (n._context.displayName || "Context") + ".Provider";
      case xd:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case Sd:
        return (
          (e = n.displayName || null), e !== null ? e : lf(n.type) || "Memo"
        );
      case rr:
        (e = n._payload), (n = n._init);
        try {
          return lf(n(e));
        } catch {}
    }
  return null;
}
function Ay(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return lf(e);
    case 8:
      return e === yd ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Ar(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function Jg(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function Ry(n) {
  var e = Jg(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          (i = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function Ba(n) {
  n._valueTracker || (n._valueTracker = Ry(n));
}
function e_(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = Jg(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function Wl(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function cf(n, e) {
  var t = e.checked;
  return Lt({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function Nh(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (t = Ar(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function t_(n, e) {
  (e = e.checked), e != null && vd(n, "checked", e, !1);
}
function uf(n, e) {
  t_(n, e);
  var t = Ar(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? ff(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && ff(n, e.type, Ar(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function Dh(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function ff(n, e, t) {
  (e !== "number" || Wl(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var Xo = Array.isArray;
function Ys(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      (r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + Ar(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        (n[r].selected = !0), i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function df(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(ue(91));
  return Lt({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function Uh(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(ue(92));
      if (Xo(t)) {
        if (1 < t.length) throw Error(ue(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: Ar(t) };
}
function n_(n, e) {
  var t = Ar(e.value),
    i = Ar(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i);
}
function Oh(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function i_(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function hf(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? i_(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var za,
  r_ = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        za = za || document.createElement("div"),
          za.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = za.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function ca(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var Ko = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  by = ["Webkit", "ms", "Moz", "O"];
Object.keys(Ko).forEach(function (n) {
  by.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (Ko[e] = Ko[n]);
  });
});
function s_(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (Ko.hasOwnProperty(n) && Ko[n])
    ? ("" + e).trim()
    : e + "px";
}
function o_(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = s_(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r);
    }
}
var Cy = Lt(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function pf(n, e) {
  if (e) {
    if (Cy[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(ue(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(ue(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(ue(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(ue(62));
  }
}
function mf(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var gf = null;
function Ed(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var _f = null,
  qs = null,
  Ks = null;
function Fh(n) {
  if ((n = La(n))) {
    if (typeof _f != "function") throw Error(ue(280));
    var e = n.stateNode;
    e && ((e = Rc(e)), _f(n.stateNode, n.type, e));
  }
}
function a_(n) {
  qs ? (Ks ? Ks.push(n) : (Ks = [n])) : (qs = n);
}
function l_() {
  if (qs) {
    var n = qs,
      e = Ks;
    if (((Ks = qs = null), Fh(n), e)) for (n = 0; n < e.length; n++) Fh(e[n]);
  }
}
function c_(n, e) {
  return n(e);
}
function u_() {}
var qc = !1;
function f_(n, e, t) {
  if (qc) return n(e, t);
  qc = !0;
  try {
    return c_(n, e, t);
  } finally {
    (qc = !1), (qs !== null || Ks !== null) && (u_(), l_());
  }
}
function ua(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = Rc(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(ue(231, e, typeof t));
  return t;
}
var vf = !1;
if (Hi)
  try {
    var Co = {};
    Object.defineProperty(Co, "passive", {
      get: function () {
        vf = !0;
      },
    }),
      window.addEventListener("test", Co, Co),
      window.removeEventListener("test", Co, Co);
  } catch {
    vf = !1;
  }
function Ly(n, e, t, i, r, s, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, c);
  } catch (u) {
    this.onError(u);
  }
}
var Zo = !1,
  Xl = null,
  jl = !1,
  yf = null,
  Py = {
    onError: function (n) {
      (Zo = !0), (Xl = n);
    },
  };
function Iy(n, e, t, i, r, s, o, a, l) {
  (Zo = !1), (Xl = null), Ly.apply(Py, arguments);
}
function Ny(n, e, t, i, r, s, o, a, l) {
  if ((Iy.apply(this, arguments), Zo)) {
    if (Zo) {
      var c = Xl;
      (Zo = !1), (Xl = null);
    } else throw Error(ue(198));
    jl || ((jl = !0), (yf = c));
  }
}
function fs(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function d_(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function kh(n) {
  if (fs(n) !== n) throw Error(ue(188));
}
function Dy(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = fs(n)), e === null)) throw Error(ue(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return kh(r), n;
        if (s === i) return kh(r), e;
        s = s.sibling;
      }
      throw Error(ue(188));
    }
    if (t.return !== i.return) (t = r), (i = s);
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === t) {
          (o = !0), (t = r), (i = s);
          break;
        }
        if (a === i) {
          (o = !0), (i = r), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (i = r);
            break;
          }
          if (a === i) {
            (o = !0), (i = s), (t = r);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(ue(189));
      }
    }
    if (t.alternate !== i) throw Error(ue(190));
  }
  if (t.tag !== 3) throw Error(ue(188));
  return t.stateNode.current === t ? n : e;
}
function h_(n) {
  return (n = Dy(n)), n !== null ? p_(n) : null;
}
function p_(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = p_(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var m_ = On.unstable_scheduleCallback,
  Bh = On.unstable_cancelCallback,
  Uy = On.unstable_shouldYield,
  Oy = On.unstable_requestPaint,
  Dt = On.unstable_now,
  Fy = On.unstable_getCurrentPriorityLevel,
  Md = On.unstable_ImmediatePriority,
  g_ = On.unstable_UserBlockingPriority,
  Yl = On.unstable_NormalPriority,
  ky = On.unstable_LowPriority,
  __ = On.unstable_IdlePriority,
  Mc = null,
  vi = null;
function By(n) {
  if (vi && typeof vi.onCommitFiberRoot == "function")
    try {
      vi.onCommitFiberRoot(Mc, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var ai = Math.clz32 ? Math.clz32 : Vy,
  zy = Math.log,
  Hy = Math.LN2;
function Vy(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((zy(n) / Hy) | 0)) | 0;
}
var Ha = 64,
  Va = 4194304;
function jo(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function ql(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = jo(a)) : ((s &= o), s !== 0 && (i = jo(s)));
  } else (o = t & ~r), o !== 0 ? (i = jo(o)) : s !== 0 && (i = jo(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      (t = 31 - ai(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
  return i;
}
function Gy(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function Wy(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - ai(s),
      a = 1 << o,
      l = r[o];
    l === -1
      ? (!(a & t) || a & i) && (r[o] = Gy(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function xf(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function v_() {
  var n = Ha;
  return (Ha <<= 1), !(Ha & 4194240) && (Ha = 64), n;
}
function Kc(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function ba(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - ai(e)),
    (n[e] = t);
}
function Xy(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - ai(t),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s);
  }
}
function Td(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - ai(t),
      r = 1 << i;
    (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
  }
}
var ft = 0;
function y_(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var x_,
  wd,
  S_,
  E_,
  M_,
  Sf = !1,
  Ga = [],
  pr = null,
  mr = null,
  gr = null,
  fa = new Map(),
  da = new Map(),
  lr = [],
  jy =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function zh(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      pr = null;
      break;
    case "dragenter":
    case "dragleave":
      mr = null;
      break;
    case "mouseover":
    case "mouseout":
      gr = null;
      break;
    case "pointerover":
    case "pointerout":
      fa.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      da.delete(e.pointerId);
  }
}
function Lo(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = La(e)), e !== null && wd(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function Yy(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return (pr = Lo(pr, n, e, t, i, r)), !0;
    case "dragenter":
      return (mr = Lo(mr, n, e, t, i, r)), !0;
    case "mouseover":
      return (gr = Lo(gr, n, e, t, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return fa.set(s, Lo(fa.get(s) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), da.set(s, Lo(da.get(s) || null, n, e, t, i, r)), !0
      );
  }
  return !1;
}
function T_(n) {
  var e = Yr(n.target);
  if (e !== null) {
    var t = fs(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = d_(t)), e !== null)) {
          (n.blockedOn = e),
            M_(n.priority, function () {
              S_(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function Il(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = Ef(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      (gf = i), t.target.dispatchEvent(i), (gf = null);
    } else return (e = La(t)), e !== null && wd(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function Hh(n, e, t) {
  Il(n) && t.delete(e);
}
function qy() {
  (Sf = !1),
    pr !== null && Il(pr) && (pr = null),
    mr !== null && Il(mr) && (mr = null),
    gr !== null && Il(gr) && (gr = null),
    fa.forEach(Hh),
    da.forEach(Hh);
}
function Po(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    Sf ||
      ((Sf = !0),
      On.unstable_scheduleCallback(On.unstable_NormalPriority, qy)));
}
function ha(n) {
  function e(r) {
    return Po(r, n);
  }
  if (0 < Ga.length) {
    Po(Ga[0], n);
    for (var t = 1; t < Ga.length; t++) {
      var i = Ga[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    pr !== null && Po(pr, n),
      mr !== null && Po(mr, n),
      gr !== null && Po(gr, n),
      fa.forEach(e),
      da.forEach(e),
      t = 0;
    t < lr.length;
    t++
  )
    (i = lr[t]), i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < lr.length && ((t = lr[0]), t.blockedOn === null); )
    T_(t), t.blockedOn === null && lr.shift();
}
var Zs = ji.ReactCurrentBatchConfig,
  Kl = !0;
function Ky(n, e, t, i) {
  var r = ft,
    s = Zs.transition;
  Zs.transition = null;
  try {
    (ft = 1), Ad(n, e, t, i);
  } finally {
    (ft = r), (Zs.transition = s);
  }
}
function Zy(n, e, t, i) {
  var r = ft,
    s = Zs.transition;
  Zs.transition = null;
  try {
    (ft = 4), Ad(n, e, t, i);
  } finally {
    (ft = r), (Zs.transition = s);
  }
}
function Ad(n, e, t, i) {
  if (Kl) {
    var r = Ef(n, e, t, i);
    if (r === null) su(n, e, i, Zl, t), zh(n, i);
    else if (Yy(r, n, e, t, i)) i.stopPropagation();
    else if ((zh(n, i), e & 4 && -1 < jy.indexOf(n))) {
      for (; r !== null; ) {
        var s = La(r);
        if (
          (s !== null && x_(s),
          (s = Ef(n, e, t, i)),
          s === null && su(n, e, i, Zl, t),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else su(n, e, i, null, t);
  }
}
var Zl = null;
function Ef(n, e, t, i) {
  if (((Zl = null), (n = Ed(i)), (n = Yr(n)), n !== null))
    if (((e = fs(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = d_(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (Zl = n), null;
}
function w_(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (Fy()) {
        case Md:
          return 1;
        case g_:
          return 4;
        case Yl:
        case ky:
          return 16;
        case __:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var ur = null,
  Rd = null,
  Nl = null;
function A_() {
  if (Nl) return Nl;
  var n,
    e = Rd,
    t = e.length,
    i,
    r = "value" in ur ? ur.value : ur.textContent,
    s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
  return (Nl = r.slice(n, 1 < i ? 1 - i : void 0));
}
function Dl(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Wa() {
  return !0;
}
function Vh() {
  return !1;
}
function kn(n) {
  function e(t, i, r, s, o) {
    (this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Wa
        : Vh),
      (this.isPropagationStopped = Vh),
      this
    );
  }
  return (
    Lt(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Wa));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Wa));
      },
      persist: function () {},
      isPersistent: Wa,
    }),
    e
  );
}
var So = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  bd = kn(So),
  Ca = Lt({}, So, { view: 0, detail: 0 }),
  $y = kn(Ca),
  Zc,
  $c,
  Io,
  Tc = Lt({}, Ca, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Cd,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== Io &&
            (Io && n.type === "mousemove"
              ? ((Zc = n.screenX - Io.screenX), ($c = n.screenY - Io.screenY))
              : ($c = Zc = 0),
            (Io = n)),
          Zc);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : $c;
    },
  }),
  Gh = kn(Tc),
  Qy = Lt({}, Tc, { dataTransfer: 0 }),
  Jy = kn(Qy),
  ex = Lt({}, Ca, { relatedTarget: 0 }),
  Qc = kn(ex),
  tx = Lt({}, So, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  nx = kn(tx),
  ix = Lt({}, So, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  rx = kn(ix),
  sx = Lt({}, So, { data: 0 }),
  Wh = kn(sx),
  ox = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  ax = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  lx = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function cx(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = lx[n]) ? !!e[n] : !1;
}
function Cd() {
  return cx;
}
var ux = Lt({}, Ca, {
    key: function (n) {
      if (n.key) {
        var e = ox[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = Dl(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? ax[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Cd,
    charCode: function (n) {
      return n.type === "keypress" ? Dl(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? Dl(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  fx = kn(ux),
  dx = Lt({}, Tc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Xh = kn(dx),
  hx = Lt({}, Ca, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Cd,
  }),
  px = kn(hx),
  mx = Lt({}, So, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  gx = kn(mx),
  _x = Lt({}, Tc, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  vx = kn(_x),
  yx = [9, 13, 27, 32],
  Ld = Hi && "CompositionEvent" in window,
  $o = null;
Hi && "documentMode" in document && ($o = document.documentMode);
var xx = Hi && "TextEvent" in window && !$o,
  R_ = Hi && (!Ld || ($o && 8 < $o && 11 >= $o)),
  jh = " ",
  Yh = !1;
function b_(n, e) {
  switch (n) {
    case "keyup":
      return yx.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function C_(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var Os = !1;
function Sx(n, e) {
  switch (n) {
    case "compositionend":
      return C_(e);
    case "keypress":
      return e.which !== 32 ? null : ((Yh = !0), jh);
    case "textInput":
      return (n = e.data), n === jh && Yh ? null : n;
    default:
      return null;
  }
}
function Ex(n, e) {
  if (Os)
    return n === "compositionend" || (!Ld && b_(n, e))
      ? ((n = A_()), (Nl = Rd = ur = null), (Os = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return R_ && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var Mx = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function qh(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!Mx[n.type] : e === "textarea";
}
function L_(n, e, t, i) {
  a_(i),
    (e = $l(e, "onChange")),
    0 < e.length &&
      ((t = new bd("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e }));
}
var Qo = null,
  pa = null;
function Tx(n) {
  H_(n, 0);
}
function wc(n) {
  var e = Bs(n);
  if (e_(e)) return n;
}
function wx(n, e) {
  if (n === "change") return e;
}
var P_ = !1;
if (Hi) {
  var Jc;
  if (Hi) {
    var eu = "oninput" in document;
    if (!eu) {
      var Kh = document.createElement("div");
      Kh.setAttribute("oninput", "return;"),
        (eu = typeof Kh.oninput == "function");
    }
    Jc = eu;
  } else Jc = !1;
  P_ = Jc && (!document.documentMode || 9 < document.documentMode);
}
function Zh() {
  Qo && (Qo.detachEvent("onpropertychange", I_), (pa = Qo = null));
}
function I_(n) {
  if (n.propertyName === "value" && wc(pa)) {
    var e = [];
    L_(e, pa, n, Ed(n)), f_(Tx, e);
  }
}
function Ax(n, e, t) {
  n === "focusin"
    ? (Zh(), (Qo = e), (pa = t), Qo.attachEvent("onpropertychange", I_))
    : n === "focusout" && Zh();
}
function Rx(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return wc(pa);
}
function bx(n, e) {
  if (n === "click") return wc(e);
}
function Cx(n, e) {
  if (n === "input" || n === "change") return wc(e);
}
function Lx(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var ui = typeof Object.is == "function" ? Object.is : Lx;
function ma(n, e) {
  if (ui(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!rf.call(e, r) || !ui(n[r], e[r])) return !1;
  }
  return !0;
}
function $h(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function Qh(n, e) {
  var t = $h(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = $h(t);
  }
}
function N_(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? N_(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function D_() {
  for (var n = window, e = Wl(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = Wl(n.document);
  }
  return e;
}
function Pd(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function Px(n) {
  var e = D_(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    N_(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && Pd(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !n.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = Qh(t, s));
        var o = Qh(t, i);
        r &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          s > i
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var Ix = Hi && "documentMode" in document && 11 >= document.documentMode,
  Fs = null,
  Mf = null,
  Jo = null,
  Tf = !1;
function Jh(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  Tf ||
    Fs == null ||
    Fs !== Wl(i) ||
    ((i = Fs),
    "selectionStart" in i && Pd(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (Jo && ma(Jo, i)) ||
      ((Jo = i),
      (i = $l(Mf, "onSelect")),
      0 < i.length &&
        ((e = new bd("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = Fs))));
}
function Xa(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var ks = {
    animationend: Xa("Animation", "AnimationEnd"),
    animationiteration: Xa("Animation", "AnimationIteration"),
    animationstart: Xa("Animation", "AnimationStart"),
    transitionend: Xa("Transition", "TransitionEnd"),
  },
  tu = {},
  U_ = {};
Hi &&
  ((U_ = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete ks.animationend.animation,
    delete ks.animationiteration.animation,
    delete ks.animationstart.animation),
  "TransitionEvent" in window || delete ks.transitionend.transition);
function Ac(n) {
  if (tu[n]) return tu[n];
  if (!ks[n]) return n;
  var e = ks[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in U_) return (tu[n] = e[t]);
  return n;
}
var O_ = Ac("animationend"),
  F_ = Ac("animationiteration"),
  k_ = Ac("animationstart"),
  B_ = Ac("transitionend"),
  z_ = new Map(),
  ep =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function Pr(n, e) {
  z_.set(n, e), us(e, [n]);
}
for (var nu = 0; nu < ep.length; nu++) {
  var iu = ep[nu],
    Nx = iu.toLowerCase(),
    Dx = iu[0].toUpperCase() + iu.slice(1);
  Pr(Nx, "on" + Dx);
}
Pr(O_, "onAnimationEnd");
Pr(F_, "onAnimationIteration");
Pr(k_, "onAnimationStart");
Pr("dblclick", "onDoubleClick");
Pr("focusin", "onFocus");
Pr("focusout", "onBlur");
Pr(B_, "onTransitionEnd");
no("onMouseEnter", ["mouseout", "mouseover"]);
no("onMouseLeave", ["mouseout", "mouseover"]);
no("onPointerEnter", ["pointerout", "pointerover"]);
no("onPointerLeave", ["pointerout", "pointerover"]);
us(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
us(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
us("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
us(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
us(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
us(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var Yo =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  Ux = new Set("cancel close invalid load scroll toggle".split(" ").concat(Yo));
function tp(n, e, t) {
  var i = n.type || "unknown-event";
  (n.currentTarget = t), Ny(i, e, void 0, n), (n.currentTarget = null);
}
function H_(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            l = a.instance,
            c = a.currentTarget;
          if (((a = a.listener), l !== s && r.isPropagationStopped())) break e;
          tp(r, a, c), (s = l);
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== s && r.isPropagationStopped())
          )
            break e;
          tp(r, a, c), (s = l);
        }
    }
  }
  if (jl) throw ((n = yf), (jl = !1), (yf = null), n);
}
function yt(n, e) {
  var t = e[Cf];
  t === void 0 && (t = e[Cf] = new Set());
  var i = n + "__bubble";
  t.has(i) || (V_(e, n, 2, !1), t.add(i));
}
function ru(n, e, t) {
  var i = 0;
  e && (i |= 4), V_(t, n, i, e);
}
var ja = "_reactListening" + Math.random().toString(36).slice(2);
function ga(n) {
  if (!n[ja]) {
    (n[ja] = !0),
      Kg.forEach(function (t) {
        t !== "selectionchange" && (Ux.has(t) || ru(t, !1, n), ru(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[ja] || ((e[ja] = !0), ru("selectionchange", !1, e));
  }
}
function V_(n, e, t, i) {
  switch (w_(e)) {
    case 1:
      var r = Ky;
      break;
    case 4:
      r = Zy;
      break;
    default:
      r = Ad;
  }
  (t = r.bind(null, e, t, n)),
    (r = void 0),
    !vf ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
      ? n.addEventListener(e, t, { passive: r })
      : n.addEventListener(e, t, !1);
}
function su(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === r || (l.nodeType === 8 && l.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = Yr(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  f_(function () {
    var c = s,
      u = Ed(t),
      f = [];
    e: {
      var d = z_.get(n);
      if (d !== void 0) {
        var p = bd,
          v = n;
        switch (n) {
          case "keypress":
            if (Dl(t) === 0) break e;
          case "keydown":
          case "keyup":
            p = fx;
            break;
          case "focusin":
            (v = "focus"), (p = Qc);
            break;
          case "focusout":
            (v = "blur"), (p = Qc);
            break;
          case "beforeblur":
          case "afterblur":
            p = Qc;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = Gh;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = Jy;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = px;
            break;
          case O_:
          case F_:
          case k_:
            p = nx;
            break;
          case B_:
            p = gx;
            break;
          case "scroll":
            p = $y;
            break;
          case "wheel":
            p = vx;
            break;
          case "copy":
          case "cut":
          case "paste":
            p = rx;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = Xh;
        }
        var x = (e & 4) !== 0,
          m = !x && n === "scroll",
          h = x ? (d !== null ? d + "Capture" : null) : d;
        x = [];
        for (var _ = c, g; _ !== null; ) {
          g = _;
          var E = g.stateNode;
          if (
            (g.tag === 5 &&
              E !== null &&
              ((g = E),
              h !== null && ((E = ua(_, h)), E != null && x.push(_a(_, E, g)))),
            m)
          )
            break;
          _ = _.return;
        }
        0 < x.length &&
          ((d = new p(d, v, null, t, u)), f.push({ event: d, listeners: x }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((d = n === "mouseover" || n === "pointerover"),
          (p = n === "mouseout" || n === "pointerout"),
          d &&
            t !== gf &&
            (v = t.relatedTarget || t.fromElement) &&
            (Yr(v) || v[Vi]))
        )
          break e;
        if (
          (p || d) &&
          ((d =
            u.window === u
              ? u
              : (d = u.ownerDocument)
              ? d.defaultView || d.parentWindow
              : window),
          p
            ? ((v = t.relatedTarget || t.toElement),
              (p = c),
              (v = v ? Yr(v) : null),
              v !== null &&
                ((m = fs(v)), v !== m || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((p = null), (v = c)),
          p !== v)
        ) {
          if (
            ((x = Gh),
            (E = "onMouseLeave"),
            (h = "onMouseEnter"),
            (_ = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((x = Xh),
              (E = "onPointerLeave"),
              (h = "onPointerEnter"),
              (_ = "pointer")),
            (m = p == null ? d : Bs(p)),
            (g = v == null ? d : Bs(v)),
            (d = new x(E, _ + "leave", p, t, u)),
            (d.target = m),
            (d.relatedTarget = g),
            (E = null),
            Yr(u) === c &&
              ((x = new x(h, _ + "enter", v, t, u)),
              (x.target = g),
              (x.relatedTarget = m),
              (E = x)),
            (m = E),
            p && v)
          )
            t: {
              for (x = p, h = v, _ = 0, g = x; g; g = ps(g)) _++;
              for (g = 0, E = h; E; E = ps(E)) g++;
              for (; 0 < _ - g; ) (x = ps(x)), _--;
              for (; 0 < g - _; ) (h = ps(h)), g--;
              for (; _--; ) {
                if (x === h || (h !== null && x === h.alternate)) break t;
                (x = ps(x)), (h = ps(h));
              }
              x = null;
            }
          else x = null;
          p !== null && np(f, d, p, x, !1),
            v !== null && m !== null && np(f, m, v, x, !0);
        }
      }
      e: {
        if (
          ((d = c ? Bs(c) : window),
          (p = d.nodeName && d.nodeName.toLowerCase()),
          p === "select" || (p === "input" && d.type === "file"))
        )
          var w = wx;
        else if (qh(d))
          if (P_) w = Cx;
          else {
            w = Rx;
            var L = Ax;
          }
        else
          (p = d.nodeName) &&
            p.toLowerCase() === "input" &&
            (d.type === "checkbox" || d.type === "radio") &&
            (w = bx);
        if (w && (w = w(n, c))) {
          L_(f, w, t, u);
          break e;
        }
        L && L(n, d, c),
          n === "focusout" &&
            (L = d._wrapperState) &&
            L.controlled &&
            d.type === "number" &&
            ff(d, "number", d.value);
      }
      switch (((L = c ? Bs(c) : window), n)) {
        case "focusin":
          (qh(L) || L.contentEditable === "true") &&
            ((Fs = L), (Mf = c), (Jo = null));
          break;
        case "focusout":
          Jo = Mf = Fs = null;
          break;
        case "mousedown":
          Tf = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (Tf = !1), Jh(f, t, u);
          break;
        case "selectionchange":
          if (Ix) break;
        case "keydown":
        case "keyup":
          Jh(f, t, u);
      }
      var A;
      if (Ld)
        e: {
          switch (n) {
            case "compositionstart":
              var U = "onCompositionStart";
              break e;
            case "compositionend":
              U = "onCompositionEnd";
              break e;
            case "compositionupdate":
              U = "onCompositionUpdate";
              break e;
          }
          U = void 0;
        }
      else
        Os
          ? b_(n, t) && (U = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (U = "onCompositionStart");
      U &&
        (R_ &&
          t.locale !== "ko" &&
          (Os || U !== "onCompositionStart"
            ? U === "onCompositionEnd" && Os && (A = A_())
            : ((ur = u),
              (Rd = "value" in ur ? ur.value : ur.textContent),
              (Os = !0))),
        (L = $l(c, U)),
        0 < L.length &&
          ((U = new Wh(U, n, null, t, u)),
          f.push({ event: U, listeners: L }),
          A ? (U.data = A) : ((A = C_(t)), A !== null && (U.data = A)))),
        (A = xx ? Sx(n, t) : Ex(n, t)) &&
          ((c = $l(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new Wh("onBeforeInput", "beforeinput", null, t, u)),
            f.push({ event: u, listeners: c }),
            (u.data = A)));
    }
    H_(f, e);
  });
}
function _a(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function $l(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = ua(n, t)),
      s != null && i.unshift(_a(n, s, r)),
      (s = ua(n, e)),
      s != null && i.push(_a(n, s, r))),
      (n = n.return);
  }
  return i;
}
function ps(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function np(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t,
      l = a.alternate,
      c = a.stateNode;
    if (l !== null && l === i) break;
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      r
        ? ((l = ua(t, s)), l != null && o.unshift(_a(t, l, a)))
        : r || ((l = ua(t, s)), l != null && o.push(_a(t, l, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var Ox = /\r\n?/g,
  Fx = /\u0000|\uFFFD/g;
function ip(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      Ox,
      `
`
    )
    .replace(Fx, "");
}
function Ya(n, e, t) {
  if (((e = ip(e)), ip(n) !== e && t)) throw Error(ue(425));
}
function Ql() {}
var wf = null,
  Af = null;
function Rf(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var bf = typeof setTimeout == "function" ? setTimeout : void 0,
  kx = typeof clearTimeout == "function" ? clearTimeout : void 0,
  rp = typeof Promise == "function" ? Promise : void 0,
  Bx =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof rp < "u"
      ? function (n) {
          return rp.resolve(null).then(n).catch(zx);
        }
      : bf;
function zx(n) {
  setTimeout(function () {
    throw n;
  });
}
function ou(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          n.removeChild(r), ha(e);
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  ha(e);
}
function _r(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function sp(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var Eo = Math.random().toString(36).slice(2),
  gi = "__reactFiber$" + Eo,
  va = "__reactProps$" + Eo,
  Vi = "__reactContainer$" + Eo,
  Cf = "__reactEvents$" + Eo,
  Hx = "__reactListeners$" + Eo,
  Vx = "__reactHandles$" + Eo;
function Yr(n) {
  var e = n[gi];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Vi] || t[gi])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = sp(n); n !== null; ) {
          if ((t = n[gi])) return t;
          n = sp(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function La(n) {
  return (
    (n = n[gi] || n[Vi]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function Bs(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(ue(33));
}
function Rc(n) {
  return n[va] || null;
}
var Lf = [],
  zs = -1;
function Ir(n) {
  return { current: n };
}
function Et(n) {
  0 > zs || ((n.current = Lf[zs]), (Lf[zs] = null), zs--);
}
function vt(n, e) {
  zs++, (Lf[zs] = n.current), (n.current = e);
}
var Rr = {},
  cn = Ir(Rr),
  Mn = Ir(!1),
  is = Rr;
function io(n, e) {
  var t = n.type.contextTypes;
  if (!t) return Rr;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in t) r[s] = e[s];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function Tn(n) {
  return (n = n.childContextTypes), n != null;
}
function Jl() {
  Et(Mn), Et(cn);
}
function op(n, e, t) {
  if (cn.current !== Rr) throw Error(ue(168));
  vt(cn, e), vt(Mn, t);
}
function G_(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(ue(108, Ay(n) || "Unknown", r));
  return Lt({}, t, i);
}
function ec(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || Rr),
    (is = cn.current),
    vt(cn, n),
    vt(Mn, Mn.current),
    !0
  );
}
function ap(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(ue(169));
  t
    ? ((n = G_(n, e, is)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      Et(Mn),
      Et(cn),
      vt(cn, n))
    : Et(Mn),
    vt(Mn, t);
}
var Di = null,
  bc = !1,
  au = !1;
function W_(n) {
  Di === null ? (Di = [n]) : Di.push(n);
}
function Gx(n) {
  (bc = !0), W_(n);
}
function Nr() {
  if (!au && Di !== null) {
    au = !0;
    var n = 0,
      e = ft;
    try {
      var t = Di;
      for (ft = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      (Di = null), (bc = !1);
    } catch (r) {
      throw (Di !== null && (Di = Di.slice(n + 1)), m_(Md, Nr), r);
    } finally {
      (ft = e), (au = !1);
    }
  }
  return null;
}
var Hs = [],
  Vs = 0,
  tc = null,
  nc = 0,
  Vn = [],
  Gn = 0,
  rs = null,
  Oi = 1,
  Fi = "";
function Vr(n, e) {
  (Hs[Vs++] = nc), (Hs[Vs++] = tc), (tc = n), (nc = e);
}
function X_(n, e, t) {
  (Vn[Gn++] = Oi), (Vn[Gn++] = Fi), (Vn[Gn++] = rs), (rs = n);
  var i = Oi;
  n = Fi;
  var r = 32 - ai(i) - 1;
  (i &= ~(1 << r)), (t += 1);
  var s = 32 - ai(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    (s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (Oi = (1 << (32 - ai(e) + r)) | (t << r) | i),
      (Fi = s + n);
  } else (Oi = (1 << s) | (t << r) | i), (Fi = n);
}
function Id(n) {
  n.return !== null && (Vr(n, 1), X_(n, 1, 0));
}
function Nd(n) {
  for (; n === tc; )
    (tc = Hs[--Vs]), (Hs[Vs] = null), (nc = Hs[--Vs]), (Hs[Vs] = null);
  for (; n === rs; )
    (rs = Vn[--Gn]),
      (Vn[Gn] = null),
      (Fi = Vn[--Gn]),
      (Vn[Gn] = null),
      (Oi = Vn[--Gn]),
      (Vn[Gn] = null);
}
var Un = null,
  Nn = null,
  wt = !1,
  ri = null;
function j_(n, e) {
  var t = Xn(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function lp(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (Un = n), (Nn = _r(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (Un = n), (Nn = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = rs !== null ? { id: Oi, overflow: Fi } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = Xn(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (Un = n),
            (Nn = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Pf(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function If(n) {
  if (wt) {
    var e = Nn;
    if (e) {
      var t = e;
      if (!lp(n, e)) {
        if (Pf(n)) throw Error(ue(418));
        e = _r(t.nextSibling);
        var i = Un;
        e && lp(n, e)
          ? j_(i, t)
          : ((n.flags = (n.flags & -4097) | 2), (wt = !1), (Un = n));
      }
    } else {
      if (Pf(n)) throw Error(ue(418));
      (n.flags = (n.flags & -4097) | 2), (wt = !1), (Un = n);
    }
  }
}
function cp(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  Un = n;
}
function qa(n) {
  if (n !== Un) return !1;
  if (!wt) return cp(n), (wt = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !Rf(n.type, n.memoizedProps))),
    e && (e = Nn))
  ) {
    if (Pf(n)) throw (Y_(), Error(ue(418)));
    for (; e; ) j_(n, e), (e = _r(e.nextSibling));
  }
  if ((cp(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(ue(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              Nn = _r(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      Nn = null;
    }
  } else Nn = Un ? _r(n.stateNode.nextSibling) : null;
  return !0;
}
function Y_() {
  for (var n = Nn; n; ) n = _r(n.nextSibling);
}
function ro() {
  (Nn = Un = null), (wt = !1);
}
function Dd(n) {
  ri === null ? (ri = [n]) : ri.push(n);
}
var Wx = ji.ReactCurrentBatchConfig;
function ni(n, e) {
  if (n && n.defaultProps) {
    (e = Lt({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
var ic = Ir(null),
  rc = null,
  Gs = null,
  Ud = null;
function Od() {
  Ud = Gs = rc = null;
}
function Fd(n) {
  var e = ic.current;
  Et(ic), (n._currentValue = e);
}
function Nf(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function $s(n, e) {
  (rc = n),
    (Ud = Gs = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (En = !0), (n.firstContext = null));
}
function Kn(n) {
  var e = n._currentValue;
  if (Ud !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), Gs === null)) {
      if (rc === null) throw Error(ue(308));
      (Gs = n), (rc.dependencies = { lanes: 0, firstContext: n });
    } else Gs = Gs.next = n;
  return e;
}
var qr = null;
function kd(n) {
  qr === null ? (qr = [n]) : qr.push(n);
}
function q_(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), kd(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    Gi(n, i)
  );
}
function Gi(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var sr = !1;
function Bd(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function K_(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function zi(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function vr(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), ot & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      Gi(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), kd(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    Gi(n, t)
  );
}
function Ul(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), Td(n, t);
  }
}
function up(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (r = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function sc(n, e, t, i) {
  var r = n.updateQueue;
  sr = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var l = a,
      c = l.next;
    (l.next = null), o === null ? (s = c) : (o.next = c), (o = l);
    var u = n.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== o &&
        (a === null ? (u.firstBaseUpdate = c) : (a.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var f = r.baseState;
    (o = 0), (u = c = l = null), (a = s);
    do {
      var d = a.lane,
        p = a.eventTime;
      if ((i & d) === d) {
        u !== null &&
          (u = u.next =
            {
              eventTime: p,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var v = n,
            x = a;
          switch (((d = e), (p = t), x.tag)) {
            case 1:
              if (((v = x.payload), typeof v == "function")) {
                f = v.call(p, f, d);
                break e;
              }
              f = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = x.payload),
                (d = typeof v == "function" ? v.call(p, f, d) : v),
                d == null)
              )
                break e;
              f = Lt({}, f, d);
              break e;
            case 2:
              sr = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (d = r.effects),
          d === null ? (r.effects = [a]) : d.push(a));
      } else
        (p = {
          eventTime: p,
          lane: d,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = p), (l = f)) : (u = u.next = p),
          (o |= d);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (d = a),
          (a = d.next),
          (d.next = null),
          (r.lastBaseUpdate = d),
          (r.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = f),
      (r.baseState = l),
      (r.firstBaseUpdate = c),
      (r.lastBaseUpdate = u),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (o |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (os |= o), (n.lanes = o), (n.memoizedState = f);
  }
}
function fp(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(ue(191, r));
        r.call(i);
      }
    }
}
var Z_ = new qg.Component().refs;
function Df(n, e, t, i) {
  (e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : Lt({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var Cc = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? fs(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = mn(),
      r = xr(n),
      s = zi(i, r);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = vr(n, s, r)),
      e !== null && (li(e, n, r, i), Ul(e, n, r));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = mn(),
      r = xr(n),
      s = zi(i, r);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = vr(n, s, r)),
      e !== null && (li(e, n, r, i), Ul(e, n, r));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = mn(),
      i = xr(n),
      r = zi(t, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = vr(n, r, i)),
      e !== null && (li(e, n, i, t), Ul(e, n, i));
  },
};
function dp(n, e, t, i, r, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !ma(t, i) || !ma(r, s)
      : !0
  );
}
function $_(n, e, t) {
  var i = !1,
    r = Rr,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = Kn(s))
      : ((r = Tn(e) ? is : cn.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? io(n, r) : Rr)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = Cc),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function hp(n, e, t, i) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && Cc.enqueueReplaceState(e, e.state, null);
}
function Uf(n, e, t, i) {
  var r = n.stateNode;
  (r.props = t), (r.state = n.memoizedState), (r.refs = Z_), Bd(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = Kn(s))
    : ((s = Tn(e) ? is : cn.current), (r.context = io(n, s))),
    (r.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (Df(n, e, s, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && Cc.enqueueReplaceState(r, r.state, null),
      sc(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function No(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(ue(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(ue(147, n));
      var r = i,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            a === Z_ && (a = r.refs = {}),
              o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(ue(284));
    if (!t._owner) throw Error(ue(290, n));
  }
  return n;
}
function Ka(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      ue(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function pp(n) {
  var e = n._init;
  return e(n._payload);
}
function Q_(n) {
  function e(h, _) {
    if (n) {
      var g = h.deletions;
      g === null ? ((h.deletions = [_]), (h.flags |= 16)) : g.push(_);
    }
  }
  function t(h, _) {
    if (!n) return null;
    for (; _ !== null; ) e(h, _), (_ = _.sibling);
    return null;
  }
  function i(h, _) {
    for (h = new Map(); _ !== null; )
      _.key !== null ? h.set(_.key, _) : h.set(_.index, _), (_ = _.sibling);
    return h;
  }
  function r(h, _) {
    return (h = Sr(h, _)), (h.index = 0), (h.sibling = null), h;
  }
  function s(h, _, g) {
    return (
      (h.index = g),
      n
        ? ((g = h.alternate),
          g !== null
            ? ((g = g.index), g < _ ? ((h.flags |= 2), _) : g)
            : ((h.flags |= 2), _))
        : ((h.flags |= 1048576), _)
    );
  }
  function o(h) {
    return n && h.alternate === null && (h.flags |= 2), h;
  }
  function a(h, _, g, E) {
    return _ === null || _.tag !== 6
      ? ((_ = pu(g, h.mode, E)), (_.return = h), _)
      : ((_ = r(_, g)), (_.return = h), _);
  }
  function l(h, _, g, E) {
    var w = g.type;
    return w === Us
      ? u(h, _, g.props.children, E, g.key)
      : _ !== null &&
        (_.elementType === w ||
          (typeof w == "object" &&
            w !== null &&
            w.$$typeof === rr &&
            pp(w) === _.type))
      ? ((E = r(_, g.props)), (E.ref = No(h, _, g)), (E.return = h), E)
      : ((E = Hl(g.type, g.key, g.props, null, h.mode, E)),
        (E.ref = No(h, _, g)),
        (E.return = h),
        E);
  }
  function c(h, _, g, E) {
    return _ === null ||
      _.tag !== 4 ||
      _.stateNode.containerInfo !== g.containerInfo ||
      _.stateNode.implementation !== g.implementation
      ? ((_ = mu(g, h.mode, E)), (_.return = h), _)
      : ((_ = r(_, g.children || [])), (_.return = h), _);
  }
  function u(h, _, g, E, w) {
    return _ === null || _.tag !== 7
      ? ((_ = Jr(g, h.mode, E, w)), (_.return = h), _)
      : ((_ = r(_, g)), (_.return = h), _);
  }
  function f(h, _, g) {
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return (_ = pu("" + _, h.mode, g)), (_.return = h), _;
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case ka:
          return (
            (g = Hl(_.type, _.key, _.props, null, h.mode, g)),
            (g.ref = No(h, null, _)),
            (g.return = h),
            g
          );
        case Ds:
          return (_ = mu(_, h.mode, g)), (_.return = h), _;
        case rr:
          var E = _._init;
          return f(h, E(_._payload), g);
      }
      if (Xo(_) || bo(_))
        return (_ = Jr(_, h.mode, g, null)), (_.return = h), _;
      Ka(h, _);
    }
    return null;
  }
  function d(h, _, g, E) {
    var w = _ !== null ? _.key : null;
    if ((typeof g == "string" && g !== "") || typeof g == "number")
      return w !== null ? null : a(h, _, "" + g, E);
    if (typeof g == "object" && g !== null) {
      switch (g.$$typeof) {
        case ka:
          return g.key === w ? l(h, _, g, E) : null;
        case Ds:
          return g.key === w ? c(h, _, g, E) : null;
        case rr:
          return (w = g._init), d(h, _, w(g._payload), E);
      }
      if (Xo(g) || bo(g)) return w !== null ? null : u(h, _, g, E, null);
      Ka(h, g);
    }
    return null;
  }
  function p(h, _, g, E, w) {
    if ((typeof E == "string" && E !== "") || typeof E == "number")
      return (h = h.get(g) || null), a(_, h, "" + E, w);
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case ka:
          return (h = h.get(E.key === null ? g : E.key) || null), l(_, h, E, w);
        case Ds:
          return (h = h.get(E.key === null ? g : E.key) || null), c(_, h, E, w);
        case rr:
          var L = E._init;
          return p(h, _, g, L(E._payload), w);
      }
      if (Xo(E) || bo(E)) return (h = h.get(g) || null), u(_, h, E, w, null);
      Ka(_, E);
    }
    return null;
  }
  function v(h, _, g, E) {
    for (
      var w = null, L = null, A = _, U = (_ = 0), M = null;
      A !== null && U < g.length;
      U++
    ) {
      A.index > U ? ((M = A), (A = null)) : (M = A.sibling);
      var b = d(h, A, g[U], E);
      if (b === null) {
        A === null && (A = M);
        break;
      }
      n && A && b.alternate === null && e(h, A),
        (_ = s(b, _, U)),
        L === null ? (w = b) : (L.sibling = b),
        (L = b),
        (A = M);
    }
    if (U === g.length) return t(h, A), wt && Vr(h, U), w;
    if (A === null) {
      for (; U < g.length; U++)
        (A = f(h, g[U], E)),
          A !== null &&
            ((_ = s(A, _, U)), L === null ? (w = A) : (L.sibling = A), (L = A));
      return wt && Vr(h, U), w;
    }
    for (A = i(h, A); U < g.length; U++)
      (M = p(A, h, U, g[U], E)),
        M !== null &&
          (n && M.alternate !== null && A.delete(M.key === null ? U : M.key),
          (_ = s(M, _, U)),
          L === null ? (w = M) : (L.sibling = M),
          (L = M));
    return (
      n &&
        A.forEach(function ($) {
          return e(h, $);
        }),
      wt && Vr(h, U),
      w
    );
  }
  function x(h, _, g, E) {
    var w = bo(g);
    if (typeof w != "function") throw Error(ue(150));
    if (((g = w.call(g)), g == null)) throw Error(ue(151));
    for (
      var L = (w = null), A = _, U = (_ = 0), M = null, b = g.next();
      A !== null && !b.done;
      U++, b = g.next()
    ) {
      A.index > U ? ((M = A), (A = null)) : (M = A.sibling);
      var $ = d(h, A, b.value, E);
      if ($ === null) {
        A === null && (A = M);
        break;
      }
      n && A && $.alternate === null && e(h, A),
        (_ = s($, _, U)),
        L === null ? (w = $) : (L.sibling = $),
        (L = $),
        (A = M);
    }
    if (b.done) return t(h, A), wt && Vr(h, U), w;
    if (A === null) {
      for (; !b.done; U++, b = g.next())
        (b = f(h, b.value, E)),
          b !== null &&
            ((_ = s(b, _, U)), L === null ? (w = b) : (L.sibling = b), (L = b));
      return wt && Vr(h, U), w;
    }
    for (A = i(h, A); !b.done; U++, b = g.next())
      (b = p(A, h, U, b.value, E)),
        b !== null &&
          (n && b.alternate !== null && A.delete(b.key === null ? U : b.key),
          (_ = s(b, _, U)),
          L === null ? (w = b) : (L.sibling = b),
          (L = b));
    return (
      n &&
        A.forEach(function (J) {
          return e(h, J);
        }),
      wt && Vr(h, U),
      w
    );
  }
  function m(h, _, g, E) {
    if (
      (typeof g == "object" &&
        g !== null &&
        g.type === Us &&
        g.key === null &&
        (g = g.props.children),
      typeof g == "object" && g !== null)
    ) {
      switch (g.$$typeof) {
        case ka:
          e: {
            for (var w = g.key, L = _; L !== null; ) {
              if (L.key === w) {
                if (((w = g.type), w === Us)) {
                  if (L.tag === 7) {
                    t(h, L.sibling),
                      (_ = r(L, g.props.children)),
                      (_.return = h),
                      (h = _);
                    break e;
                  }
                } else if (
                  L.elementType === w ||
                  (typeof w == "object" &&
                    w !== null &&
                    w.$$typeof === rr &&
                    pp(w) === L.type)
                ) {
                  t(h, L.sibling),
                    (_ = r(L, g.props)),
                    (_.ref = No(h, L, g)),
                    (_.return = h),
                    (h = _);
                  break e;
                }
                t(h, L);
                break;
              } else e(h, L);
              L = L.sibling;
            }
            g.type === Us
              ? ((_ = Jr(g.props.children, h.mode, E, g.key)),
                (_.return = h),
                (h = _))
              : ((E = Hl(g.type, g.key, g.props, null, h.mode, E)),
                (E.ref = No(h, _, g)),
                (E.return = h),
                (h = E));
          }
          return o(h);
        case Ds:
          e: {
            for (L = g.key; _ !== null; ) {
              if (_.key === L)
                if (
                  _.tag === 4 &&
                  _.stateNode.containerInfo === g.containerInfo &&
                  _.stateNode.implementation === g.implementation
                ) {
                  t(h, _.sibling),
                    (_ = r(_, g.children || [])),
                    (_.return = h),
                    (h = _);
                  break e;
                } else {
                  t(h, _);
                  break;
                }
              else e(h, _);
              _ = _.sibling;
            }
            (_ = mu(g, h.mode, E)), (_.return = h), (h = _);
          }
          return o(h);
        case rr:
          return (L = g._init), m(h, _, L(g._payload), E);
      }
      if (Xo(g)) return v(h, _, g, E);
      if (bo(g)) return x(h, _, g, E);
      Ka(h, g);
    }
    return (typeof g == "string" && g !== "") || typeof g == "number"
      ? ((g = "" + g),
        _ !== null && _.tag === 6
          ? (t(h, _.sibling), (_ = r(_, g)), (_.return = h), (h = _))
          : (t(h, _), (_ = pu(g, h.mode, E)), (_.return = h), (h = _)),
        o(h))
      : t(h, _);
  }
  return m;
}
var so = Q_(!0),
  J_ = Q_(!1),
  Pa = {},
  yi = Ir(Pa),
  ya = Ir(Pa),
  xa = Ir(Pa);
function Kr(n) {
  if (n === Pa) throw Error(ue(174));
  return n;
}
function zd(n, e) {
  switch ((vt(xa, e), vt(ya, n), vt(yi, Pa), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : hf(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = hf(e, n));
  }
  Et(yi), vt(yi, e);
}
function oo() {
  Et(yi), Et(ya), Et(xa);
}
function e0(n) {
  Kr(xa.current);
  var e = Kr(yi.current),
    t = hf(e, n.type);
  e !== t && (vt(ya, n), vt(yi, t));
}
function Hd(n) {
  ya.current === n && (Et(yi), Et(ya));
}
var At = Ir(0);
function oc(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var lu = [];
function Vd() {
  for (var n = 0; n < lu.length; n++)
    lu[n]._workInProgressVersionPrimary = null;
  lu.length = 0;
}
var Ol = ji.ReactCurrentDispatcher,
  cu = ji.ReactCurrentBatchConfig,
  ss = 0,
  bt = null,
  Bt = null,
  Yt = null,
  ac = !1,
  ea = !1,
  Sa = 0,
  Xx = 0;
function rn() {
  throw Error(ue(321));
}
function Gd(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!ui(n[t], e[t])) return !1;
  return !0;
}
function Wd(n, e, t, i, r, s) {
  if (
    ((ss = s),
    (bt = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Ol.current = n === null || n.memoizedState === null ? Kx : Zx),
    (n = t(i, r)),
    ea)
  ) {
    s = 0;
    do {
      if (((ea = !1), (Sa = 0), 25 <= s)) throw Error(ue(301));
      (s += 1),
        (Yt = Bt = null),
        (e.updateQueue = null),
        (Ol.current = $x),
        (n = t(i, r));
    } while (ea);
  }
  if (
    ((Ol.current = lc),
    (e = Bt !== null && Bt.next !== null),
    (ss = 0),
    (Yt = Bt = bt = null),
    (ac = !1),
    e)
  )
    throw Error(ue(300));
  return n;
}
function Xd() {
  var n = Sa !== 0;
  return (Sa = 0), n;
}
function pi() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return Yt === null ? (bt.memoizedState = Yt = n) : (Yt = Yt.next = n), Yt;
}
function Zn() {
  if (Bt === null) {
    var n = bt.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Bt.next;
  var e = Yt === null ? bt.memoizedState : Yt.next;
  if (e !== null) (Yt = e), (Bt = n);
  else {
    if (n === null) throw Error(ue(310));
    (Bt = n),
      (n = {
        memoizedState: Bt.memoizedState,
        baseState: Bt.baseState,
        baseQueue: Bt.baseQueue,
        queue: Bt.queue,
        next: null,
      }),
      Yt === null ? (bt.memoizedState = Yt = n) : (Yt = Yt.next = n);
  }
  return Yt;
}
function Ea(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function uu(n) {
  var e = Zn(),
    t = e.queue;
  if (t === null) throw Error(ue(311));
  t.lastRenderedReducer = n;
  var i = Bt,
    r = i.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      (r.next = s.next), (s.next = o);
    }
    (i.baseQueue = r = s), (t.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var a = (o = null),
      l = null,
      c = s;
    do {
      var u = c.lane;
      if ((ss & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (i = c.hasEagerState ? c.eagerState : n(i, c.action));
      else {
        var f = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((a = l = f), (o = i)) : (l = l.next = f),
          (bt.lanes |= u),
          (os |= u);
      }
      c = c.next;
    } while (c !== null && c !== s);
    l === null ? (o = i) : (l.next = a),
      ui(i, e.memoizedState) || (En = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = i);
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do (s = r.lane), (bt.lanes |= s), (os |= s), (r = r.next);
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function fu(n) {
  var e = Zn(),
    t = e.queue;
  if (t === null) throw Error(ue(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = (r = r.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== r);
    ui(s, e.memoizedState) || (En = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, i];
}
function t0() {}
function n0(n, e) {
  var t = bt,
    i = Zn(),
    r = e(),
    s = !ui(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (En = !0)),
    (i = i.queue),
    jd(s0.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || (Yt !== null && Yt.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      Ma(9, r0.bind(null, t, i, r, e), void 0, null),
      Zt === null)
    )
      throw Error(ue(349));
    ss & 30 || i0(t, e, r);
  }
  return r;
}
function i0(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = bt.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (bt.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function r0(n, e, t, i) {
  (e.value = t), (e.getSnapshot = i), o0(e) && a0(n);
}
function s0(n, e, t) {
  return t(function () {
    o0(e) && a0(n);
  });
}
function o0(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !ui(n, t);
  } catch {
    return !0;
  }
}
function a0(n) {
  var e = Gi(n, 1);
  e !== null && li(e, n, 1, -1);
}
function mp(n) {
  var e = pi();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Ea,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = qx.bind(null, bt, n)),
    [e.memoizedState, n]
  );
}
function Ma(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = bt.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (bt.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function l0() {
  return Zn().memoizedState;
}
function Fl(n, e, t, i) {
  var r = pi();
  (bt.flags |= n),
    (r.memoizedState = Ma(1 | e, t, void 0, i === void 0 ? null : i));
}
function Lc(n, e, t, i) {
  var r = Zn();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Bt !== null) {
    var o = Bt.memoizedState;
    if (((s = o.destroy), i !== null && Gd(i, o.deps))) {
      r.memoizedState = Ma(e, t, s, i);
      return;
    }
  }
  (bt.flags |= n), (r.memoizedState = Ma(1 | e, t, s, i));
}
function gp(n, e) {
  return Fl(8390656, 8, n, e);
}
function jd(n, e) {
  return Lc(2048, 8, n, e);
}
function c0(n, e) {
  return Lc(4, 2, n, e);
}
function u0(n, e) {
  return Lc(4, 4, n, e);
}
function f0(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function d0(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), Lc(4, 4, f0.bind(null, e, n), t)
  );
}
function Yd() {}
function h0(n, e) {
  var t = Zn();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && Gd(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function p0(n, e) {
  var t = Zn();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && Gd(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function m0(n, e, t) {
  return ss & 21
    ? (ui(t, e) || ((t = v_()), (bt.lanes |= t), (os |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (En = !0)), (n.memoizedState = t));
}
function jx(n, e) {
  var t = ft;
  (ft = t !== 0 && 4 > t ? t : 4), n(!0);
  var i = cu.transition;
  cu.transition = {};
  try {
    n(!1), e();
  } finally {
    (ft = t), (cu.transition = i);
  }
}
function g0() {
  return Zn().memoizedState;
}
function Yx(n, e, t) {
  var i = xr(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    _0(n))
  )
    v0(e, t);
  else if (((t = q_(n, e, t, i)), t !== null)) {
    var r = mn();
    li(t, n, i, r), y0(t, e, i);
  }
}
function qx(n, e, t) {
  var i = xr(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (_0(n)) v0(e, r);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), ui(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((r.next = r), kd(e))
            : ((r.next = l.next), (l.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (t = q_(n, e, r, i)),
      t !== null && ((r = mn()), li(t, n, i, r), y0(t, e, i));
  }
}
function _0(n) {
  var e = n.alternate;
  return n === bt || (e !== null && e === bt);
}
function v0(n, e) {
  ea = ac = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function y0(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), Td(n, t);
  }
}
var lc = {
    readContext: Kn,
    useCallback: rn,
    useContext: rn,
    useEffect: rn,
    useImperativeHandle: rn,
    useInsertionEffect: rn,
    useLayoutEffect: rn,
    useMemo: rn,
    useReducer: rn,
    useRef: rn,
    useState: rn,
    useDebugValue: rn,
    useDeferredValue: rn,
    useTransition: rn,
    useMutableSource: rn,
    useSyncExternalStore: rn,
    useId: rn,
    unstable_isNewReconciler: !1,
  },
  Kx = {
    readContext: Kn,
    useCallback: function (n, e) {
      return (pi().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: Kn,
    useEffect: gp,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        Fl(4194308, 4, f0.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return Fl(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return Fl(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = pi();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var i = pi();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = Yx.bind(null, bt, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = pi();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: mp,
    useDebugValue: Yd,
    useDeferredValue: function (n) {
      return (pi().memoizedState = n);
    },
    useTransition: function () {
      var n = mp(!1),
        e = n[0];
      return (n = jx.bind(null, n[1])), (pi().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = bt,
        r = pi();
      if (wt) {
        if (t === void 0) throw Error(ue(407));
        t = t();
      } else {
        if (((t = e()), Zt === null)) throw Error(ue(349));
        ss & 30 || i0(i, e, t);
      }
      r.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (r.queue = s),
        gp(s0.bind(null, i, s, n), [n]),
        (i.flags |= 2048),
        Ma(9, r0.bind(null, i, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = pi(),
        e = Zt.identifierPrefix;
      if (wt) {
        var t = Fi,
          i = Oi;
        (t = (i & ~(1 << (32 - ai(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = Sa++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = Xx++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  Zx = {
    readContext: Kn,
    useCallback: h0,
    useContext: Kn,
    useEffect: jd,
    useImperativeHandle: d0,
    useInsertionEffect: c0,
    useLayoutEffect: u0,
    useMemo: p0,
    useReducer: uu,
    useRef: l0,
    useState: function () {
      return uu(Ea);
    },
    useDebugValue: Yd,
    useDeferredValue: function (n) {
      var e = Zn();
      return m0(e, Bt.memoizedState, n);
    },
    useTransition: function () {
      var n = uu(Ea)[0],
        e = Zn().memoizedState;
      return [n, e];
    },
    useMutableSource: t0,
    useSyncExternalStore: n0,
    useId: g0,
    unstable_isNewReconciler: !1,
  },
  $x = {
    readContext: Kn,
    useCallback: h0,
    useContext: Kn,
    useEffect: jd,
    useImperativeHandle: d0,
    useInsertionEffect: c0,
    useLayoutEffect: u0,
    useMemo: p0,
    useReducer: fu,
    useRef: l0,
    useState: function () {
      return fu(Ea);
    },
    useDebugValue: Yd,
    useDeferredValue: function (n) {
      var e = Zn();
      return Bt === null ? (e.memoizedState = n) : m0(e, Bt.memoizedState, n);
    },
    useTransition: function () {
      var n = fu(Ea)[0],
        e = Zn().memoizedState;
      return [n, e];
    },
    useMutableSource: t0,
    useSyncExternalStore: n0,
    useId: g0,
    unstable_isNewReconciler: !1,
  };
function ao(n, e) {
  try {
    var t = "",
      i = e;
    do (t += wy(i)), (i = i.return);
    while (i);
    var r = t;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function du(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function Of(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var Qx = typeof WeakMap == "function" ? WeakMap : Map;
function x0(n, e, t) {
  (t = zi(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var i = e.value;
  return (
    (t.callback = function () {
      uc || ((uc = !0), (jf = i)), Of(n, e);
    }),
    t
  );
}
function S0(n, e, t) {
  (t = zi(-1, t)), (t.tag = 3);
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        Of(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        Of(n, e),
          typeof i != "function" &&
            (yr === null ? (yr = new Set([this])) : yr.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function _p(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new Qx();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(t) || (r.add(t), (n = dS.bind(null, n, e, t)), e.then(n, n));
}
function vp(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function yp(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = zi(-1, 1)), (e.tag = 2), vr(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var Jx = ji.ReactCurrentOwner,
  En = !1;
function hn(n, e, t, i) {
  e.child = n === null ? J_(e, null, t, i) : so(e, n.child, t, i);
}
function xp(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return (
    $s(e, r),
    (i = Wd(n, e, t, i, s, r)),
    (t = Xd()),
    n !== null && !En
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Wi(n, e, r))
      : (wt && t && Id(e), (e.flags |= 1), hn(n, e, i, r), e.child)
  );
}
function Sp(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !th(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), E0(n, e, s, i, r))
      : ((n = Hl(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : ma), t(o, i) && n.ref === e.ref)
    )
      return Wi(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = Sr(s, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function E0(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (ma(s, i) && n.ref === e.ref)
      if (((En = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
        n.flags & 131072 && (En = !0);
      else return (e.lanes = n.lanes), Wi(n, e, r);
  }
  return Ff(n, e, t, i, r);
}
function M0(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        vt(Xs, Cn),
        (Cn |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          vt(Xs, Cn),
          (Cn |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : t),
        vt(Xs, Cn),
        (Cn |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
      vt(Xs, Cn),
      (Cn |= i);
  return hn(n, e, r, t), e.child;
}
function T0(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Ff(n, e, t, i, r) {
  var s = Tn(t) ? is : cn.current;
  return (
    (s = io(e, s)),
    $s(e, r),
    (t = Wd(n, e, t, i, s, r)),
    (i = Xd()),
    n !== null && !En
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        Wi(n, e, r))
      : (wt && i && Id(e), (e.flags |= 1), hn(n, e, t, r), e.child)
  );
}
function Ep(n, e, t, i, r) {
  if (Tn(t)) {
    var s = !0;
    ec(e);
  } else s = !1;
  if (($s(e, r), e.stateNode === null))
    kl(n, e), $_(e, t, i), Uf(e, t, i, r), (i = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      c = t.contextType;
    typeof c == "object" && c !== null
      ? (c = Kn(c))
      : ((c = Tn(t) ? is : cn.current), (c = io(e, c)));
    var u = t.getDerivedStateFromProps,
      f =
        typeof u == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    f ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || l !== c) && hp(e, o, i, c)),
      (sr = !1);
    var d = e.memoizedState;
    (o.state = d),
      sc(e, i, o, r),
      (l = e.memoizedState),
      a !== i || d !== l || Mn.current || sr
        ? (typeof u == "function" && (Df(e, t, u, i), (l = e.memoizedState)),
          (a = sr || dp(e, t, a, i, d, l, c))
            ? (f ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = l)),
          (o.props = i),
          (o.state = l),
          (o.context = c),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (o = e.stateNode),
      K_(n, e),
      (a = e.memoizedProps),
      (c = e.type === e.elementType ? a : ni(e.type, a)),
      (o.props = c),
      (f = e.pendingProps),
      (d = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = Kn(l))
        : ((l = Tn(t) ? is : cn.current), (l = io(e, l)));
    var p = t.getDerivedStateFromProps;
    (u =
      typeof p == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== f || d !== l) && hp(e, o, i, l)),
      (sr = !1),
      (d = e.memoizedState),
      (o.state = d),
      sc(e, i, o, r);
    var v = e.memoizedState;
    a !== f || d !== v || Mn.current || sr
      ? (typeof p == "function" && (Df(e, t, p, i), (v = e.memoizedState)),
        (c = sr || dp(e, t, c, i, d, v, l) || !1)
          ? (u ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, v, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, v, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && d === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && d === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = v)),
        (o.props = i),
        (o.state = v),
        (o.context = l),
        (i = c))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && d === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && d === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return kf(n, e, t, i, s, r);
}
function kf(n, e, t, i, r, s) {
  T0(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && ap(e, t, !1), Wi(n, e, s);
  (i = e.stateNode), (Jx.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = so(e, n.child, null, s)), (e.child = so(e, null, a, s)))
      : hn(n, e, a, s),
    (e.memoizedState = i.state),
    r && ap(e, t, !0),
    e.child
  );
}
function w0(n) {
  var e = n.stateNode;
  e.pendingContext
    ? op(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && op(n, e.context, !1),
    zd(n, e.containerInfo);
}
function Mp(n, e, t, i, r) {
  return ro(), Dd(r), (e.flags |= 256), hn(n, e, t, i), e.child;
}
var Bf = { dehydrated: null, treeContext: null, retryLane: 0 };
function zf(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function A0(n, e, t) {
  var i = e.pendingProps,
    r = At.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    vt(At, r & 1),
    n === null)
  )
    return (
      If(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (n = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = Nc(o, i, 0, null)),
              (n = Jr(n, i, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = zf(t)),
              (e.memoizedState = Bf),
              n)
            : qd(e, o))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return eS(n, e, o, i, a, r, t);
  if (s) {
    (s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling);
    var l = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = l),
          (e.deletions = null))
        : ((i = Sr(r, l)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = Sr(a, s)) : ((s = Jr(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? zf(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = Bf),
      i
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (i = Sr(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function qd(n, e) {
  return (
    (e = Nc({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function Za(n, e, t, i) {
  return (
    i !== null && Dd(i),
    so(e, n.child, null, t),
    (n = qd(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function eS(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = du(Error(ue(422)))), Za(n, e, o, i))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = i.fallback),
        (r = e.mode),
        (i = Nc({ mode: "visible", children: i.children }, r, 0, null)),
        (s = Jr(s, r, o, null)),
        (s.flags |= 2),
        (i.return = e),
        (s.return = e),
        (i.sibling = s),
        (e.child = i),
        e.mode & 1 && so(e, n.child, null, o),
        (e.child.memoizedState = zf(o)),
        (e.memoizedState = Bf),
        s);
  if (!(e.mode & 1)) return Za(n, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (s = Error(ue(419))), (i = du(s, i, void 0)), Za(n, e, o, i)
    );
  }
  if (((a = (o & n.childLanes) !== 0), En || a)) {
    if (((i = Zt), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), Gi(n, r), li(i, n, r, -1));
    }
    return eh(), (i = du(Error(ue(421)))), Za(n, e, o, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = hS.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (Nn = _r(r.nextSibling)),
      (Un = e),
      (wt = !0),
      (ri = null),
      n !== null &&
        ((Vn[Gn++] = Oi),
        (Vn[Gn++] = Fi),
        (Vn[Gn++] = rs),
        (Oi = n.id),
        (Fi = n.overflow),
        (rs = e)),
      (e = qd(e, i.children)),
      (e.flags |= 4096),
      e);
}
function Tp(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), Nf(n.return, e, t);
}
function hu(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = t),
      (s.tailMode = r));
}
function R0(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((hn(n, e, i.children, t), (i = At.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && Tp(n, t, e);
        else if (n.tag === 19) Tp(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    i &= 1;
  }
  if ((vt(At, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          (n = t.alternate),
            n !== null && oc(n) === null && (r = t),
            (t = t.sibling);
        (t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          hu(e, !1, r, t, s);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && oc(n) === null)) {
            e.child = r;
            break;
          }
          (n = r.sibling), (r.sibling = t), (t = r), (r = n);
        }
        hu(e, !0, t, null, s);
        break;
      case "together":
        hu(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function kl(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Wi(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (os |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(ue(153));
  if (e.child !== null) {
    for (
      n = e.child, t = Sr(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = Sr(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function tS(n, e, t) {
  switch (e.tag) {
    case 3:
      w0(e), ro();
      break;
    case 5:
      e0(e);
      break;
    case 1:
      Tn(e.type) && ec(e);
      break;
    case 4:
      zd(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      vt(ic, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (vt(At, At.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? A0(n, e, t)
          : (vt(At, At.current & 1),
            (n = Wi(n, e, t)),
            n !== null ? n.sibling : null);
      vt(At, At.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return R0(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        vt(At, At.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), M0(n, e, t);
  }
  return Wi(n, e, t);
}
var b0, Hf, C0, L0;
b0 = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
Hf = function () {};
C0 = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    (n = e.stateNode), Kr(yi.current);
    var s = null;
    switch (t) {
      case "input":
        (r = cf(n, r)), (i = cf(n, i)), (s = []);
        break;
      case "select":
        (r = Lt({}, r, { value: void 0 })),
          (i = Lt({}, i, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (r = df(n, r)), (i = df(n, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = Ql);
    }
    pf(t, i);
    var o;
    t = null;
    for (c in r)
      if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
        if (c === "style") {
          var a = r[c];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (la.hasOwnProperty(c)
              ? s || (s = [])
              : (s = s || []).push(c, null));
    for (c in i) {
      var l = i[c];
      if (
        ((a = r != null ? r[c] : void 0),
        i.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else t || (s || (s = []), s.push(c, t)), (t = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (la.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && yt("scroll", n),
                  s || a === l || (s = []))
                : (s = s || []).push(c, l));
    }
    t && (s = s || []).push("style", t);
    var c = s;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
L0 = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Do(n, e) {
  if (!wt)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), (t = t.sibling);
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function sn(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling);
  else
    for (r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling);
  return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function nS(n, e, t) {
  var i = e.pendingProps;
  switch ((Nd(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return sn(e), null;
    case 1:
      return Tn(e.type) && Jl(), sn(e), null;
    case 3:
      return (
        (i = e.stateNode),
        oo(),
        Et(Mn),
        Et(cn),
        Vd(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          (qa(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), ri !== null && (Kf(ri), (ri = null)))),
        Hf(n, e),
        sn(e),
        null
      );
    case 5:
      Hd(e);
      var r = Kr(xa.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        C0(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(ue(166));
          return sn(e), null;
        }
        if (((n = Kr(yi.current)), qa(e))) {
          (i = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((i[gi] = e), (i[va] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              yt("cancel", i), yt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              yt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < Yo.length; r++) yt(Yo[r], i);
              break;
            case "source":
              yt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              yt("error", i), yt("load", i);
              break;
            case "details":
              yt("toggle", i);
              break;
            case "input":
              Nh(i, s), yt("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!s.multiple }),
                yt("invalid", i);
              break;
            case "textarea":
              Uh(i, s), yt("invalid", i);
          }
          pf(t, s), (r = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Ya(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Ya(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : la.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  yt("scroll", i);
            }
          switch (t) {
            case "input":
              Ba(i), Dh(i, s, !0);
              break;
            case "textarea":
              Ba(i), Oh(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = Ql);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (o = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = i_(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                ? (n = o.createElement(t, { is: i.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    i.multiple
                      ? (o.multiple = !0)
                      : i.size && (o.size = i.size)))
              : (n = o.createElementNS(n, t)),
            (n[gi] = e),
            (n[va] = i),
            b0(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = mf(t, i)), t)) {
              case "dialog":
                yt("cancel", n), yt("close", n), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                yt("load", n), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < Yo.length; r++) yt(Yo[r], n);
                r = i;
                break;
              case "source":
                yt("error", n), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                yt("error", n), yt("load", n), (r = i);
                break;
              case "details":
                yt("toggle", n), (r = i);
                break;
              case "input":
                Nh(n, i), (r = cf(n, i)), yt("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = Lt({}, i, { value: void 0 })),
                  yt("invalid", n);
                break;
              case "textarea":
                Uh(n, i), (r = df(n, i)), yt("invalid", n);
                break;
              default:
                r = i;
            }
            pf(t, r), (a = r);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? o_(n, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && r_(n, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (t !== "textarea" || l !== "") && ca(n, l)
                    : typeof l == "number" && ca(n, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (la.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && yt("scroll", n)
                      : l != null && vd(n, s, l, o));
              }
            switch (t) {
              case "input":
                Ba(n), Dh(n, i, !1);
                break;
              case "textarea":
                Ba(n), Oh(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + Ar(i.value));
                break;
              case "select":
                (n.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? Ys(n, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      Ys(n, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = Ql);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return sn(e), null;
    case 6:
      if (n && e.stateNode != null) L0(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(ue(166));
        if (((t = Kr(xa.current)), Kr(yi.current), qa(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[gi] = e),
            (s = i.nodeValue !== t) && ((n = Un), n !== null))
          )
            switch (n.tag) {
              case 3:
                Ya(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  Ya(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[gi] = e),
            (e.stateNode = i);
      }
      return sn(e), null;
    case 13:
      if (
        (Et(At),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (wt && Nn !== null && e.mode & 1 && !(e.flags & 128))
          Y_(), ro(), (e.flags |= 98560), (s = !1);
        else if (((s = qa(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(ue(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(ue(317));
            s[gi] = e;
          } else
            ro(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          sn(e), (s = !1);
        } else ri !== null && (Kf(ri), (ri = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || At.current & 1 ? Ht === 0 && (Ht = 3) : eh())),
          e.updateQueue !== null && (e.flags |= 4),
          sn(e),
          null);
    case 4:
      return (
        oo(), Hf(n, e), n === null && ga(e.stateNode.containerInfo), sn(e), null
      );
    case 10:
      return Fd(e.type._context), sn(e), null;
    case 17:
      return Tn(e.type) && Jl(), sn(e), null;
    case 19:
      if ((Et(At), (s = e.memoizedState), s === null)) return sn(e), null;
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) Do(s, !1);
        else {
          if (Ht !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = oc(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    Do(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return vt(At, (At.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            Dt() > lo &&
            ((e.flags |= 128), (i = !0), Do(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = oc(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              Do(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !wt)
            )
              return sn(e), null;
          } else
            2 * Dt() - s.renderingStartTime > lo &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Do(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Dt()),
          (e.sibling = null),
          (t = At.current),
          vt(At, i ? (t & 1) | 2 : t & 1),
          e)
        : (sn(e), null);
    case 22:
    case 23:
      return (
        Jd(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? Cn & 1073741824 && (sn(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : sn(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(ue(156, e.tag));
}
function iS(n, e) {
  switch ((Nd(e), e.tag)) {
    case 1:
      return (
        Tn(e.type) && Jl(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        oo(),
        Et(Mn),
        Et(cn),
        Vd(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return Hd(e), null;
    case 13:
      if (
        (Et(At), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(ue(340));
        ro();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return Et(At), null;
    case 4:
      return oo(), null;
    case 10:
      return Fd(e.type._context), null;
    case 22:
    case 23:
      return Jd(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var $a = !1,
  ln = !1,
  rS = typeof WeakSet == "function" ? WeakSet : Set,
  Ce = null;
function Ws(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        Nt(n, e, i);
      }
    else t.current = null;
}
function Vf(n, e, t) {
  try {
    t();
  } catch (i) {
    Nt(n, e, i);
  }
}
var wp = !1;
function sS(n, e) {
  if (((wf = Kl), (n = D_()), Pd(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            f = n,
            d = null;
          t: for (;;) {
            for (
              var p;
              f !== t || (r !== 0 && f.nodeType !== 3) || (a = o + r),
                f !== s || (i !== 0 && f.nodeType !== 3) || (l = o + i),
                f.nodeType === 3 && (o += f.nodeValue.length),
                (p = f.firstChild) !== null;

            )
              (d = f), (f = p);
            for (;;) {
              if (f === n) break t;
              if (
                (d === t && ++c === r && (a = o),
                d === s && ++u === i && (l = o),
                (p = f.nextSibling) !== null)
              )
                break;
              (f = d), (d = f.parentNode);
            }
            f = p;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    Af = { focusedElem: n, selectionRange: t }, Kl = !1, Ce = e;
    Ce !== null;

  )
    if (((e = Ce), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (Ce = n);
    else
      for (; Ce !== null; ) {
        e = Ce;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var x = v.memoizedProps,
                    m = v.memoizedState,
                    h = e.stateNode,
                    _ = h.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? x : ni(e.type, x),
                      m
                    );
                  h.__reactInternalSnapshotBeforeUpdate = _;
                }
                break;
              case 3:
                var g = e.stateNode.containerInfo;
                g.nodeType === 1
                  ? (g.textContent = "")
                  : g.nodeType === 9 &&
                    g.documentElement &&
                    g.removeChild(g.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(ue(163));
            }
        } catch (E) {
          Nt(e, e.return, E);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (Ce = n);
          break;
        }
        Ce = e.return;
      }
  return (v = wp), (wp = !1), v;
}
function ta(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && Vf(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function Pc(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function Gf(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function P0(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), P0(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[gi], delete e[va], delete e[Cf], delete e[Hx], delete e[Vx])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function I0(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function Ap(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || I0(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function Wf(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = Ql));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Wf(n, e, t), n = n.sibling; n !== null; ) Wf(n, e, t), (n = n.sibling);
}
function Xf(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Xf(n, e, t), n = n.sibling; n !== null; ) Xf(n, e, t), (n = n.sibling);
}
var Jt = null,
  ii = !1;
function Zi(n, e, t) {
  for (t = t.child; t !== null; ) N0(n, e, t), (t = t.sibling);
}
function N0(n, e, t) {
  if (vi && typeof vi.onCommitFiberUnmount == "function")
    try {
      vi.onCommitFiberUnmount(Mc, t);
    } catch {}
  switch (t.tag) {
    case 5:
      ln || Ws(t, e);
    case 6:
      var i = Jt,
        r = ii;
      (Jt = null),
        Zi(n, e, t),
        (Jt = i),
        (ii = r),
        Jt !== null &&
          (ii
            ? ((n = Jt),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Jt.removeChild(t.stateNode));
      break;
    case 18:
      Jt !== null &&
        (ii
          ? ((n = Jt),
            (t = t.stateNode),
            n.nodeType === 8
              ? ou(n.parentNode, t)
              : n.nodeType === 1 && ou(n, t),
            ha(n))
          : ou(Jt, t.stateNode));
      break;
    case 4:
      (i = Jt),
        (r = ii),
        (Jt = t.stateNode.containerInfo),
        (ii = !0),
        Zi(n, e, t),
        (Jt = i),
        (ii = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !ln &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Vf(t, e, o),
            (r = r.next);
        } while (r !== i);
      }
      Zi(n, e, t);
      break;
    case 1:
      if (
        !ln &&
        (Ws(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          Nt(t, e, a);
        }
      Zi(n, e, t);
      break;
    case 21:
      Zi(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((ln = (i = ln) || t.memoizedState !== null), Zi(n, e, t), (ln = i))
        : Zi(n, e, t);
      break;
    default:
      Zi(n, e, t);
  }
}
function Rp(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new rS()),
      e.forEach(function (i) {
        var r = pS.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      });
  }
}
function $n(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Jt = a.stateNode), (ii = !1);
              break e;
            case 3:
              (Jt = a.stateNode.containerInfo), (ii = !0);
              break e;
            case 4:
              (Jt = a.stateNode.containerInfo), (ii = !0);
              break e;
          }
          a = a.return;
        }
        if (Jt === null) throw Error(ue(160));
        N0(s, o, r), (Jt = null), (ii = !1);
        var l = r.alternate;
        l !== null && (l.return = null), (r.return = null);
      } catch (c) {
        Nt(r, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) D0(e, n), (e = e.sibling);
}
function D0(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (($n(e, n), hi(n), i & 4)) {
        try {
          ta(3, n, n.return), Pc(3, n);
        } catch (x) {
          Nt(n, n.return, x);
        }
        try {
          ta(5, n, n.return);
        } catch (x) {
          Nt(n, n.return, x);
        }
      }
      break;
    case 1:
      $n(e, n), hi(n), i & 512 && t !== null && Ws(t, t.return);
      break;
    case 5:
      if (
        ($n(e, n),
        hi(n),
        i & 512 && t !== null && Ws(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          ca(r, "");
        } catch (x) {
          Nt(n, n.return, x);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && t_(r, s),
              mf(a, o);
            var c = mf(a, s);
            for (o = 0; o < l.length; o += 2) {
              var u = l[o],
                f = l[o + 1];
              u === "style"
                ? o_(r, f)
                : u === "dangerouslySetInnerHTML"
                ? r_(r, f)
                : u === "children"
                ? ca(r, f)
                : vd(r, u, f, c);
            }
            switch (a) {
              case "input":
                uf(r, s);
                break;
              case "textarea":
                n_(r, s);
                break;
              case "select":
                var d = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var p = s.value;
                p != null
                  ? Ys(r, !!s.multiple, p, !1)
                  : d !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Ys(r, !!s.multiple, s.defaultValue, !0)
                      : Ys(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[va] = s;
          } catch (x) {
            Nt(n, n.return, x);
          }
      }
      break;
    case 6:
      if (($n(e, n), hi(n), i & 4)) {
        if (n.stateNode === null) throw Error(ue(162));
        (r = n.stateNode), (s = n.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (x) {
          Nt(n, n.return, x);
        }
      }
      break;
    case 3:
      if (
        ($n(e, n), hi(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          ha(e.containerInfo);
        } catch (x) {
          Nt(n, n.return, x);
        }
      break;
    case 4:
      $n(e, n), hi(n);
      break;
    case 13:
      $n(e, n),
        hi(n),
        (r = n.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            ($d = Dt())),
        i & 4 && Rp(n);
      break;
    case 22:
      if (
        ((u = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((ln = (c = ln) || u), $n(e, n), (ln = c)) : $n(e, n),
        hi(n),
        i & 8192)
      ) {
        if (
          ((c = n.memoizedState !== null),
          (n.stateNode.isHidden = c) && !u && n.mode & 1)
        )
          for (Ce = n, u = n.child; u !== null; ) {
            for (f = Ce = u; Ce !== null; ) {
              switch (((d = Ce), (p = d.child), d.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  ta(4, d, d.return);
                  break;
                case 1:
                  Ws(d, d.return);
                  var v = d.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (i = d), (t = d.return);
                    try {
                      (e = i),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (x) {
                      Nt(i, t, x);
                    }
                  }
                  break;
                case 5:
                  Ws(d, d.return);
                  break;
                case 22:
                  if (d.memoizedState !== null) {
                    Cp(f);
                    continue;
                  }
              }
              p !== null ? ((p.return = d), (Ce = p)) : Cp(f);
            }
            u = u.sibling;
          }
        e: for (u = null, f = n; ; ) {
          if (f.tag === 5) {
            if (u === null) {
              u = f;
              try {
                (r = f.stateNode),
                  c
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = f.stateNode),
                      (l = f.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = s_("display", o)));
              } catch (x) {
                Nt(n, n.return, x);
              }
            }
          } else if (f.tag === 6) {
            if (u === null)
              try {
                f.stateNode.nodeValue = c ? "" : f.memoizedProps;
              } catch (x) {
                Nt(n, n.return, x);
              }
          } else if (
            ((f.tag !== 22 && f.tag !== 23) ||
              f.memoizedState === null ||
              f === n) &&
            f.child !== null
          ) {
            (f.child.return = f), (f = f.child);
            continue;
          }
          if (f === n) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === n) break e;
            u === f && (u = null), (f = f.return);
          }
          u === f && (u = null), (f.sibling.return = f.return), (f = f.sibling);
        }
      }
      break;
    case 19:
      $n(e, n), hi(n), i & 4 && Rp(n);
      break;
    case 21:
      break;
    default:
      $n(e, n), hi(n);
  }
}
function hi(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (I0(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(ue(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (ca(r, ""), (i.flags &= -33));
          var s = Ap(n);
          Xf(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = Ap(n);
          Wf(n, a, o);
          break;
        default:
          throw Error(ue(161));
      }
    } catch (l) {
      Nt(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function oS(n, e, t) {
  (Ce = n), U0(n);
}
function U0(n, e, t) {
  for (var i = (n.mode & 1) !== 0; Ce !== null; ) {
    var r = Ce,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || $a;
      if (!o) {
        var a = r.alternate,
          l = (a !== null && a.memoizedState !== null) || ln;
        a = $a;
        var c = ln;
        if ((($a = o), (ln = l) && !c))
          for (Ce = r; Ce !== null; )
            (o = Ce),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? Lp(r)
                : l !== null
                ? ((l.return = o), (Ce = l))
                : Lp(r);
        for (; s !== null; ) (Ce = s), U0(s), (s = s.sibling);
        (Ce = r), ($a = a), (ln = c);
      }
      bp(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (Ce = s)) : bp(n);
  }
}
function bp(n) {
  for (; Ce !== null; ) {
    var e = Ce;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              ln || Pc(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !ln)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : ni(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && fp(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                fp(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var f = u.dehydrated;
                    f !== null && ha(f);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(ue(163));
          }
        ln || (e.flags & 512 && Gf(e));
      } catch (d) {
        Nt(e, e.return, d);
      }
    }
    if (e === n) {
      Ce = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (Ce = t);
      break;
    }
    Ce = e.return;
  }
}
function Cp(n) {
  for (; Ce !== null; ) {
    var e = Ce;
    if (e === n) {
      Ce = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (Ce = t);
      break;
    }
    Ce = e.return;
  }
}
function Lp(n) {
  for (; Ce !== null; ) {
    var e = Ce;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            Pc(4, e);
          } catch (l) {
            Nt(e, t, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              Nt(e, r, l);
            }
          }
          var s = e.return;
          try {
            Gf(e);
          } catch (l) {
            Nt(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            Gf(e);
          } catch (l) {
            Nt(e, o, l);
          }
      }
    } catch (l) {
      Nt(e, e.return, l);
    }
    if (e === n) {
      Ce = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (Ce = a);
      break;
    }
    Ce = e.return;
  }
}
var aS = Math.ceil,
  cc = ji.ReactCurrentDispatcher,
  Kd = ji.ReactCurrentOwner,
  Yn = ji.ReactCurrentBatchConfig,
  ot = 0,
  Zt = null,
  Ft = null,
  en = 0,
  Cn = 0,
  Xs = Ir(0),
  Ht = 0,
  Ta = null,
  os = 0,
  Ic = 0,
  Zd = 0,
  na = null,
  xn = null,
  $d = 0,
  lo = 1 / 0,
  Ni = null,
  uc = !1,
  jf = null,
  yr = null,
  Qa = !1,
  fr = null,
  fc = 0,
  ia = 0,
  Yf = null,
  Bl = -1,
  zl = 0;
function mn() {
  return ot & 6 ? Dt() : Bl !== -1 ? Bl : (Bl = Dt());
}
function xr(n) {
  return n.mode & 1
    ? ot & 2 && en !== 0
      ? en & -en
      : Wx.transition !== null
      ? (zl === 0 && (zl = v_()), zl)
      : ((n = ft),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : w_(n.type))),
        n)
    : 1;
}
function li(n, e, t, i) {
  if (50 < ia) throw ((ia = 0), (Yf = null), Error(ue(185)));
  ba(n, t, i),
    (!(ot & 2) || n !== Zt) &&
      (n === Zt && (!(ot & 2) && (Ic |= t), Ht === 4 && cr(n, en)),
      wn(n, i),
      t === 1 && ot === 0 && !(e.mode & 1) && ((lo = Dt() + 500), bc && Nr()));
}
function wn(n, e) {
  var t = n.callbackNode;
  Wy(n, e);
  var i = ql(n, n === Zt ? en : 0);
  if (i === 0)
    t !== null && Bh(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && Bh(t), e === 1))
      n.tag === 0 ? Gx(Pp.bind(null, n)) : W_(Pp.bind(null, n)),
        Bx(function () {
          !(ot & 6) && Nr();
        }),
        (t = null);
    else {
      switch (y_(i)) {
        case 1:
          t = Md;
          break;
        case 4:
          t = g_;
          break;
        case 16:
          t = Yl;
          break;
        case 536870912:
          t = __;
          break;
        default:
          t = Yl;
      }
      t = G0(t, O0.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function O0(n, e) {
  if (((Bl = -1), (zl = 0), ot & 6)) throw Error(ue(327));
  var t = n.callbackNode;
  if (Qs() && n.callbackNode !== t) return null;
  var i = ql(n, n === Zt ? en : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = dc(n, i);
  else {
    e = i;
    var r = ot;
    ot |= 2;
    var s = k0();
    (Zt !== n || en !== e) && ((Ni = null), (lo = Dt() + 500), Qr(n, e));
    do
      try {
        uS();
        break;
      } catch (a) {
        F0(n, a);
      }
    while (!0);
    Od(),
      (cc.current = s),
      (ot = r),
      Ft !== null ? (e = 0) : ((Zt = null), (en = 0), (e = Ht));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = xf(n)), r !== 0 && ((i = r), (e = qf(n, r)))), e === 1)
    )
      throw ((t = Ta), Qr(n, 0), cr(n, i), wn(n, Dt()), t);
    if (e === 6) cr(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !lS(r) &&
          ((e = dc(n, i)),
          e === 2 && ((s = xf(n)), s !== 0 && ((i = s), (e = qf(n, s)))),
          e === 1))
      )
        throw ((t = Ta), Qr(n, 0), cr(n, i), wn(n, Dt()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(ue(345));
        case 2:
          Gr(n, xn, Ni);
          break;
        case 3:
          if (
            (cr(n, i), (i & 130023424) === i && ((e = $d + 500 - Dt()), 10 < e))
          ) {
            if (ql(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              mn(), (n.pingedLanes |= n.suspendedLanes & r);
              break;
            }
            n.timeoutHandle = bf(Gr.bind(null, n, xn, Ni), e);
            break;
          }
          Gr(n, xn, Ni);
          break;
        case 4:
          if ((cr(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - ai(i);
            (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
          }
          if (
            ((i = r),
            (i = Dt() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * aS(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = bf(Gr.bind(null, n, xn, Ni), i);
            break;
          }
          Gr(n, xn, Ni);
          break;
        case 5:
          Gr(n, xn, Ni);
          break;
        default:
          throw Error(ue(329));
      }
    }
  }
  return wn(n, Dt()), n.callbackNode === t ? O0.bind(null, n) : null;
}
function qf(n, e) {
  var t = na;
  return (
    n.current.memoizedState.isDehydrated && (Qr(n, e).flags |= 256),
    (n = dc(n, e)),
    n !== 2 && ((e = xn), (xn = t), e !== null && Kf(e)),
    n
  );
}
function Kf(n) {
  xn === null ? (xn = n) : xn.push.apply(xn, n);
}
function lS(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!ui(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function cr(n, e) {
  for (
    e &= ~Zd,
      e &= ~Ic,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - ai(e),
      i = 1 << t;
    (n[t] = -1), (e &= ~i);
  }
}
function Pp(n) {
  if (ot & 6) throw Error(ue(327));
  Qs();
  var e = ql(n, 0);
  if (!(e & 1)) return wn(n, Dt()), null;
  var t = dc(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = xf(n);
    i !== 0 && ((e = i), (t = qf(n, i)));
  }
  if (t === 1) throw ((t = Ta), Qr(n, 0), cr(n, e), wn(n, Dt()), t);
  if (t === 6) throw Error(ue(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    Gr(n, xn, Ni),
    wn(n, Dt()),
    null
  );
}
function Qd(n, e) {
  var t = ot;
  ot |= 1;
  try {
    return n(e);
  } finally {
    (ot = t), ot === 0 && ((lo = Dt() + 500), bc && Nr());
  }
}
function as(n) {
  fr !== null && fr.tag === 0 && !(ot & 6) && Qs();
  var e = ot;
  ot |= 1;
  var t = Yn.transition,
    i = ft;
  try {
    if (((Yn.transition = null), (ft = 1), n)) return n();
  } finally {
    (ft = i), (Yn.transition = t), (ot = e), !(ot & 6) && Nr();
  }
}
function Jd() {
  (Cn = Xs.current), Et(Xs);
}
function Qr(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), kx(t)), Ft !== null))
    for (t = Ft.return; t !== null; ) {
      var i = t;
      switch ((Nd(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && Jl();
          break;
        case 3:
          oo(), Et(Mn), Et(cn), Vd();
          break;
        case 5:
          Hd(i);
          break;
        case 4:
          oo();
          break;
        case 13:
          Et(At);
          break;
        case 19:
          Et(At);
          break;
        case 10:
          Fd(i.type._context);
          break;
        case 22:
        case 23:
          Jd();
      }
      t = t.return;
    }
  if (
    ((Zt = n),
    (Ft = n = Sr(n.current, null)),
    (en = Cn = e),
    (Ht = 0),
    (Ta = null),
    (Zd = Ic = os = 0),
    (xn = na = null),
    qr !== null)
  ) {
    for (e = 0; e < qr.length; e++)
      if (((t = qr[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = r), (i.next = o);
        }
        t.pending = i;
      }
    qr = null;
  }
  return n;
}
function F0(n, e) {
  do {
    var t = Ft;
    try {
      if ((Od(), (Ol.current = lc), ac)) {
        for (var i = bt.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        ac = !1;
      }
      if (
        ((ss = 0),
        (Yt = Bt = bt = null),
        (ea = !1),
        (Sa = 0),
        (Kd.current = null),
        t === null || t.return === null)
      ) {
        (Ht = 1), (Ta = e), (Ft = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = en),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = a,
            f = u.tag;
          if (!(u.mode & 1) && (f === 0 || f === 11 || f === 15)) {
            var d = u.alternate;
            d
              ? ((u.updateQueue = d.updateQueue),
                (u.memoizedState = d.memoizedState),
                (u.lanes = d.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var p = vp(o);
          if (p !== null) {
            (p.flags &= -257),
              yp(p, o, a, s, e),
              p.mode & 1 && _p(s, c, e),
              (e = p),
              (l = c);
            var v = e.updateQueue;
            if (v === null) {
              var x = new Set();
              x.add(l), (e.updateQueue = x);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              _p(s, c, e), eh();
              break e;
            }
            l = Error(ue(426));
          }
        } else if (wt && a.mode & 1) {
          var m = vp(o);
          if (m !== null) {
            !(m.flags & 65536) && (m.flags |= 256),
              yp(m, o, a, s, e),
              Dd(ao(l, a));
            break e;
          }
        }
        (s = l = ao(l, a)),
          Ht !== 4 && (Ht = 2),
          na === null ? (na = [s]) : na.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var h = x0(s, l, e);
              up(s, h);
              break e;
            case 1:
              a = l;
              var _ = s.type,
                g = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof _.getDerivedStateFromError == "function" ||
                  (g !== null &&
                    typeof g.componentDidCatch == "function" &&
                    (yr === null || !yr.has(g))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var E = S0(s, a, e);
                up(s, E);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      z0(t);
    } catch (w) {
      (e = w), Ft === t && t !== null && (Ft = t = t.return);
      continue;
    }
    break;
  } while (!0);
}
function k0() {
  var n = cc.current;
  return (cc.current = lc), n === null ? lc : n;
}
function eh() {
  (Ht === 0 || Ht === 3 || Ht === 2) && (Ht = 4),
    Zt === null || (!(os & 268435455) && !(Ic & 268435455)) || cr(Zt, en);
}
function dc(n, e) {
  var t = ot;
  ot |= 2;
  var i = k0();
  (Zt !== n || en !== e) && ((Ni = null), Qr(n, e));
  do
    try {
      cS();
      break;
    } catch (r) {
      F0(n, r);
    }
  while (!0);
  if ((Od(), (ot = t), (cc.current = i), Ft !== null)) throw Error(ue(261));
  return (Zt = null), (en = 0), Ht;
}
function cS() {
  for (; Ft !== null; ) B0(Ft);
}
function uS() {
  for (; Ft !== null && !Uy(); ) B0(Ft);
}
function B0(n) {
  var e = V0(n.alternate, n, Cn);
  (n.memoizedProps = n.pendingProps),
    e === null ? z0(n) : (Ft = e),
    (Kd.current = null);
}
function z0(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = iS(t, e)), t !== null)) {
        (t.flags &= 32767), (Ft = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (Ht = 6), (Ft = null);
        return;
      }
    } else if (((t = nS(t, e, Cn)), t !== null)) {
      Ft = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Ft = e;
      return;
    }
    Ft = e = n;
  } while (e !== null);
  Ht === 0 && (Ht = 5);
}
function Gr(n, e, t) {
  var i = ft,
    r = Yn.transition;
  try {
    (Yn.transition = null), (ft = 1), fS(n, e, t, i);
  } finally {
    (Yn.transition = r), (ft = i);
  }
  return null;
}
function fS(n, e, t, i) {
  do Qs();
  while (fr !== null);
  if (ot & 6) throw Error(ue(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(ue(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (Xy(n, s),
    n === Zt && ((Ft = Zt = null), (en = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      Qa ||
      ((Qa = !0),
      G0(Yl, function () {
        return Qs(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = Yn.transition), (Yn.transition = null);
    var o = ft;
    ft = 1;
    var a = ot;
    (ot |= 4),
      (Kd.current = null),
      sS(n, t),
      D0(t, n),
      Px(Af),
      (Kl = !!wf),
      (Af = wf = null),
      (n.current = t),
      oS(t),
      Oy(),
      (ot = a),
      (ft = o),
      (Yn.transition = s);
  } else n.current = t;
  if (
    (Qa && ((Qa = !1), (fr = n), (fc = r)),
    (s = n.pendingLanes),
    s === 0 && (yr = null),
    By(t.stateNode),
    wn(n, Dt()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (uc) throw ((uc = !1), (n = jf), (jf = null), n);
  return (
    fc & 1 && n.tag !== 0 && Qs(),
    (s = n.pendingLanes),
    s & 1 ? (n === Yf ? ia++ : ((ia = 0), (Yf = n))) : (ia = 0),
    Nr(),
    null
  );
}
function Qs() {
  if (fr !== null) {
    var n = y_(fc),
      e = Yn.transition,
      t = ft;
    try {
      if (((Yn.transition = null), (ft = 16 > n ? 16 : n), fr === null))
        var i = !1;
      else {
        if (((n = fr), (fr = null), (fc = 0), ot & 6)) throw Error(ue(331));
        var r = ot;
        for (ot |= 4, Ce = n.current; Ce !== null; ) {
          var s = Ce,
            o = s.child;
          if (Ce.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l];
                for (Ce = c; Ce !== null; ) {
                  var u = Ce;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      ta(8, u, s);
                  }
                  var f = u.child;
                  if (f !== null) (f.return = u), (Ce = f);
                  else
                    for (; Ce !== null; ) {
                      u = Ce;
                      var d = u.sibling,
                        p = u.return;
                      if ((P0(u), u === c)) {
                        Ce = null;
                        break;
                      }
                      if (d !== null) {
                        (d.return = p), (Ce = d);
                        break;
                      }
                      Ce = p;
                    }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var x = v.child;
                if (x !== null) {
                  v.child = null;
                  do {
                    var m = x.sibling;
                    (x.sibling = null), (x = m);
                  } while (x !== null);
                }
              }
              Ce = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (Ce = o);
          else
            e: for (; Ce !== null; ) {
              if (((s = Ce), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    ta(9, s, s.return);
                }
              var h = s.sibling;
              if (h !== null) {
                (h.return = s.return), (Ce = h);
                break e;
              }
              Ce = s.return;
            }
        }
        var _ = n.current;
        for (Ce = _; Ce !== null; ) {
          o = Ce;
          var g = o.child;
          if (o.subtreeFlags & 2064 && g !== null) (g.return = o), (Ce = g);
          else
            e: for (o = _; Ce !== null; ) {
              if (((a = Ce), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pc(9, a);
                  }
                } catch (w) {
                  Nt(a, a.return, w);
                }
              if (a === o) {
                Ce = null;
                break e;
              }
              var E = a.sibling;
              if (E !== null) {
                (E.return = a.return), (Ce = E);
                break e;
              }
              Ce = a.return;
            }
        }
        if (
          ((ot = r), Nr(), vi && typeof vi.onPostCommitFiberRoot == "function")
        )
          try {
            vi.onPostCommitFiberRoot(Mc, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (ft = t), (Yn.transition = e);
    }
  }
  return !1;
}
function Ip(n, e, t) {
  (e = ao(t, e)),
    (e = x0(n, e, 1)),
    (n = vr(n, e, 1)),
    (e = mn()),
    n !== null && (ba(n, 1, e), wn(n, e));
}
function Nt(n, e, t) {
  if (n.tag === 3) Ip(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        Ip(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (yr === null || !yr.has(i)))
        ) {
          (n = ao(t, n)),
            (n = S0(e, n, 1)),
            (e = vr(e, n, 1)),
            (n = mn()),
            e !== null && (ba(e, 1, n), wn(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function dS(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e),
    (e = mn()),
    (n.pingedLanes |= n.suspendedLanes & t),
    Zt === n &&
      (en & t) === t &&
      (Ht === 4 || (Ht === 3 && (en & 130023424) === en && 500 > Dt() - $d)
        ? Qr(n, 0)
        : (Zd |= t)),
    wn(n, e);
}
function H0(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Va), (Va <<= 1), !(Va & 130023424) && (Va = 4194304))
      : (e = 1));
  var t = mn();
  (n = Gi(n, e)), n !== null && (ba(n, e, t), wn(n, t));
}
function hS(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), H0(n, t);
}
function pS(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(ue(314));
  }
  i !== null && i.delete(e), H0(n, t);
}
var V0;
V0 = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || Mn.current) En = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (En = !1), tS(n, e, t);
      En = !!(n.flags & 131072);
    }
  else (En = !1), wt && e.flags & 1048576 && X_(e, nc, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      kl(n, e), (n = e.pendingProps);
      var r = io(e, cn.current);
      $s(e, t), (r = Wd(null, e, i, n, r, t));
      var s = Xd();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Tn(i) ? ((s = !0), ec(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            Bd(e),
            (r.updater = Cc),
            (e.stateNode = r),
            (r._reactInternals = e),
            Uf(e, i, n, t),
            (e = kf(null, e, i, !0, s, t)))
          : ((e.tag = 0), wt && s && Id(e), hn(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (kl(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = gS(i)),
          (n = ni(i, n)),
          r)
        ) {
          case 0:
            e = Ff(null, e, i, n, t);
            break e;
          case 1:
            e = Ep(null, e, i, n, t);
            break e;
          case 11:
            e = xp(null, e, i, n, t);
            break e;
          case 14:
            e = Sp(null, e, i, ni(i.type, n), t);
            break e;
        }
        throw Error(ue(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ni(i, r)),
        Ff(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ni(i, r)),
        Ep(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((w0(e), n === null)) throw Error(ue(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          K_(n, e),
          sc(e, i, null, t);
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = ao(Error(ue(423)), e)), (e = Mp(n, e, i, t, r));
            break e;
          } else if (i !== r) {
            (r = ao(Error(ue(424)), e)), (e = Mp(n, e, i, t, r));
            break e;
          } else
            for (
              Nn = _r(e.stateNode.containerInfo.firstChild),
                Un = e,
                wt = !0,
                ri = null,
                t = J_(e, null, i, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((ro(), i === r)) {
            e = Wi(n, e, t);
            break e;
          }
          hn(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        e0(e),
        n === null && If(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = r.children),
        Rf(i, r) ? (o = null) : s !== null && Rf(i, s) && (e.flags |= 32),
        T0(n, e),
        hn(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && If(e), null;
    case 13:
      return A0(n, e, t);
    case 4:
      return (
        zd(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = so(e, null, i, t)) : hn(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ni(i, r)),
        xp(n, e, i, r, t)
      );
    case 7:
      return hn(n, e, e.pendingProps, t), e.child;
    case 8:
      return hn(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return hn(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          vt(ic, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (ui(s.value, o)) {
            if (s.children === r.children && !Mn.current) {
              e = Wi(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === i) {
                    if (s.tag === 1) {
                      (l = zi(-1, t & -t)), (l.tag = 2);
                      var c = s.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      Nf(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(ue(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  Nf(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        hn(n, e, r.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        $s(e, t),
        (r = Kn(r)),
        (i = i(r)),
        (e.flags |= 1),
        hn(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = ni(i, e.pendingProps)),
        (r = ni(i.type, r)),
        Sp(n, e, i, r, t)
      );
    case 15:
      return E0(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : ni(i, r)),
        kl(n, e),
        (e.tag = 1),
        Tn(i) ? ((n = !0), ec(e)) : (n = !1),
        $s(e, t),
        $_(e, i, r),
        Uf(e, i, r, t),
        kf(null, e, i, !0, n, t)
      );
    case 19:
      return R0(n, e, t);
    case 22:
      return M0(n, e, t);
  }
  throw Error(ue(156, e.tag));
};
function G0(n, e) {
  return m_(n, e);
}
function mS(n, e, t, i) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Xn(n, e, t, i) {
  return new mS(n, e, t, i);
}
function th(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function gS(n) {
  if (typeof n == "function") return th(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === xd)) return 11;
    if (n === Sd) return 14;
  }
  return 2;
}
function Sr(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = Xn(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function Hl(n, e, t, i, r, s) {
  var o = 2;
  if (((i = n), typeof n == "function")) th(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case Us:
        return Jr(t.children, r, s, e);
      case yd:
        (o = 8), (r |= 8);
        break;
      case sf:
        return (
          (n = Xn(12, t, e, r | 2)), (n.elementType = sf), (n.lanes = s), n
        );
      case of:
        return (n = Xn(13, t, e, r)), (n.elementType = of), (n.lanes = s), n;
      case af:
        return (n = Xn(19, t, e, r)), (n.elementType = af), (n.lanes = s), n;
      case Qg:
        return Nc(t, r, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case Zg:
              o = 10;
              break e;
            case $g:
              o = 9;
              break e;
            case xd:
              o = 11;
              break e;
            case Sd:
              o = 14;
              break e;
            case rr:
              (o = 16), (i = null);
              break e;
          }
        throw Error(ue(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = Xn(o, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = s), e
  );
}
function Jr(n, e, t, i) {
  return (n = Xn(7, n, i, e)), (n.lanes = t), n;
}
function Nc(n, e, t, i) {
  return (
    (n = Xn(22, n, i, e)),
    (n.elementType = Qg),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function pu(n, e, t) {
  return (n = Xn(6, n, null, e)), (n.lanes = t), n;
}
function mu(n, e, t) {
  return (
    (e = Xn(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function _S(n, e, t, i, r) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Kc(0)),
    (this.expirationTimes = Kc(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Kc(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function nh(n, e, t, i, r, s, o, a, l) {
  return (
    (n = new _S(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = Xn(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    Bd(s),
    n
  );
}
function vS(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Ds,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function W0(n) {
  if (!n) return Rr;
  n = n._reactInternals;
  e: {
    if (fs(n) !== n || n.tag !== 1) throw Error(ue(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Tn(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(ue(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Tn(t)) return G_(n, t, e);
  }
  return e;
}
function X0(n, e, t, i, r, s, o, a, l) {
  return (
    (n = nh(t, i, !0, n, r, s, o, a, l)),
    (n.context = W0(null)),
    (t = n.current),
    (i = mn()),
    (r = xr(t)),
    (s = zi(i, r)),
    (s.callback = e ?? null),
    vr(t, s, r),
    (n.current.lanes = r),
    ba(n, r, i),
    wn(n, i),
    n
  );
}
function Dc(n, e, t, i) {
  var r = e.current,
    s = mn(),
    o = xr(r);
  return (
    (t = W0(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = zi(s, o)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = vr(r, e, o)),
    n !== null && (li(n, r, o, s), Ul(n, r, o)),
    o
  );
}
function hc(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function Np(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function ih(n, e) {
  Np(n, e), (n = n.alternate) && Np(n, e);
}
function yS() {
  return null;
}
var j0 =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function rh(n) {
  this._internalRoot = n;
}
Uc.prototype.render = rh.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(ue(409));
  Dc(n, e, null, null);
};
Uc.prototype.unmount = rh.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    as(function () {
      Dc(null, n, null, null);
    }),
      (e[Vi] = null);
  }
};
function Uc(n) {
  this._internalRoot = n;
}
Uc.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = E_();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < lr.length && e !== 0 && e < lr[t].priority; t++);
    lr.splice(t, 0, n), t === 0 && T_(n);
  }
};
function sh(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function Oc(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function Dp() {}
function xS(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var c = hc(o);
        s.call(c);
      };
    }
    var o = X0(e, i, n, 0, null, !1, !1, "", Dp);
    return (
      (n._reactRootContainer = o),
      (n[Vi] = o.current),
      ga(n.nodeType === 8 ? n.parentNode : n),
      as(),
      o
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var c = hc(l);
      a.call(c);
    };
  }
  var l = nh(n, 0, !1, null, null, !1, !1, "", Dp);
  return (
    (n._reactRootContainer = l),
    (n[Vi] = l.current),
    ga(n.nodeType === 8 ? n.parentNode : n),
    as(function () {
      Dc(e, l, t, i);
    }),
    l
  );
}
function Fc(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var l = hc(o);
        a.call(l);
      };
    }
    Dc(e, o, n, r);
  } else o = xS(t, e, n, r, i);
  return hc(o);
}
x_ = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = jo(e.pendingLanes);
        t !== 0 &&
          (Td(e, t | 1), wn(e, Dt()), !(ot & 6) && ((lo = Dt() + 500), Nr()));
      }
      break;
    case 13:
      as(function () {
        var i = Gi(n, 1);
        if (i !== null) {
          var r = mn();
          li(i, n, 1, r);
        }
      }),
        ih(n, 1);
  }
};
wd = function (n) {
  if (n.tag === 13) {
    var e = Gi(n, 134217728);
    if (e !== null) {
      var t = mn();
      li(e, n, 134217728, t);
    }
    ih(n, 134217728);
  }
};
S_ = function (n) {
  if (n.tag === 13) {
    var e = xr(n),
      t = Gi(n, e);
    if (t !== null) {
      var i = mn();
      li(t, n, e, i);
    }
    ih(n, e);
  }
};
E_ = function () {
  return ft;
};
M_ = function (n, e) {
  var t = ft;
  try {
    return (ft = n), e();
  } finally {
    ft = t;
  }
};
_f = function (n, e, t) {
  switch (e) {
    case "input":
      if ((uf(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = Rc(i);
            if (!r) throw Error(ue(90));
            e_(i), uf(i, r);
          }
        }
      }
      break;
    case "textarea":
      n_(n, t);
      break;
    case "select":
      (e = t.value), e != null && Ys(n, !!t.multiple, e, !1);
  }
};
c_ = Qd;
u_ = as;
var SS = { usingClientEntryPoint: !1, Events: [La, Bs, Rc, a_, l_, Qd] },
  Uo = {
    findFiberByHostInstance: Yr,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  ES = {
    bundleType: Uo.bundleType,
    version: Uo.version,
    rendererPackageName: Uo.rendererPackageName,
    rendererConfig: Uo.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ji.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = h_(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: Uo.findFiberByHostInstance || yS,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Ja = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Ja.isDisabled && Ja.supportsFiber)
    try {
      (Mc = Ja.inject(ES)), (vi = Ja);
    } catch {}
}
Fn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = SS;
Fn.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!sh(e)) throw Error(ue(200));
  return vS(n, e, null, t);
};
Fn.createRoot = function (n, e) {
  if (!sh(n)) throw Error(ue(299));
  var t = !1,
    i = "",
    r = j0;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = nh(n, 1, !1, null, null, t, !1, i, r)),
    (n[Vi] = e.current),
    ga(n.nodeType === 8 ? n.parentNode : n),
    new rh(e)
  );
};
Fn.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(ue(188))
      : ((n = Object.keys(n).join(",")), Error(ue(268, n)));
  return (n = h_(e)), (n = n === null ? null : n.stateNode), n;
};
Fn.flushSync = function (n) {
  return as(n);
};
Fn.hydrate = function (n, e, t) {
  if (!Oc(e)) throw Error(ue(200));
  return Fc(null, n, e, !0, t);
};
Fn.hydrateRoot = function (n, e, t) {
  if (!sh(n)) throw Error(ue(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    s = "",
    o = j0;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = X0(e, null, n, 1, t ?? null, r, !1, s, o)),
    (n[Vi] = e.current),
    ga(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      (t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r);
  return new Uc(e);
};
Fn.render = function (n, e, t) {
  if (!Oc(e)) throw Error(ue(200));
  return Fc(null, n, e, !1, t);
};
Fn.unmountComponentAtNode = function (n) {
  if (!Oc(n)) throw Error(ue(40));
  return n._reactRootContainer
    ? (as(function () {
        Fc(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[Vi] = null);
        });
      }),
      !0)
    : !1;
};
Fn.unstable_batchedUpdates = Qd;
Fn.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!Oc(t)) throw Error(ue(200));
  if (n == null || n._reactInternals === void 0) throw Error(ue(38));
  return Fc(n, e, t, !1, i);
};
Fn.version = "18.2.0-next-9e3b772b8-20220608";
function Y0() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Y0);
    } catch (n) {
      console.error(n);
    }
}
Y0(), (Xg.exports = Fn);
var MS = Xg.exports,
  Up = MS;
(nf.createRoot = Up.createRoot), (nf.hydrateRoot = Up.hydrateRoot);
const q0 = jt.createContext({
  clientHeight: document.documentElement.clientHeight,
  clientWidth: document.documentElement.clientWidth,
});
function TS({ children: n }) {
  const e = jt.useCallback(
      () => document.documentElement.clientHeight || 0,
      []
    ),
    t = jt.useCallback(() => document.documentElement.clientWidth || 0, []),
    [i, r] = jt.useState(e()),
    [s, o] = jt.useState(t());
  return (
    jt.useEffect(() => {
      const a = () => {
        r(e()), o(t());
      };
      return (
        window.addEventListener("resize", a),
        () => {
          window.removeEventListener("resize", a);
        }
      );
    }, [e, t]),
    Ln.jsx(q0.Provider, {
      value: { clientHeight: i, clientWidth: s },
      children: n,
    })
  );
}
function wS() {
  return jt.useContext(q0);
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const oh = "158",
  ms = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  gs = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  AS = 0,
  Op = 1,
  RS = 2,
  K0 = 1,
  Z0 = 2,
  Ii = 3,
  Xi = 0,
  An = 1,
  oi = 2,
  Er = 0,
  Js = 1,
  Fp = 2,
  kp = 3,
  Bp = 4,
  bS = 5,
  Xr = 100,
  CS = 101,
  LS = 102,
  zp = 103,
  Hp = 104,
  PS = 200,
  IS = 201,
  NS = 202,
  DS = 203,
  Zf = 204,
  $f = 205,
  US = 206,
  OS = 207,
  FS = 208,
  kS = 209,
  BS = 210,
  zS = 211,
  HS = 212,
  VS = 213,
  GS = 214,
  WS = 0,
  XS = 1,
  jS = 2,
  pc = 3,
  YS = 4,
  qS = 5,
  KS = 6,
  ZS = 7,
  $0 = 0,
  $S = 1,
  QS = 2,
  Mr = 0,
  JS = 1,
  Q0 = 2,
  eE = 3,
  tE = 4,
  nE = 5,
  Vp = "attached",
  iE = "detached",
  J0 = 300,
  co = 301,
  uo = 302,
  mc = 303,
  Qf = 304,
  kc = 306,
  fo = 1e3,
  Sn = 1001,
  gc = 1002,
  qt = 1003,
  Jf = 1004,
  Vl = 1005,
  zt = 1006,
  ev = 1007,
  br = 1008,
  Tr = 1009,
  rE = 1010,
  sE = 1011,
  ah = 1012,
  tv = 1013,
  dr = 1014,
  jn = 1015,
  ki = 1016,
  nv = 1017,
  iv = 1018,
  es = 1020,
  oE = 1021,
  Pn = 1023,
  aE = 1024,
  lE = 1025,
  ts = 1026,
  ho = 1027,
  rv = 1028,
  sv = 1029,
  cE = 1030,
  ov = 1031,
  av = 1033,
  gu = 33776,
  _u = 33777,
  vu = 33778,
  yu = 33779,
  Gp = 35840,
  Wp = 35841,
  Xp = 35842,
  jp = 35843,
  uE = 36196,
  Yp = 37492,
  qp = 37496,
  Kp = 37808,
  Zp = 37809,
  $p = 37810,
  Qp = 37811,
  Jp = 37812,
  em = 37813,
  tm = 37814,
  nm = 37815,
  im = 37816,
  rm = 37817,
  sm = 37818,
  om = 37819,
  am = 37820,
  lm = 37821,
  xu = 36492,
  cm = 36494,
  um = 36495,
  fE = 36283,
  fm = 36284,
  dm = 36285,
  hm = 36286,
  wa = 2300,
  po = 2301,
  Su = 2302,
  pm = 2400,
  mm = 2401,
  gm = 2402,
  dE = 2500,
  hE = 0,
  lv = 1,
  ed = 2,
  cv = 3e3,
  ns = 3001,
  pE = 3200,
  mE = 3201,
  uv = 0,
  gE = 1,
  In = "",
  Rt = "srgb",
  Vt = "srgb-linear",
  lh = "display-p3",
  Bc = "display-p3-linear",
  _c = "linear",
  xt = "srgb",
  vc = "rec709",
  yc = "p3",
  _s = 7680,
  _m = 519,
  _E = 512,
  vE = 513,
  yE = 514,
  xE = 515,
  SE = 516,
  EE = 517,
  ME = 518,
  TE = 519,
  td = 35044,
  vm = "300 es",
  nd = 1035,
  Bi = 2e3,
  xc = 2001;
class ds {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const on = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let ym = 1234567;
const ra = Math.PI / 180,
  mo = 180 / Math.PI;
function ci() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    on[n & 255] +
    on[(n >> 8) & 255] +
    on[(n >> 16) & 255] +
    on[(n >> 24) & 255] +
    "-" +
    on[e & 255] +
    on[(e >> 8) & 255] +
    "-" +
    on[((e >> 16) & 15) | 64] +
    on[(e >> 24) & 255] +
    "-" +
    on[(t & 63) | 128] +
    on[(t >> 8) & 255] +
    "-" +
    on[(t >> 16) & 255] +
    on[(t >> 24) & 255] +
    on[i & 255] +
    on[(i >> 8) & 255] +
    on[(i >> 16) & 255] +
    on[(i >> 24) & 255]
  ).toLowerCase();
}
function Kt(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function ch(n, e) {
  return ((n % e) + e) % e;
}
function wE(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function AE(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function sa(n, e, t) {
  return (1 - t) * n + t * e;
}
function RE(n, e, t, i) {
  return sa(n, e, 1 - Math.exp(-t * i));
}
function bE(n, e = 1) {
  return e - Math.abs(ch(n, e * 2) - e);
}
function CE(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function LE(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function PE(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function IE(n, e) {
  return n + Math.random() * (e - n);
}
function NE(n) {
  return n * (0.5 - Math.random());
}
function DE(n) {
  n !== void 0 && (ym = n);
  let e = (ym += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function UE(n) {
  return n * ra;
}
function OE(n) {
  return n * mo;
}
function id(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function fv(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Sc(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function FE(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    c = s((e + i) / 2),
    u = o((e + i) / 2),
    f = s((e - i) / 2),
    d = o((e - i) / 2),
    p = s((i - e) / 2),
    v = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * u, l * f, l * d, a * c);
      break;
    case "YZY":
      n.set(l * d, a * u, l * f, a * c);
      break;
    case "ZXZ":
      n.set(l * f, l * d, a * u, a * c);
      break;
    case "XZX":
      n.set(a * u, l * v, l * p, a * c);
      break;
    case "YXY":
      n.set(l * p, a * u, l * v, a * c);
      break;
    case "ZYZ":
      n.set(l * v, l * p, a * u, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function _i(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ht(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const uh = {
  DEG2RAD: ra,
  RAD2DEG: mo,
  generateUUID: ci,
  clamp: Kt,
  euclideanModulo: ch,
  mapLinear: wE,
  inverseLerp: AE,
  lerp: sa,
  damp: RE,
  pingpong: bE,
  smoothstep: CE,
  smootherstep: LE,
  randInt: PE,
  randFloat: IE,
  randFloatSpread: NE,
  seededRandom: DE,
  degToRad: UE,
  radToDeg: OE,
  isPowerOfTwo: id,
  ceilPowerOfTwo: fv,
  floorPowerOfTwo: Sc,
  setQuaternionFromProperEuler: FE,
  normalize: ht,
  denormalize: _i,
};
class Ge {
  constructor(e = 0, t = 0) {
    (Ge.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Kt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class et {
  constructor(e, t, i, r, s, o, a, l, c) {
    (et.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, c);
  }
  set(e, t, i, r, s, o, a, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = r),
      (u[2] = a),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = i),
      (u[7] = o),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      c = i[1],
      u = i[4],
      f = i[7],
      d = i[2],
      p = i[5],
      v = i[8],
      x = r[0],
      m = r[3],
      h = r[6],
      _ = r[1],
      g = r[4],
      E = r[7],
      w = r[2],
      L = r[5],
      A = r[8];
    return (
      (s[0] = o * x + a * _ + l * w),
      (s[3] = o * m + a * g + l * L),
      (s[6] = o * h + a * E + l * A),
      (s[1] = c * x + u * _ + f * w),
      (s[4] = c * m + u * g + f * L),
      (s[7] = c * h + u * E + f * A),
      (s[2] = d * x + p * _ + v * w),
      (s[5] = d * m + p * g + v * L),
      (s[8] = d * h + p * E + v * A),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * o * u - t * a * c - i * s * u + i * a * l + r * s * c - r * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      f = u * o - a * c,
      d = a * l - u * s,
      p = c * s - o * l,
      v = t * f + i * d + r * p;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / v;
    return (
      (e[0] = f * x),
      (e[1] = (r * c - u * i) * x),
      (e[2] = (a * i - r * o) * x),
      (e[3] = d * x),
      (e[4] = (u * t - r * l) * x),
      (e[5] = (r * s - a * t) * x),
      (e[6] = p * x),
      (e[7] = (i * l - c * t) * x),
      (e[8] = (o * t - i * s) * x),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        i * l,
        i * c,
        -i * (l * o + c * a) + o + e,
        -r * c,
        r * l,
        -r * (-c * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Eu.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Eu.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Eu.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Eu = new et();
function dv(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
function Aa(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function kE() {
  const n = Aa("canvas");
  return (n.style.display = "block"), n;
}
const xm = {};
function oa(n) {
  n in xm || ((xm[n] = !0), console.warn(n));
}
const Sm = new et().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  Em = new et().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  el = {
    [Vt]: {
      transfer: _c,
      primaries: vc,
      toReference: (n) => n,
      fromReference: (n) => n,
    },
    [Rt]: {
      transfer: xt,
      primaries: vc,
      toReference: (n) => n.convertSRGBToLinear(),
      fromReference: (n) => n.convertLinearToSRGB(),
    },
    [Bc]: {
      transfer: _c,
      primaries: yc,
      toReference: (n) => n.applyMatrix3(Em),
      fromReference: (n) => n.applyMatrix3(Sm),
    },
    [lh]: {
      transfer: xt,
      primaries: yc,
      toReference: (n) => n.convertSRGBToLinear().applyMatrix3(Em),
      fromReference: (n) => n.applyMatrix3(Sm).convertLinearToSRGB(),
    },
  },
  BE = new Set([Vt, Bc]),
  lt = {
    enabled: !0,
    _workingColorSpace: Vt,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(n) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !n);
    },
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(n) {
      if (!BE.has(n))
        throw new Error(`Unsupported working color space, "${n}".`);
      this._workingColorSpace = n;
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const i = el[e].toReference,
        r = el[t].fromReference;
      return r(i(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this._workingColorSpace);
    },
    getPrimaries: function (n) {
      return el[n].primaries;
    },
    getTransfer: function (n) {
      return n === In ? _c : el[n].transfer;
    },
  };
function eo(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Mu(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let vs;
class hv {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      vs === void 0 && (vs = Aa("canvas")),
        (vs.width = e.width),
        (vs.height = e.height);
      const i = vs.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = vs);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Aa("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = eo(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(eo(t[i] / 255) * 255))
          : (t[i] = eo(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let zE = 0;
class pv {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: zE++ }),
      (this.uuid = ci()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(Tu(r[o].image)) : s.push(Tu(r[o]));
      } else s = Tu(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function Tu(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? hv.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let HE = 0;
class tn extends ds {
  constructor(
    e = tn.DEFAULT_IMAGE,
    t = tn.DEFAULT_MAPPING,
    i = Sn,
    r = Sn,
    s = zt,
    o = br,
    a = Pn,
    l = Tr,
    c = tn.DEFAULT_ANISOTROPY,
    u = In
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: HE++ }),
      (this.uuid = ci()),
      (this.name = ""),
      (this.source = new pv(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new Ge(0, 0)),
      (this.repeat = new Ge(1, 1)),
      (this.center = new Ge(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new et()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof u == "string"
        ? (this.colorSpace = u)
        : (oa(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = u === ns ? Rt : In)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== J0) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case fo:
          e.x = e.x - Math.floor(e.x);
          break;
        case Sn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case gc:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case fo:
          e.y = e.y - Math.floor(e.y);
          break;
        case Sn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case gc:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      oa("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === Rt ? ns : cv
    );
  }
  set encoding(e) {
    oa("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === ns ? Rt : In);
  }
}
tn.DEFAULT_IMAGE = null;
tn.DEFAULT_MAPPING = J0;
tn.DEFAULT_ANISOTROPY = 1;
class gt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (gt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      f = l[8],
      d = l[1],
      p = l[5],
      v = l[9],
      x = l[2],
      m = l[6],
      h = l[10];
    if (
      Math.abs(u - d) < 0.01 &&
      Math.abs(f - x) < 0.01 &&
      Math.abs(v - m) < 0.01
    ) {
      if (
        Math.abs(u + d) < 0.1 &&
        Math.abs(f + x) < 0.1 &&
        Math.abs(v + m) < 0.1 &&
        Math.abs(c + p + h - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const g = (c + 1) / 2,
        E = (p + 1) / 2,
        w = (h + 1) / 2,
        L = (u + d) / 4,
        A = (f + x) / 4,
        U = (v + m) / 4;
      return (
        g > E && g > w
          ? g < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(g)), (r = L / i), (s = A / i))
          : E > w
          ? E < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(E)), (i = L / r), (s = U / r))
          : w < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(w)), (i = A / s), (r = U / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let _ = Math.sqrt(
      (m - v) * (m - v) + (f - x) * (f - x) + (d - u) * (d - u)
    );
    return (
      Math.abs(_) < 0.001 && (_ = 1),
      (this.x = (m - v) / _),
      (this.y = (f - x) / _),
      (this.z = (d - u) / _),
      (this.w = Math.acos((c + p + h - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class VE extends ds {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new gt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new gt(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 &&
      (oa(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (i.colorSpace = i.encoding === ns ? Rt : In)),
      (i = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: zt,
          depthBuffer: !0,
          stencilBuffer: !1,
          depthTexture: null,
          samples: 0,
        },
        i
      )),
      (this.texture = new tn(
        r,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps = i.generateMipmaps),
      (this.texture.internalFormat = i.internalFormat),
      (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples);
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new pv(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ls extends VE {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), (this.isWebGLRenderTarget = !0);
  }
}
class mv extends tn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = qt),
      (this.minFilter = qt),
      (this.wrapR = Sn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class GE extends tn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = qt),
      (this.minFilter = qt),
      (this.wrapR = Sn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Si {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0],
      c = i[r + 1],
      u = i[r + 2],
      f = i[r + 3];
    const d = s[o + 0],
      p = s[o + 1],
      v = s[o + 2],
      x = s[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = f);
      return;
    }
    if (a === 1) {
      (e[t + 0] = d), (e[t + 1] = p), (e[t + 2] = v), (e[t + 3] = x);
      return;
    }
    if (f !== x || l !== d || c !== p || u !== v) {
      let m = 1 - a;
      const h = l * d + c * p + u * v + f * x,
        _ = h >= 0 ? 1 : -1,
        g = 1 - h * h;
      if (g > Number.EPSILON) {
        const w = Math.sqrt(g),
          L = Math.atan2(w, h * _);
        (m = Math.sin(m * L) / w), (a = Math.sin(a * L) / w);
      }
      const E = a * _;
      if (
        ((l = l * m + d * E),
        (c = c * m + p * E),
        (u = u * m + v * E),
        (f = f * m + x * E),
        m === 1 - a)
      ) {
        const w = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
        (l *= w), (c *= w), (u *= w), (f *= w);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = f);
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      c = i[r + 2],
      u = i[r + 3],
      f = s[o],
      d = s[o + 1],
      p = s[o + 2],
      v = s[o + 3];
    return (
      (e[t] = a * v + u * f + l * p - c * d),
      (e[t + 1] = l * v + u * d + c * f - a * p),
      (e[t + 2] = c * v + u * p + a * d - l * f),
      (e[t + 3] = u * v - a * f - l * d - c * p),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(i / 2),
      u = a(r / 2),
      f = a(s / 2),
      d = l(i / 2),
      p = l(r / 2),
      v = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = d * u * f + c * p * v),
          (this._y = c * p * f - d * u * v),
          (this._z = c * u * v + d * p * f),
          (this._w = c * u * f - d * p * v);
        break;
      case "YXZ":
        (this._x = d * u * f + c * p * v),
          (this._y = c * p * f - d * u * v),
          (this._z = c * u * v - d * p * f),
          (this._w = c * u * f + d * p * v);
        break;
      case "ZXY":
        (this._x = d * u * f - c * p * v),
          (this._y = c * p * f + d * u * v),
          (this._z = c * u * v + d * p * f),
          (this._w = c * u * f - d * p * v);
        break;
      case "ZYX":
        (this._x = d * u * f - c * p * v),
          (this._y = c * p * f + d * u * v),
          (this._z = c * u * v - d * p * f),
          (this._w = c * u * f + d * p * v);
        break;
      case "YZX":
        (this._x = d * u * f + c * p * v),
          (this._y = c * p * f + d * u * v),
          (this._z = c * u * v - d * p * f),
          (this._w = c * u * f - d * p * v);
        break;
      case "XZY":
        (this._x = d * u * f - c * p * v),
          (this._y = c * p * f - d * u * v),
          (this._z = c * u * v + d * p * f),
          (this._w = c * u * f + d * p * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      f = t[10],
      d = i + a + f;
    if (d > 0) {
      const p = 0.5 / Math.sqrt(d + 1);
      (this._w = 0.25 / p),
        (this._x = (u - l) * p),
        (this._y = (s - c) * p),
        (this._z = (o - r) * p);
    } else if (i > a && i > f) {
      const p = 2 * Math.sqrt(1 + i - a - f);
      (this._w = (u - l) / p),
        (this._x = 0.25 * p),
        (this._y = (r + o) / p),
        (this._z = (s + c) / p);
    } else if (a > f) {
      const p = 2 * Math.sqrt(1 + a - i - f);
      (this._w = (s - c) / p),
        (this._x = (r + o) / p),
        (this._y = 0.25 * p),
        (this._z = (l + u) / p);
    } else {
      const p = 2 * Math.sqrt(1 + f - i - a);
      (this._w = (o - r) / p),
        (this._x = (s + c) / p),
        (this._y = (l + u) / p),
        (this._z = 0.25 * p);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Kt(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = i * u + o * a + r * c - s * l),
      (this._y = r * u + o * l + s * a - i * c),
      (this._z = s * u + o * c + i * l - r * a),
      (this._w = o * u - i * a - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const p = 1 - t;
      return (
        (this._w = p * o + t * this._w),
        (this._x = p * i + t * this._x),
        (this._y = p * r + t * this._y),
        (this._z = p * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, a),
      f = Math.sin((1 - t) * u) / c,
      d = Math.sin(t * u) / c;
    return (
      (this._w = o * f + this._w * d),
      (this._x = i * f + this._x * d),
      (this._y = r * f + this._y * d),
      (this._z = s * f + this._z * d),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class B {
  constructor(e = 0, t = 0, i = 0) {
    (B.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Mm.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Mm.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (o * r - a * i),
      u = 2 * (a * t - s * r),
      f = 2 * (s * i - o * t);
    return (
      (this.x = t + l * c + o * f - a * u),
      (this.y = i + l * u + a * c - s * f),
      (this.z = r + l * f + s * u - o * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * a),
      (this.y = s * o - i * l),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return wu.copy(this).projectOnVector(e), this.sub(wu);
  }
  reflect(e) {
    return this.sub(wu.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(Kt(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const wu = new B(),
  Mm = new Si();
class Yi {
  constructor(
    e = new B(1 / 0, 1 / 0, 1 / 0),
    t = new B(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Qn.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Qn.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Qn.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, Qn)
            : Qn.fromBufferAttribute(s, o),
            Qn.applyMatrix4(e.matrixWorld),
            this.expandByPoint(Qn);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            tl.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            tl.copy(i.boundingBox)),
          tl.applyMatrix4(e.matrixWorld),
          this.union(tl);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Qn),
      Qn.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Oo),
      nl.subVectors(this.max, Oo),
      ys.subVectors(e.a, Oo),
      xs.subVectors(e.b, Oo),
      Ss.subVectors(e.c, Oo),
      $i.subVectors(xs, ys),
      Qi.subVectors(Ss, xs),
      Fr.subVectors(ys, Ss);
    let t = [
      0,
      -$i.z,
      $i.y,
      0,
      -Qi.z,
      Qi.y,
      0,
      -Fr.z,
      Fr.y,
      $i.z,
      0,
      -$i.x,
      Qi.z,
      0,
      -Qi.x,
      Fr.z,
      0,
      -Fr.x,
      -$i.y,
      $i.x,
      0,
      -Qi.y,
      Qi.x,
      0,
      -Fr.y,
      Fr.x,
      0,
    ];
    return !Au(t, ys, xs, Ss, nl) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Au(t, ys, xs, Ss, nl))
      ? !1
      : (il.crossVectors($i, Qi),
        (t = [il.x, il.y, il.z]),
        Au(t, ys, xs, Ss, nl));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Qn).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Qn).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Ai[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Ai[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Ai[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Ai[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Ai[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Ai[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Ai[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Ai[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Ai),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Ai = [
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
    new B(),
  ],
  Qn = new B(),
  tl = new Yi(),
  ys = new B(),
  xs = new B(),
  Ss = new B(),
  $i = new B(),
  Qi = new B(),
  Fr = new B(),
  Oo = new B(),
  nl = new B(),
  il = new B(),
  kr = new B();
function Au(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    kr.fromArray(n, s);
    const a =
        r.x * Math.abs(kr.x) + r.y * Math.abs(kr.y) + r.z * Math.abs(kr.z),
      l = e.dot(kr),
      c = t.dot(kr),
      u = i.dot(kr);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
  }
  return !0;
}
const WE = new Yi(),
  Fo = new B(),
  Ru = new B();
class Ei {
  constructor(e = new B(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : WE.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Fo.subVectors(e, this.center);
    const t = Fo.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(Fo, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (Ru.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Fo.copy(e.center).add(Ru)),
            this.expandByPoint(Fo.copy(e.center).sub(Ru))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ri = new B(),
  bu = new B(),
  rl = new B(),
  Ji = new B(),
  Cu = new B(),
  sl = new B(),
  Lu = new B();
class Ia {
  constructor(e = new B(), t = new B(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ri)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ri.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Ri.copy(this.origin).addScaledVector(this.direction, t),
        Ri.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    bu.copy(e).add(t).multiplyScalar(0.5),
      rl.copy(t).sub(e).normalize(),
      Ji.copy(this.origin).sub(bu);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(rl),
      a = Ji.dot(this.direction),
      l = -Ji.dot(rl),
      c = Ji.lengthSq(),
      u = Math.abs(1 - o * o);
    let f, d, p, v;
    if (u > 0)
      if (((f = o * l - a), (d = o * a - l), (v = s * u), f >= 0))
        if (d >= -v)
          if (d <= v) {
            const x = 1 / u;
            (f *= x),
              (d *= x),
              (p = f * (f + o * d + 2 * a) + d * (o * f + d + 2 * l) + c);
          } else
            (d = s),
              (f = Math.max(0, -(o * d + a))),
              (p = -f * f + d * (d + 2 * l) + c);
        else
          (d = -s),
            (f = Math.max(0, -(o * d + a))),
            (p = -f * f + d * (d + 2 * l) + c);
      else
        d <= -v
          ? ((f = Math.max(0, -(-o * s + a))),
            (d = f > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (p = -f * f + d * (d + 2 * l) + c))
          : d <= v
          ? ((f = 0),
            (d = Math.min(Math.max(-s, -l), s)),
            (p = d * (d + 2 * l) + c))
          : ((f = Math.max(0, -(o * s + a))),
            (d = f > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (p = -f * f + d * (d + 2 * l) + c));
    else
      (d = o > 0 ? -s : s),
        (f = Math.max(0, -(o * d + a))),
        (p = -f * f + d * (d + 2 * l) + c);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, f),
      r && r.copy(bu).addScaledVector(rl, d),
      p
    );
  }
  intersectSphere(e, t) {
    Ri.subVectors(e.center, this.origin);
    const i = Ri.dot(this.direction),
      r = Ri.dot(Ri) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      f = 1 / this.direction.z,
      d = this.origin;
    return (
      c >= 0
        ? ((i = (e.min.x - d.x) * c), (r = (e.max.x - d.x) * c))
        : ((i = (e.max.x - d.x) * c), (r = (e.min.x - d.x) * c)),
      u >= 0
        ? ((s = (e.min.y - d.y) * u), (o = (e.max.y - d.y) * u))
        : ((s = (e.max.y - d.y) * u), (o = (e.min.y - d.y) * u)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      f >= 0
        ? ((a = (e.min.z - d.z) * f), (l = (e.max.z - d.z) * f))
        : ((a = (e.max.z - d.z) * f), (l = (e.min.z - d.z) * f)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ri) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    Cu.subVectors(t, e), sl.subVectors(i, e), Lu.crossVectors(Cu, sl);
    let o = this.direction.dot(Lu),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    Ji.subVectors(this.origin, e);
    const l = a * this.direction.dot(sl.crossVectors(Ji, sl));
    if (l < 0) return null;
    const c = a * this.direction.dot(Cu.cross(Ji));
    if (c < 0 || l + c > o) return null;
    const u = -a * Ji.dot(Lu);
    return u < 0 ? null : this.at(u / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class tt {
  constructor(e, t, i, r, s, o, a, l, c, u, f, d, p, v, x, m) {
    (tt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, i, r, s, o, a, l, c, u, f, d, p, v, x, m);
  }
  set(e, t, i, r, s, o, a, l, c, u, f, d, p, v, x, m) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[4] = t),
      (h[8] = i),
      (h[12] = r),
      (h[1] = s),
      (h[5] = o),
      (h[9] = a),
      (h[13] = l),
      (h[2] = c),
      (h[6] = u),
      (h[10] = f),
      (h[14] = d),
      (h[3] = p),
      (h[7] = v),
      (h[11] = x),
      (h[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new tt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Es.setFromMatrixColumn(e, 0).length(),
      s = 1 / Es.setFromMatrixColumn(e, 1).length(),
      o = 1 / Es.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      c = Math.sin(r),
      u = Math.cos(s),
      f = Math.sin(s);
    if (e.order === "XYZ") {
      const d = o * u,
        p = o * f,
        v = a * u,
        x = a * f;
      (t[0] = l * u),
        (t[4] = -l * f),
        (t[8] = c),
        (t[1] = p + v * c),
        (t[5] = d - x * c),
        (t[9] = -a * l),
        (t[2] = x - d * c),
        (t[6] = v + p * c),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const d = l * u,
        p = l * f,
        v = c * u,
        x = c * f;
      (t[0] = d + x * a),
        (t[4] = v * a - p),
        (t[8] = o * c),
        (t[1] = o * f),
        (t[5] = o * u),
        (t[9] = -a),
        (t[2] = p * a - v),
        (t[6] = x + d * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const d = l * u,
        p = l * f,
        v = c * u,
        x = c * f;
      (t[0] = d - x * a),
        (t[4] = -o * f),
        (t[8] = v + p * a),
        (t[1] = p + v * a),
        (t[5] = o * u),
        (t[9] = x - d * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const d = o * u,
        p = o * f,
        v = a * u,
        x = a * f;
      (t[0] = l * u),
        (t[4] = v * c - p),
        (t[8] = d * c + x),
        (t[1] = l * f),
        (t[5] = x * c + d),
        (t[9] = p * c - v),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const d = o * l,
        p = o * c,
        v = a * l,
        x = a * c;
      (t[0] = l * u),
        (t[4] = x - d * f),
        (t[8] = v * f + p),
        (t[1] = f),
        (t[5] = o * u),
        (t[9] = -a * u),
        (t[2] = -c * u),
        (t[6] = p * f + v),
        (t[10] = d - x * f);
    } else if (e.order === "XZY") {
      const d = o * l,
        p = o * c,
        v = a * l,
        x = a * c;
      (t[0] = l * u),
        (t[4] = -f),
        (t[8] = c * u),
        (t[1] = d * f + x),
        (t[5] = o * u),
        (t[9] = p * f - v),
        (t[2] = v * f - p),
        (t[6] = a * u),
        (t[10] = x * f + d);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(XE, e, jE);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      Rn.subVectors(e, t),
      Rn.lengthSq() === 0 && (Rn.z = 1),
      Rn.normalize(),
      er.crossVectors(i, Rn),
      er.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (Rn.x += 1e-4) : (Rn.z += 1e-4),
        Rn.normalize(),
        er.crossVectors(i, Rn)),
      er.normalize(),
      ol.crossVectors(Rn, er),
      (r[0] = er.x),
      (r[4] = ol.x),
      (r[8] = Rn.x),
      (r[1] = er.y),
      (r[5] = ol.y),
      (r[9] = Rn.y),
      (r[2] = er.z),
      (r[6] = ol.z),
      (r[10] = Rn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      c = i[12],
      u = i[1],
      f = i[5],
      d = i[9],
      p = i[13],
      v = i[2],
      x = i[6],
      m = i[10],
      h = i[14],
      _ = i[3],
      g = i[7],
      E = i[11],
      w = i[15],
      L = r[0],
      A = r[4],
      U = r[8],
      M = r[12],
      b = r[1],
      $ = r[5],
      J = r[9],
      se = r[13],
      H = r[2],
      Q = r[6],
      ie = r[10],
      te = r[14],
      W = r[3],
      K = r[7],
      G = r[11],
      z = r[15];
    return (
      (s[0] = o * L + a * b + l * H + c * W),
      (s[4] = o * A + a * $ + l * Q + c * K),
      (s[8] = o * U + a * J + l * ie + c * G),
      (s[12] = o * M + a * se + l * te + c * z),
      (s[1] = u * L + f * b + d * H + p * W),
      (s[5] = u * A + f * $ + d * Q + p * K),
      (s[9] = u * U + f * J + d * ie + p * G),
      (s[13] = u * M + f * se + d * te + p * z),
      (s[2] = v * L + x * b + m * H + h * W),
      (s[6] = v * A + x * $ + m * Q + h * K),
      (s[10] = v * U + x * J + m * ie + h * G),
      (s[14] = v * M + x * se + m * te + h * z),
      (s[3] = _ * L + g * b + E * H + w * W),
      (s[7] = _ * A + g * $ + E * Q + w * K),
      (s[11] = _ * U + g * J + E * ie + w * G),
      (s[15] = _ * M + g * se + E * te + w * z),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      f = e[6],
      d = e[10],
      p = e[14],
      v = e[3],
      x = e[7],
      m = e[11],
      h = e[15];
    return (
      v *
        (+s * l * f -
          r * c * f -
          s * a * d +
          i * c * d +
          r * a * p -
          i * l * p) +
      x *
        (+t * l * p -
          t * c * d +
          s * o * d -
          r * o * p +
          r * c * u -
          s * l * u) +
      m *
        (+t * c * f -
          t * a * p -
          s * o * f +
          i * o * p +
          s * a * u -
          i * c * u) +
      h *
        (-r * a * u - t * l * f + t * a * d + r * o * f - i * o * d + i * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      f = e[9],
      d = e[10],
      p = e[11],
      v = e[12],
      x = e[13],
      m = e[14],
      h = e[15],
      _ = f * m * c - x * d * c + x * l * p - a * m * p - f * l * h + a * d * h,
      g = v * d * c - u * m * c - v * l * p + o * m * p + u * l * h - o * d * h,
      E = u * x * c - v * f * c + v * a * p - o * x * p - u * a * h + o * f * h,
      w = v * f * l - u * x * l - v * a * d + o * x * d + u * a * m - o * f * m,
      L = t * _ + i * g + r * E + s * w;
    if (L === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / L;
    return (
      (e[0] = _ * A),
      (e[1] =
        (x * d * s -
          f * m * s -
          x * r * p +
          i * m * p +
          f * r * h -
          i * d * h) *
        A),
      (e[2] =
        (a * m * s -
          x * l * s +
          x * r * c -
          i * m * c -
          a * r * h +
          i * l * h) *
        A),
      (e[3] =
        (f * l * s -
          a * d * s -
          f * r * c +
          i * d * c +
          a * r * p -
          i * l * p) *
        A),
      (e[4] = g * A),
      (e[5] =
        (u * m * s -
          v * d * s +
          v * r * p -
          t * m * p -
          u * r * h +
          t * d * h) *
        A),
      (e[6] =
        (v * l * s -
          o * m * s -
          v * r * c +
          t * m * c +
          o * r * h -
          t * l * h) *
        A),
      (e[7] =
        (o * d * s -
          u * l * s +
          u * r * c -
          t * d * c -
          o * r * p +
          t * l * p) *
        A),
      (e[8] = E * A),
      (e[9] =
        (v * f * s -
          u * x * s -
          v * i * p +
          t * x * p +
          u * i * h -
          t * f * h) *
        A),
      (e[10] =
        (o * x * s -
          v * a * s +
          v * i * c -
          t * x * c -
          o * i * h +
          t * a * h) *
        A),
      (e[11] =
        (u * a * s -
          o * f * s -
          u * i * c +
          t * f * c +
          o * i * p -
          t * a * p) *
        A),
      (e[12] = w * A),
      (e[13] =
        (u * x * r -
          v * f * r +
          v * i * d -
          t * x * d -
          u * i * m +
          t * f * m) *
        A),
      (e[14] =
        (v * a * r -
          o * x * r -
          v * i * l +
          t * x * l +
          o * i * m -
          t * a * m) *
        A),
      (e[15] =
        (o * f * r -
          u * a * r +
          u * i * l -
          t * f * l -
          o * i * d +
          t * a * d) *
        A),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      c = s * o,
      u = s * a;
    return (
      this.set(
        c * o + i,
        c * a - r * l,
        c * l + r * a,
        0,
        c * a + r * l,
        u * a + i,
        u * l - r * o,
        0,
        c * l - r * a,
        u * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = s + s,
      u = o + o,
      f = a + a,
      d = s * c,
      p = s * u,
      v = s * f,
      x = o * u,
      m = o * f,
      h = a * f,
      _ = l * c,
      g = l * u,
      E = l * f,
      w = i.x,
      L = i.y,
      A = i.z;
    return (
      (r[0] = (1 - (x + h)) * w),
      (r[1] = (p + E) * w),
      (r[2] = (v - g) * w),
      (r[3] = 0),
      (r[4] = (p - E) * L),
      (r[5] = (1 - (d + h)) * L),
      (r[6] = (m + _) * L),
      (r[7] = 0),
      (r[8] = (v + g) * A),
      (r[9] = (m - _) * A),
      (r[10] = (1 - (d + x)) * A),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Es.set(r[0], r[1], r[2]).length();
    const o = Es.set(r[4], r[5], r[6]).length(),
      a = Es.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Jn.copy(this);
    const c = 1 / s,
      u = 1 / o,
      f = 1 / a;
    return (
      (Jn.elements[0] *= c),
      (Jn.elements[1] *= c),
      (Jn.elements[2] *= c),
      (Jn.elements[4] *= u),
      (Jn.elements[5] *= u),
      (Jn.elements[6] *= u),
      (Jn.elements[8] *= f),
      (Jn.elements[9] *= f),
      (Jn.elements[10] *= f),
      t.setFromRotationMatrix(Jn),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o, a = Bi) {
    const l = this.elements,
      c = (2 * s) / (t - e),
      u = (2 * s) / (i - r),
      f = (t + e) / (t - e),
      d = (i + r) / (i - r);
    let p, v;
    if (a === Bi) (p = -(o + s) / (o - s)), (v = (-2 * o * s) / (o - s));
    else if (a === xc) (p = -o / (o - s)), (v = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = f),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = d),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = p),
      (l[14] = v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o, a = Bi) {
    const l = this.elements,
      c = 1 / (t - e),
      u = 1 / (i - r),
      f = 1 / (o - s),
      d = (t + e) * c,
      p = (i + r) * u;
    let v, x;
    if (a === Bi) (v = (o + s) * f), (x = -2 * f);
    else if (a === xc) (v = s * f), (x = -1 * f);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -d),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -p),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = x),
      (l[14] = -v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Es = new B(),
  Jn = new tt(),
  XE = new B(0, 0, 0),
  jE = new B(1, 1, 1),
  er = new B(),
  ol = new B(),
  Rn = new B(),
  Tm = new tt(),
  wm = new Si();
class zc {
  constructor(e = 0, t = 0, i = 0, r = zc.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      c = r[5],
      u = r[9],
      f = r[2],
      d = r[6],
      p = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(Kt(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, p)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(d, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Kt(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, p)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-f, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Kt(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._y = Math.atan2(-f, p)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Kt(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._x = Math.atan2(d, p)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
        break;
      case "YZX":
        (this._z = Math.asin(Kt(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-f, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, p)));
        break;
      case "XZY":
        (this._z = Math.asin(-Kt(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(d, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-u, p)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      Tm.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Tm, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return wm.setFromEuler(this), this.setFromQuaternion(wm, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
zc.DEFAULT_ORDER = "XYZ";
class gv {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let YE = 0;
const Am = new B(),
  Ms = new Si(),
  bi = new tt(),
  al = new B(),
  ko = new B(),
  qE = new B(),
  KE = new Si(),
  Rm = new B(1, 0, 0),
  bm = new B(0, 1, 0),
  Cm = new B(0, 0, 1),
  ZE = { type: "added" },
  $E = { type: "removed" };
class Ct extends ds {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: YE++ }),
      (this.uuid = ci()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Ct.DEFAULT_UP.clone());
    const e = new B(),
      t = new zc(),
      i = new Si(),
      r = new B(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new tt() },
        normalMatrix: { value: new et() },
      }),
      (this.matrix = new tt()),
      (this.matrixWorld = new tt()),
      (this.matrixAutoUpdate = Ct.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new gv()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ms.setFromAxisAngle(e, t), this.quaternion.multiply(Ms), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ms.setFromAxisAngle(e, t), this.quaternion.premultiply(Ms), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Rm, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(bm, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Cm, e);
  }
  translateOnAxis(e, t) {
    return (
      Am.copy(e).applyQuaternion(this.quaternion),
      this.position.add(Am.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Rm, e);
  }
  translateY(e) {
    return this.translateOnAxis(bm, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Cm, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(bi.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? al.copy(e) : al.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      ko.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? bi.lookAt(ko, al, this.up)
        : bi.lookAt(al, ko, this.up),
      this.quaternion.setFromRotationMatrix(bi),
      r &&
        (bi.extractRotation(r.matrixWorld),
        Ms.setFromRotationMatrix(bi),
        this.quaternion.premultiply(Ms.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(ZE))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent($E)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      bi.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), bi.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(bi),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let r = 0, s = this.children.length; r < s; r++) {
      const o = this.children[r].getObjectsByProperty(e, t);
      o.length > 0 && (i = i.concat(o));
    }
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ko, e, qE), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ko, KE, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const f = l[c];
            s(e.shapes, f);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        u = o(e.images),
        f = o(e.shapes),
        d = o(e.skeletons),
        p = o(e.animations),
        v = o(e.nodes);
      a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        c.length > 0 && (i.textures = c),
        u.length > 0 && (i.images = u),
        f.length > 0 && (i.shapes = f),
        d.length > 0 && (i.skeletons = d),
        p.length > 0 && (i.animations = p),
        v.length > 0 && (i.nodes = v);
    }
    return (i.object = r), i;
    function o(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Ct.DEFAULT_UP = new B(0, 1, 0);
Ct.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ct.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ei = new B(),
  Ci = new B(),
  Pu = new B(),
  Li = new B(),
  Ts = new B(),
  ws = new B(),
  Lm = new B(),
  Iu = new B(),
  Nu = new B(),
  Du = new B();
let ll = !1;
class si {
  constructor(e = new B(), t = new B(), i = new B()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), ei.subVectors(e, t), r.cross(ei);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    ei.subVectors(r, t), Ci.subVectors(i, t), Pu.subVectors(e, t);
    const o = ei.dot(ei),
      a = ei.dot(Ci),
      l = ei.dot(Pu),
      c = Ci.dot(Ci),
      u = Ci.dot(Pu),
      f = o * c - a * a;
    if (f === 0) return s.set(-2, -1, -1);
    const d = 1 / f,
      p = (c * l - a * u) * d,
      v = (o * u - a * l) * d;
    return s.set(1 - p - v, v, p);
  }
  static containsPoint(e, t, i, r) {
    return (
      this.getBarycoord(e, t, i, r, Li),
      Li.x >= 0 && Li.y >= 0 && Li.x + Li.y <= 1
    );
  }
  static getUV(e, t, i, r, s, o, a, l) {
    return (
      ll === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (ll = !0)),
      this.getInterpolation(e, t, i, r, s, o, a, l)
    );
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return (
      this.getBarycoord(e, t, i, r, Li),
      l.setScalar(0),
      l.addScaledVector(s, Li.x),
      l.addScaledVector(o, Li.y),
      l.addScaledVector(a, Li.z),
      l
    );
  }
  static isFrontFacing(e, t, i, r) {
    return ei.subVectors(i, t), Ci.subVectors(e, t), ei.cross(Ci).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      ei.subVectors(this.c, this.b),
      Ci.subVectors(this.a, this.b),
      ei.cross(Ci).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return si.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return si.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, s) {
    return (
      ll === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (ll = !0)),
      si.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    );
  }
  getInterpolation(e, t, i, r, s) {
    return si.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return si.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return si.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    Ts.subVectors(r, i), ws.subVectors(s, i), Iu.subVectors(e, i);
    const l = Ts.dot(Iu),
      c = ws.dot(Iu);
    if (l <= 0 && c <= 0) return t.copy(i);
    Nu.subVectors(e, r);
    const u = Ts.dot(Nu),
      f = ws.dot(Nu);
    if (u >= 0 && f <= u) return t.copy(r);
    const d = l * f - u * c;
    if (d <= 0 && l >= 0 && u <= 0)
      return (o = l / (l - u)), t.copy(i).addScaledVector(Ts, o);
    Du.subVectors(e, s);
    const p = Ts.dot(Du),
      v = ws.dot(Du);
    if (v >= 0 && p <= v) return t.copy(s);
    const x = p * c - l * v;
    if (x <= 0 && c >= 0 && v <= 0)
      return (a = c / (c - v)), t.copy(i).addScaledVector(ws, a);
    const m = u * v - p * f;
    if (m <= 0 && f - u >= 0 && p - v >= 0)
      return (
        Lm.subVectors(s, r),
        (a = (f - u) / (f - u + (p - v))),
        t.copy(r).addScaledVector(Lm, a)
      );
    const h = 1 / (m + x + d);
    return (
      (o = x * h),
      (a = d * h),
      t.copy(i).addScaledVector(Ts, o).addScaledVector(ws, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const _v = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  tr = { h: 0, s: 0, l: 0 },
  cl = { h: 0, s: 0, l: 0 };
function Uu(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Ke {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
        ? this.setHex(r)
        : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Rt) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      lt.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = lt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      lt.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = lt.workingColorSpace) {
    if (((e = ch(e, 1)), (t = Kt(t, 0, 1)), (i = Kt(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      (this.r = Uu(o, s, e + 1 / 3)),
        (this.g = Uu(o, s, e)),
        (this.b = Uu(o, s, e - 1 / 3));
    }
    return lt.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Rt) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Rt) {
    const i = _v[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = eo(e.r)), (this.g = eo(e.g)), (this.b = eo(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Mu(e.r)), (this.g = Mu(e.g)), (this.b = Mu(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Rt) {
    return (
      lt.fromWorkingColorSpace(an.copy(this), e),
      Math.round(Kt(an.r * 255, 0, 255)) * 65536 +
        Math.round(Kt(an.g * 255, 0, 255)) * 256 +
        Math.round(Kt(an.b * 255, 0, 255))
    );
  }
  getHexString(e = Rt) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = lt.workingColorSpace) {
    lt.fromWorkingColorSpace(an.copy(this), t);
    const i = an.r,
      r = an.g,
      s = an.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let l, c;
    const u = (a + o) / 2;
    if (a === o) (l = 0), (c = 0);
    else {
      const f = o - a;
      switch (((c = u <= 0.5 ? f / (o + a) : f / (2 - o - a)), o)) {
        case i:
          l = (r - s) / f + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / f + 2;
          break;
        case s:
          l = (i - r) / f + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, t = lt.workingColorSpace) {
    return (
      lt.fromWorkingColorSpace(an.copy(this), t),
      (e.r = an.r),
      (e.g = an.g),
      (e.b = an.b),
      e
    );
  }
  getStyle(e = Rt) {
    lt.fromWorkingColorSpace(an.copy(this), e);
    const t = an.r,
      i = an.g,
      r = an.b;
    return e !== Rt
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(
          r * 255
        )})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(tr), this.setHSL(tr.h + e, tr.s + t, tr.l + i);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(tr), e.getHSL(cl);
    const i = sa(tr.h, cl.h, t),
      r = sa(tr.s, cl.s, t),
      s = sa(tr.l, cl.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const an = new Ke();
Ke.NAMES = _v;
let QE = 0;
class xi extends ds {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: QE++ }),
      (this.uuid = ci()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Js),
      (this.side = Xi),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Zf),
      (this.blendDst = $f),
      (this.blendEquation = Xr),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Ke(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = pc),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = _m),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = _s),
      (this.stencilZFail = _s),
      (this.stencilZPass = _s),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Js && (i.blending = this.blending),
      this.side !== Xi && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== Zf && (i.blendSrc = this.blendSrc),
      this.blendDst !== $f && (i.blendDst = this.blendDst),
      this.blendEquation !== Xr && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== pc && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== _m && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== _s && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== _s && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== _s && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Zr extends xi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = $0),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Ui = JE();
function JE() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : c < -14
      ? ((i[l] = 1024 >> (-c - 14)),
        (i[l | 256] = (1024 >> (-c - 14)) | 32768),
        (r[l] = -c - 1),
        (r[l | 256] = -c - 1))
      : c <= 15
      ? ((i[l] = (c + 15) << 10),
        (i[l | 256] = ((c + 15) << 10) | 32768),
        (r[l] = 13),
        (r[l | 256] = 13))
      : c < 128
      ? ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 24), (r[l | 256] = 24))
      : ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 13), (r[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0;
    for (; !(c & 8388608); ) (c <<= 1), (u -= 8388608);
    (c &= -8388609), (u += 947912704), (s[l] = c | u);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function eM(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = Kt(n, -65504, 65504)),
    (Ui.floatView[0] = n);
  const e = Ui.uint32View[0],
    t = (e >> 23) & 511;
  return Ui.baseTable[t] + ((e & 8388607) >> Ui.shiftTable[t]);
}
function tM(n) {
  const e = n >> 10;
  return (
    (Ui.uint32View[0] =
      Ui.mantissaTable[Ui.offsetTable[e] + (n & 1023)] + Ui.exponentTable[e]),
    Ui.floatView[0]
  );
}
const Pm = { toHalfFloat: eM, fromHalfFloat: tM },
  Ot = new B(),
  ul = new Ge();
class gn {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = td),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = jn),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        ul.fromBufferAttribute(this, t),
          ul.applyMatrix3(e),
          this.setXY(t, ul.x, ul.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Ot.fromBufferAttribute(this, t),
          Ot.applyMatrix3(e),
          this.setXYZ(t, Ot.x, Ot.y, Ot.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ot.fromBufferAttribute(this, t),
        Ot.applyMatrix4(e),
        this.setXYZ(t, Ot.x, Ot.y, Ot.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ot.fromBufferAttribute(this, t),
        Ot.applyNormalMatrix(e),
        this.setXYZ(t, Ot.x, Ot.y, Ot.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ot.fromBufferAttribute(this, t),
        Ot.transformDirection(e),
        this.setXYZ(t, Ot.x, Ot.y, Ot.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = _i(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = ht(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = ht(t, this.array)), (i = ht(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = ht(t, this.array)),
        (i = ht(i, this.array)),
        (r = ht(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = ht(t, this.array)),
        (i = ht(i, this.array)),
        (r = ht(r, this.array)),
        (s = ht(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== td && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
}
class vv extends gn {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class yv extends gn {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class qn extends gn {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let nM = 0;
const zn = new tt(),
  Ou = new Ct(),
  As = new B(),
  bn = new Yi(),
  Bo = new Yi(),
  Xt = new B();
class fi extends ds {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: nM++ }),
      (this.uuid = ci()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (dv(e) ? yv : vv)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new et().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return zn.makeRotationFromQuaternion(e), this.applyMatrix4(zn), this;
  }
  rotateX(e) {
    return zn.makeRotationX(e), this.applyMatrix4(zn), this;
  }
  rotateY(e) {
    return zn.makeRotationY(e), this.applyMatrix4(zn), this;
  }
  rotateZ(e) {
    return zn.makeRotationZ(e), this.applyMatrix4(zn), this;
  }
  translate(e, t, i) {
    return zn.makeTranslation(e, t, i), this.applyMatrix4(zn), this;
  }
  scale(e, t, i) {
    return zn.makeScale(e, t, i), this.applyMatrix4(zn), this;
  }
  lookAt(e) {
    return Ou.lookAt(e), Ou.updateMatrix(), this.applyMatrix4(Ou.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(As).negate(),
      this.translate(As.x, As.y, As.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new qn(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Yi());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new B(-1 / 0, -1 / 0, -1 / 0),
          new B(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          bn.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Xt.addVectors(this.boundingBox.min, bn.min),
                this.boundingBox.expandByPoint(Xt),
                Xt.addVectors(this.boundingBox.max, bn.max),
                this.boundingBox.expandByPoint(Xt))
              : (this.boundingBox.expandByPoint(bn.min),
                this.boundingBox.expandByPoint(bn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ei());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new B(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((bn.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          Bo.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Xt.addVectors(bn.min, Bo.min),
                bn.expandByPoint(Xt),
                Xt.addVectors(bn.max, Bo.max),
                bn.expandByPoint(Xt))
              : (bn.expandByPoint(Bo.min), bn.expandByPoint(Bo.max));
        }
      bn.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Xt.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Xt)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            Xt.fromBufferAttribute(a, c),
              l && (As.fromBufferAttribute(e, c), Xt.add(As)),
              (r = Math.max(r, i.distanceToSquared(Xt)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = e.array,
      r = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new gn(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      u = [];
    for (let b = 0; b < a; b++) (c[b] = new B()), (u[b] = new B());
    const f = new B(),
      d = new B(),
      p = new B(),
      v = new Ge(),
      x = new Ge(),
      m = new Ge(),
      h = new B(),
      _ = new B();
    function g(b, $, J) {
      f.fromArray(r, b * 3),
        d.fromArray(r, $ * 3),
        p.fromArray(r, J * 3),
        v.fromArray(o, b * 2),
        x.fromArray(o, $ * 2),
        m.fromArray(o, J * 2),
        d.sub(f),
        p.sub(f),
        x.sub(v),
        m.sub(v);
      const se = 1 / (x.x * m.y - m.x * x.y);
      isFinite(se) &&
        (h
          .copy(d)
          .multiplyScalar(m.y)
          .addScaledVector(p, -x.y)
          .multiplyScalar(se),
        _.copy(p)
          .multiplyScalar(x.x)
          .addScaledVector(d, -m.x)
          .multiplyScalar(se),
        c[b].add(h),
        c[$].add(h),
        c[J].add(h),
        u[b].add(_),
        u[$].add(_),
        u[J].add(_));
    }
    let E = this.groups;
    E.length === 0 && (E = [{ start: 0, count: i.length }]);
    for (let b = 0, $ = E.length; b < $; ++b) {
      const J = E[b],
        se = J.start,
        H = J.count;
      for (let Q = se, ie = se + H; Q < ie; Q += 3)
        g(i[Q + 0], i[Q + 1], i[Q + 2]);
    }
    const w = new B(),
      L = new B(),
      A = new B(),
      U = new B();
    function M(b) {
      A.fromArray(s, b * 3), U.copy(A);
      const $ = c[b];
      w.copy($),
        w.sub(A.multiplyScalar(A.dot($))).normalize(),
        L.crossVectors(U, $);
      const se = L.dot(u[b]) < 0 ? -1 : 1;
      (l[b * 4] = w.x),
        (l[b * 4 + 1] = w.y),
        (l[b * 4 + 2] = w.z),
        (l[b * 4 + 3] = se);
    }
    for (let b = 0, $ = E.length; b < $; ++b) {
      const J = E[b],
        se = J.start,
        H = J.count;
      for (let Q = se, ie = se + H; Q < ie; Q += 3)
        M(i[Q + 0]), M(i[Q + 1]), M(i[Q + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new gn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let d = 0, p = i.count; d < p; d++) i.setXYZ(d, 0, 0, 0);
      const r = new B(),
        s = new B(),
        o = new B(),
        a = new B(),
        l = new B(),
        c = new B(),
        u = new B(),
        f = new B();
      if (e)
        for (let d = 0, p = e.count; d < p; d += 3) {
          const v = e.getX(d + 0),
            x = e.getX(d + 1),
            m = e.getX(d + 2);
          r.fromBufferAttribute(t, v),
            s.fromBufferAttribute(t, x),
            o.fromBufferAttribute(t, m),
            u.subVectors(o, s),
            f.subVectors(r, s),
            u.cross(f),
            a.fromBufferAttribute(i, v),
            l.fromBufferAttribute(i, x),
            c.fromBufferAttribute(i, m),
            a.add(u),
            l.add(u),
            c.add(u),
            i.setXYZ(v, a.x, a.y, a.z),
            i.setXYZ(x, l.x, l.y, l.z),
            i.setXYZ(m, c.x, c.y, c.z);
        }
      else
        for (let d = 0, p = t.count; d < p; d += 3)
          r.fromBufferAttribute(t, d + 0),
            s.fromBufferAttribute(t, d + 1),
            o.fromBufferAttribute(t, d + 2),
            u.subVectors(o, s),
            f.subVectors(r, s),
            u.cross(f),
            i.setXYZ(d + 0, u.x, u.y, u.z),
            i.setXYZ(d + 1, u.x, u.y, u.z),
            i.setXYZ(d + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Xt.fromBufferAttribute(e, t),
        Xt.normalize(),
        e.setXYZ(t, Xt.x, Xt.y, Xt.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        u = a.itemSize,
        f = a.normalized,
        d = new c.constructor(l.length * u);
      let p = 0,
        v = 0;
      for (let x = 0, m = l.length; x < m; x++) {
        a.isInterleavedBufferAttribute
          ? (p = l[x] * a.data.stride + a.offset)
          : (p = l[x] * u);
        for (let h = 0; h < u; h++) d[v++] = c[p++];
      }
      return new gn(d, u, f);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new fi(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const l = r[a],
        c = e(l, i);
      t.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        c = s[a];
      for (let u = 0, f = c.length; u < f; u++) {
        const d = c[u],
          p = e(d, i);
        l.push(p);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let f = 0, d = c.length; f < d; f++) {
        const p = c[f];
        u.push(p.toJSON(e.data));
      }
      u.length > 0 && ((r[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const c in r) {
      const u = r[c];
      this.setAttribute(c, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        f = s[c];
      for (let d = 0, p = f.length; d < p; d++) u.push(f[d].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, u = o.length; c < u; c++) {
      const f = o[c];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Im = new tt(),
  Br = new Ia(),
  fl = new Ei(),
  Nm = new B(),
  Rs = new B(),
  bs = new B(),
  Cs = new B(),
  Fu = new B(),
  dl = new B(),
  hl = new Ge(),
  pl = new Ge(),
  ml = new Ge(),
  Dm = new B(),
  Um = new B(),
  Om = new B(),
  gl = new B(),
  _l = new B();
class Dn extends Ct {
  constructor(e = new fi(), t = new Zr()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      dl.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = a[l],
          f = s[l];
        u !== 0 &&
          (Fu.fromBufferAttribute(f, e),
          o ? dl.addScaledVector(Fu, u) : dl.addScaledVector(Fu.sub(t), u));
      }
      t.add(dl);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      fl.copy(i.boundingSphere),
      fl.applyMatrix4(s),
      Br.copy(e.ray).recast(e.near),
      !(
        fl.containsPoint(Br.origin) === !1 &&
        (Br.intersectSphere(fl, Nm) === null ||
          Br.origin.distanceToSquared(Nm) > (e.far - e.near) ** 2)
      ) &&
        (Im.copy(s).invert(),
        Br.copy(e.ray).applyMatrix4(Im),
        !(i.boundingBox !== null && Br.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, t, Br)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      f = s.attributes.normal,
      d = s.groups,
      p = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let v = 0, x = d.length; v < x; v++) {
          const m = d[v],
            h = o[m.materialIndex],
            _ = Math.max(m.start, p.start),
            g = Math.min(
              a.count,
              Math.min(m.start + m.count, p.start + p.count)
            );
          for (let E = _, w = g; E < w; E += 3) {
            const L = a.getX(E),
              A = a.getX(E + 1),
              U = a.getX(E + 2);
            (r = vl(this, h, e, i, c, u, f, L, A, U)),
              r &&
                ((r.faceIndex = Math.floor(E / 3)),
                (r.face.materialIndex = m.materialIndex),
                t.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start),
          x = Math.min(a.count, p.start + p.count);
        for (let m = v, h = x; m < h; m += 3) {
          const _ = a.getX(m),
            g = a.getX(m + 1),
            E = a.getX(m + 2);
          (r = vl(this, o, e, i, c, u, f, _, g, E)),
            r && ((r.faceIndex = Math.floor(m / 3)), t.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let v = 0, x = d.length; v < x; v++) {
          const m = d[v],
            h = o[m.materialIndex],
            _ = Math.max(m.start, p.start),
            g = Math.min(
              l.count,
              Math.min(m.start + m.count, p.start + p.count)
            );
          for (let E = _, w = g; E < w; E += 3) {
            const L = E,
              A = E + 1,
              U = E + 2;
            (r = vl(this, h, e, i, c, u, f, L, A, U)),
              r &&
                ((r.faceIndex = Math.floor(E / 3)),
                (r.face.materialIndex = m.materialIndex),
                t.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start),
          x = Math.min(l.count, p.start + p.count);
        for (let m = v, h = x; m < h; m += 3) {
          const _ = m,
            g = m + 1,
            E = m + 2;
          (r = vl(this, o, e, i, c, u, f, _, g, E)),
            r && ((r.faceIndex = Math.floor(m / 3)), t.push(r));
        }
      }
  }
}
function iM(n, e, t, i, r, s, o, a) {
  let l;
  if (
    (e.side === An
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === Xi, a)),
    l === null)
  )
    return null;
  _l.copy(a), _l.applyMatrix4(n.matrixWorld);
  const c = t.ray.origin.distanceTo(_l);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: _l.clone(), object: n };
}
function vl(n, e, t, i, r, s, o, a, l, c) {
  n.getVertexPosition(a, Rs),
    n.getVertexPosition(l, bs),
    n.getVertexPosition(c, Cs);
  const u = iM(n, e, t, i, Rs, bs, Cs, gl);
  if (u) {
    r &&
      (hl.fromBufferAttribute(r, a),
      pl.fromBufferAttribute(r, l),
      ml.fromBufferAttribute(r, c),
      (u.uv = si.getInterpolation(gl, Rs, bs, Cs, hl, pl, ml, new Ge()))),
      s &&
        (hl.fromBufferAttribute(s, a),
        pl.fromBufferAttribute(s, l),
        ml.fromBufferAttribute(s, c),
        (u.uv1 = si.getInterpolation(gl, Rs, bs, Cs, hl, pl, ml, new Ge())),
        (u.uv2 = u.uv1)),
      o &&
        (Dm.fromBufferAttribute(o, a),
        Um.fromBufferAttribute(o, l),
        Om.fromBufferAttribute(o, c),
        (u.normal = si.getInterpolation(gl, Rs, bs, Cs, Dm, Um, Om, new B())),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
    const f = { a, b: l, c, normal: new B(), materialIndex: 0 };
    si.getNormal(Rs, bs, Cs, f.normal), (u.face = f);
  }
  return u;
}
class Na extends fi {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      c = [],
      u = [],
      f = [];
    let d = 0,
      p = 0;
    v("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      v("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      v("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      v("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      v("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      v("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new qn(c, 3)),
      this.setAttribute("normal", new qn(u, 3)),
      this.setAttribute("uv", new qn(f, 2));
    function v(x, m, h, _, g, E, w, L, A, U, M) {
      const b = E / A,
        $ = w / U,
        J = E / 2,
        se = w / 2,
        H = L / 2,
        Q = A + 1,
        ie = U + 1;
      let te = 0,
        W = 0;
      const K = new B();
      for (let G = 0; G < ie; G++) {
        const z = G * $ - se;
        for (let V = 0; V < Q; V++) {
          const _e = V * b - J;
          (K[x] = _e * _),
            (K[m] = z * g),
            (K[h] = H),
            c.push(K.x, K.y, K.z),
            (K[x] = 0),
            (K[m] = 0),
            (K[h] = L > 0 ? 1 : -1),
            u.push(K.x, K.y, K.z),
            f.push(V / A),
            f.push(1 - G / U),
            (te += 1);
        }
      }
      for (let G = 0; G < U; G++)
        for (let z = 0; z < A; z++) {
          const V = d + z + Q * G,
            _e = d + z + Q * (G + 1),
            ve = d + (z + 1) + Q * (G + 1),
            we = d + (z + 1) + Q * G;
          l.push(V, _e, we), l.push(_e, ve, we), (W += 6);
        }
      a.addGroup(p, W, M), (p += W), (d += te);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Na(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function go(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r);
    }
  }
  return e;
}
function dn(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = go(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function rM(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function xv(n) {
  return n.getRenderTarget() === null
    ? n.outputColorSpace
    : lt.workingColorSpace;
}
const sM = { clone: go, merge: dn };
var oM = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  aM = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Cr extends xi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = oM),
      (this.fragmentShader = aM),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = go(e.uniforms)),
      (this.uniformsGroups = rM(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[r] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
        : (t.uniforms[r] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Sv extends Ct {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new tt()),
      (this.projectionMatrix = new tt()),
      (this.projectionMatrixInverse = new tt()),
      (this.coordinateSystem = Bi);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class pn extends Sv {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = mo * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(ra * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return mo * 2 * Math.atan(Math.tan(ra * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(ra * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      (s += (o.offsetX * r) / l),
        (t -= (o.offsetY * i) / c),
        (r *= o.width / l),
        (i *= o.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Ls = -90,
  Ps = 1;
class lM extends Ct {
  constructor(e, t, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const r = new pn(Ls, Ps, e, t);
    (r.layers = this.layers), this.add(r);
    const s = new pn(Ls, Ps, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new pn(Ls, Ps, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new pn(Ls, Ps, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new pn(Ls, Ps, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new pn(Ls, Ps, e, t);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, r, s, o, a, l] = t;
    for (const c of t) this.remove(c);
    if (e === Bi)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === xc)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, l, c, u] = this.children,
      f = e.getRenderTarget(),
      d = e.getActiveCubeFace(),
      p = e.getActiveMipmapLevel(),
      v = e.xr.enabled;
    e.xr.enabled = !1;
    const x = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(t, s),
      e.setRenderTarget(i, 1, r),
      e.render(t, o),
      e.setRenderTarget(i, 2, r),
      e.render(t, a),
      e.setRenderTarget(i, 3, r),
      e.render(t, l),
      e.setRenderTarget(i, 4, r),
      e.render(t, c),
      (i.texture.generateMipmaps = x),
      e.setRenderTarget(i, 5, r),
      e.render(t, u),
      e.setRenderTarget(f, d, p),
      (e.xr.enabled = v),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class Ev extends tn {
  constructor(e, t, i, r, s, o, a, l, c, u) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : co),
      super(e, t, i, r, s, o, a, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class cM extends ls {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    t.encoding !== void 0 &&
      (oa(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === ns ? Rt : In)),
      (this.texture = new Ev(
        r,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : zt);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Na(5, 5, 5),
      s = new Cr({
        name: "CubemapFromEquirect",
        uniforms: go(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: An,
        blending: Er,
      });
    s.uniforms.tEquirect.value = t;
    const o = new Dn(r, s),
      a = t.minFilter;
    return (
      t.minFilter === br && (t.minFilter = zt),
      new lM(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const ku = new B(),
  uM = new B(),
  fM = new et();
class or {
  constructor(e = new B(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = ku.subVectors(i, t).cross(uM.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(ku),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || fM.getNormalMatrix(e),
      r = this.coplanarPoint(ku).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const zr = new Ei(),
  yl = new B();
class fh {
  constructor(
    e = new or(),
    t = new or(),
    i = new or(),
    r = new or(),
    s = new or(),
    o = new or()
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = Bi) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      o = r[1],
      a = r[2],
      l = r[3],
      c = r[4],
      u = r[5],
      f = r[6],
      d = r[7],
      p = r[8],
      v = r[9],
      x = r[10],
      m = r[11],
      h = r[12],
      _ = r[13],
      g = r[14],
      E = r[15];
    if (
      (i[0].setComponents(l - s, d - c, m - p, E - h).normalize(),
      i[1].setComponents(l + s, d + c, m + p, E + h).normalize(),
      i[2].setComponents(l + o, d + u, m + v, E + _).normalize(),
      i[3].setComponents(l - o, d - u, m - v, E - _).normalize(),
      i[4].setComponents(l - a, d - f, m - x, E - g).normalize(),
      t === Bi)
    )
      i[5].setComponents(l + a, d + f, m + x, E + g).normalize();
    else if (t === xc) i[5].setComponents(a, f, x, g).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        zr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        zr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(zr);
  }
  intersectsSprite(e) {
    return (
      zr.center.set(0, 0, 0),
      (zr.radius = 0.7071067811865476),
      zr.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(zr)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((yl.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (yl.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (yl.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(yl) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Mv() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function dM(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function r(c, u) {
    const f = c.array,
      d = c.usage,
      p = n.createBuffer();
    n.bindBuffer(u, p), n.bufferData(u, f, d), c.onUploadCallback();
    let v;
    if (f instanceof Float32Array) v = n.FLOAT;
    else if (f instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t) v = n.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else v = n.UNSIGNED_SHORT;
    else if (f instanceof Int16Array) v = n.SHORT;
    else if (f instanceof Uint32Array) v = n.UNSIGNED_INT;
    else if (f instanceof Int32Array) v = n.INT;
    else if (f instanceof Int8Array) v = n.BYTE;
    else if (f instanceof Uint8Array) v = n.UNSIGNED_BYTE;
    else if (f instanceof Uint8ClampedArray) v = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + f
      );
    return {
      buffer: p,
      type: v,
      bytesPerElement: f.BYTES_PER_ELEMENT,
      version: c.version,
    };
  }
  function s(c, u, f) {
    const d = u.array,
      p = u.updateRange;
    n.bindBuffer(f, c),
      p.count === -1
        ? n.bufferSubData(f, 0, d)
        : (t
            ? n.bufferSubData(
                f,
                p.offset * d.BYTES_PER_ELEMENT,
                d,
                p.offset,
                p.count
              )
            : n.bufferSubData(
                f,
                p.offset * d.BYTES_PER_ELEMENT,
                d.subarray(p.offset, p.offset + p.count)
              ),
          (p.count = -1)),
      u.onUploadCallback();
  }
  function o(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function a(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = i.get(c);
    u && (n.deleteBuffer(u.buffer), i.delete(c));
  }
  function l(c, u) {
    if (c.isGLBufferAttribute) {
      const d = i.get(c);
      (!d || d.version < c.version) &&
        i.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const f = i.get(c);
    f === void 0
      ? i.set(c, r(c, u))
      : f.version < c.version && (s(f.buffer, c, u), (f.version = c.version));
  }
  return { get: o, remove: a, update: l };
}
class dh extends fi {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      c = a + 1,
      u = l + 1,
      f = e / a,
      d = t / l,
      p = [],
      v = [],
      x = [],
      m = [];
    for (let h = 0; h < u; h++) {
      const _ = h * d - o;
      for (let g = 0; g < c; g++) {
        const E = g * f - s;
        v.push(E, -_, 0), x.push(0, 0, 1), m.push(g / a), m.push(1 - h / l);
      }
    }
    for (let h = 0; h < l; h++)
      for (let _ = 0; _ < a; _++) {
        const g = _ + c * h,
          E = _ + c * (h + 1),
          w = _ + 1 + c * (h + 1),
          L = _ + 1 + c * h;
        p.push(g, E, L), p.push(E, w, L);
      }
    this.setIndex(p),
      this.setAttribute("position", new qn(v, 3)),
      this.setAttribute("normal", new qn(x, 3)),
      this.setAttribute("uv", new qn(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new dh(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var hM = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  pM = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  mM = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  gM = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  _M = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  vM = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  yM = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  xM = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  SM = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  EM = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  MM = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  TM = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  wM = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  AM = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  RM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  bM = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  CM = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  LM = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  PM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  IM = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  NM = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  DM = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  UM = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  OM = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  FM = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  kM = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  BM = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  zM = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  HM = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  VM = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  GM = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  WM = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  XM = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  jM = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  YM = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  qM = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  KM = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  ZM = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  $M = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  QM = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  JM = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  eT = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  tT = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  nT = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  iT = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  rT = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  sT = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  oT = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  aT = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  lT = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  cT = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  uT = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  fT = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  dT = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  hT = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  pT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  mT = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  gT = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  _T = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  vT = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  yT = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  xT = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  ST = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  ET = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  MT = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  TT = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  wT = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  AT = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  RT = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  bT = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  CT = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  LT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  PT = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  IT = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  NT = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  DT = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  UT = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  OT = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  FT = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  kT = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  BT = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  zT = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  HT = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  VT = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  GT = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  WT = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  XT = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  jT = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  YT = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  qT = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  KT = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  ZT = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  $T = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  QT = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  JT = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  e1 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  t1 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  n1 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  i1 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  r1 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  s1 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  o1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  a1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  l1 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  c1 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const u1 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  f1 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  d1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  h1 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  p1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  m1 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  g1 = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  _1 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  v1 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  y1 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  x1 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  S1 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  E1 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  M1 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  T1 = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  w1 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  A1 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  R1 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  b1 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  C1 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  L1 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  P1 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  I1 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  N1 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  D1 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  U1 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  O1 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  F1 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  k1 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  B1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  z1 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  H1 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  V1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  G1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Qe = {
    alphahash_fragment: hM,
    alphahash_pars_fragment: pM,
    alphamap_fragment: mM,
    alphamap_pars_fragment: gM,
    alphatest_fragment: _M,
    alphatest_pars_fragment: vM,
    aomap_fragment: yM,
    aomap_pars_fragment: xM,
    begin_vertex: SM,
    beginnormal_vertex: EM,
    bsdfs: MM,
    iridescence_fragment: TM,
    bumpmap_pars_fragment: wM,
    clipping_planes_fragment: AM,
    clipping_planes_pars_fragment: RM,
    clipping_planes_pars_vertex: bM,
    clipping_planes_vertex: CM,
    color_fragment: LM,
    color_pars_fragment: PM,
    color_pars_vertex: IM,
    color_vertex: NM,
    common: DM,
    cube_uv_reflection_fragment: UM,
    defaultnormal_vertex: OM,
    displacementmap_pars_vertex: FM,
    displacementmap_vertex: kM,
    emissivemap_fragment: BM,
    emissivemap_pars_fragment: zM,
    colorspace_fragment: HM,
    colorspace_pars_fragment: VM,
    envmap_fragment: GM,
    envmap_common_pars_fragment: WM,
    envmap_pars_fragment: XM,
    envmap_pars_vertex: jM,
    envmap_physical_pars_fragment: rT,
    envmap_vertex: YM,
    fog_vertex: qM,
    fog_pars_vertex: KM,
    fog_fragment: ZM,
    fog_pars_fragment: $M,
    gradientmap_pars_fragment: QM,
    lightmap_fragment: JM,
    lightmap_pars_fragment: eT,
    lights_lambert_fragment: tT,
    lights_lambert_pars_fragment: nT,
    lights_pars_begin: iT,
    lights_toon_fragment: sT,
    lights_toon_pars_fragment: oT,
    lights_phong_fragment: aT,
    lights_phong_pars_fragment: lT,
    lights_physical_fragment: cT,
    lights_physical_pars_fragment: uT,
    lights_fragment_begin: fT,
    lights_fragment_maps: dT,
    lights_fragment_end: hT,
    logdepthbuf_fragment: pT,
    logdepthbuf_pars_fragment: mT,
    logdepthbuf_pars_vertex: gT,
    logdepthbuf_vertex: _T,
    map_fragment: vT,
    map_pars_fragment: yT,
    map_particle_fragment: xT,
    map_particle_pars_fragment: ST,
    metalnessmap_fragment: ET,
    metalnessmap_pars_fragment: MT,
    morphcolor_vertex: TT,
    morphnormal_vertex: wT,
    morphtarget_pars_vertex: AT,
    morphtarget_vertex: RT,
    normal_fragment_begin: bT,
    normal_fragment_maps: CT,
    normal_pars_fragment: LT,
    normal_pars_vertex: PT,
    normal_vertex: IT,
    normalmap_pars_fragment: NT,
    clearcoat_normal_fragment_begin: DT,
    clearcoat_normal_fragment_maps: UT,
    clearcoat_pars_fragment: OT,
    iridescence_pars_fragment: FT,
    opaque_fragment: kT,
    packing: BT,
    premultiplied_alpha_fragment: zT,
    project_vertex: HT,
    dithering_fragment: VT,
    dithering_pars_fragment: GT,
    roughnessmap_fragment: WT,
    roughnessmap_pars_fragment: XT,
    shadowmap_pars_fragment: jT,
    shadowmap_pars_vertex: YT,
    shadowmap_vertex: qT,
    shadowmask_pars_fragment: KT,
    skinbase_vertex: ZT,
    skinning_pars_vertex: $T,
    skinning_vertex: QT,
    skinnormal_vertex: JT,
    specularmap_fragment: e1,
    specularmap_pars_fragment: t1,
    tonemapping_fragment: n1,
    tonemapping_pars_fragment: i1,
    transmission_fragment: r1,
    transmission_pars_fragment: s1,
    uv_pars_fragment: o1,
    uv_pars_vertex: a1,
    uv_vertex: l1,
    worldpos_vertex: c1,
    background_vert: u1,
    background_frag: f1,
    backgroundCube_vert: d1,
    backgroundCube_frag: h1,
    cube_vert: p1,
    cube_frag: m1,
    depth_vert: g1,
    depth_frag: _1,
    distanceRGBA_vert: v1,
    distanceRGBA_frag: y1,
    equirect_vert: x1,
    equirect_frag: S1,
    linedashed_vert: E1,
    linedashed_frag: M1,
    meshbasic_vert: T1,
    meshbasic_frag: w1,
    meshlambert_vert: A1,
    meshlambert_frag: R1,
    meshmatcap_vert: b1,
    meshmatcap_frag: C1,
    meshnormal_vert: L1,
    meshnormal_frag: P1,
    meshphong_vert: I1,
    meshphong_frag: N1,
    meshphysical_vert: D1,
    meshphysical_frag: U1,
    meshtoon_vert: O1,
    meshtoon_frag: F1,
    points_vert: k1,
    points_frag: B1,
    shadow_vert: z1,
    shadow_frag: H1,
    sprite_vert: V1,
    sprite_frag: G1,
  },
  Me = {
    common: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new et() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new et() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new et() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new et() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new et() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new et() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new et() },
      normalScale: { value: new Ge(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new et() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new et() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new et() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new et() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Ke(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new et() },
      alphaTest: { value: 0 },
      uvTransform: { value: new et() },
    },
    sprite: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      center: { value: new Ge(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new et() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new et() },
      alphaTest: { value: 0 },
    },
  },
  mi = {
    basic: {
      uniforms: dn([
        Me.common,
        Me.specularmap,
        Me.envmap,
        Me.aomap,
        Me.lightmap,
        Me.fog,
      ]),
      vertexShader: Qe.meshbasic_vert,
      fragmentShader: Qe.meshbasic_frag,
    },
    lambert: {
      uniforms: dn([
        Me.common,
        Me.specularmap,
        Me.envmap,
        Me.aomap,
        Me.lightmap,
        Me.emissivemap,
        Me.bumpmap,
        Me.normalmap,
        Me.displacementmap,
        Me.fog,
        Me.lights,
        { emissive: { value: new Ke(0) } },
      ]),
      vertexShader: Qe.meshlambert_vert,
      fragmentShader: Qe.meshlambert_frag,
    },
    phong: {
      uniforms: dn([
        Me.common,
        Me.specularmap,
        Me.envmap,
        Me.aomap,
        Me.lightmap,
        Me.emissivemap,
        Me.bumpmap,
        Me.normalmap,
        Me.displacementmap,
        Me.fog,
        Me.lights,
        {
          emissive: { value: new Ke(0) },
          specular: { value: new Ke(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Qe.meshphong_vert,
      fragmentShader: Qe.meshphong_frag,
    },
    standard: {
      uniforms: dn([
        Me.common,
        Me.envmap,
        Me.aomap,
        Me.lightmap,
        Me.emissivemap,
        Me.bumpmap,
        Me.normalmap,
        Me.displacementmap,
        Me.roughnessmap,
        Me.metalnessmap,
        Me.fog,
        Me.lights,
        {
          emissive: { value: new Ke(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Qe.meshphysical_vert,
      fragmentShader: Qe.meshphysical_frag,
    },
    toon: {
      uniforms: dn([
        Me.common,
        Me.aomap,
        Me.lightmap,
        Me.emissivemap,
        Me.bumpmap,
        Me.normalmap,
        Me.displacementmap,
        Me.gradientmap,
        Me.fog,
        Me.lights,
        { emissive: { value: new Ke(0) } },
      ]),
      vertexShader: Qe.meshtoon_vert,
      fragmentShader: Qe.meshtoon_frag,
    },
    matcap: {
      uniforms: dn([
        Me.common,
        Me.bumpmap,
        Me.normalmap,
        Me.displacementmap,
        Me.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Qe.meshmatcap_vert,
      fragmentShader: Qe.meshmatcap_frag,
    },
    points: {
      uniforms: dn([Me.points, Me.fog]),
      vertexShader: Qe.points_vert,
      fragmentShader: Qe.points_frag,
    },
    dashed: {
      uniforms: dn([
        Me.common,
        Me.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Qe.linedashed_vert,
      fragmentShader: Qe.linedashed_frag,
    },
    depth: {
      uniforms: dn([Me.common, Me.displacementmap]),
      vertexShader: Qe.depth_vert,
      fragmentShader: Qe.depth_frag,
    },
    normal: {
      uniforms: dn([
        Me.common,
        Me.bumpmap,
        Me.normalmap,
        Me.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Qe.meshnormal_vert,
      fragmentShader: Qe.meshnormal_frag,
    },
    sprite: {
      uniforms: dn([Me.sprite, Me.fog]),
      vertexShader: Qe.sprite_vert,
      fragmentShader: Qe.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new et() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Qe.background_vert,
      fragmentShader: Qe.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Qe.backgroundCube_vert,
      fragmentShader: Qe.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Qe.cube_vert,
      fragmentShader: Qe.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Qe.equirect_vert,
      fragmentShader: Qe.equirect_frag,
    },
    distanceRGBA: {
      uniforms: dn([
        Me.common,
        Me.displacementmap,
        {
          referencePosition: { value: new B() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Qe.distanceRGBA_vert,
      fragmentShader: Qe.distanceRGBA_frag,
    },
    shadow: {
      uniforms: dn([
        Me.lights,
        Me.fog,
        { color: { value: new Ke(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Qe.shadow_vert,
      fragmentShader: Qe.shadow_frag,
    },
  };
mi.physical = {
  uniforms: dn([
    mi.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new et() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new et() },
      clearcoatNormalScale: { value: new Ge(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new et() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new et() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new et() },
      sheen: { value: 0 },
      sheenColor: { value: new Ke(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new et() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new et() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new et() },
      transmissionSamplerSize: { value: new Ge() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new et() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ke(0) },
      specularColor: { value: new Ke(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new et() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new et() },
      anisotropyVector: { value: new Ge() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new et() },
    },
  ]),
  vertexShader: Qe.meshphysical_vert,
  fragmentShader: Qe.meshphysical_frag,
};
const xl = { r: 0, b: 0, g: 0 };
function W1(n, e, t, i, r, s, o) {
  const a = new Ke(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    f = null,
    d = 0,
    p = null;
  function v(m, h) {
    let _ = !1,
      g = h.isScene === !0 ? h.background : null;
    g && g.isTexture && (g = (h.backgroundBlurriness > 0 ? t : e).get(g)),
      g === null ? x(a, l) : g && g.isColor && (x(g, 1), (_ = !0));
    const E = n.xr.getEnvironmentBlendMode();
    E === "additive"
      ? i.buffers.color.setClear(0, 0, 0, 1, o)
      : E === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || _) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      g && (g.isCubeTexture || g.mapping === kc)
        ? (u === void 0 &&
            ((u = new Dn(
              new Na(1, 1, 1),
              new Cr({
                name: "BackgroundCubeMaterial",
                uniforms: go(mi.backgroundCube.uniforms),
                vertexShader: mi.backgroundCube.vertexShader,
                fragmentShader: mi.backgroundCube.fragmentShader,
                side: An,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            (u.onBeforeRender = function (w, L, A) {
              this.matrixWorld.copyPosition(A.matrixWorld);
            }),
            Object.defineProperty(u.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(u)),
          (u.material.uniforms.envMap.value = g),
          (u.material.uniforms.flipEnvMap.value =
            g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1),
          (u.material.uniforms.backgroundBlurriness.value =
            h.backgroundBlurriness),
          (u.material.uniforms.backgroundIntensity.value =
            h.backgroundIntensity),
          (u.material.toneMapped = lt.getTransfer(g.colorSpace) !== xt),
          (f !== g || d !== g.version || p !== n.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (f = g),
            (d = g.version),
            (p = n.toneMapping)),
          u.layers.enableAll(),
          m.unshift(u, u.geometry, u.material, 0, 0, null))
        : g &&
          g.isTexture &&
          (c === void 0 &&
            ((c = new Dn(
              new dh(2, 2),
              new Cr({
                name: "BackgroundMaterial",
                uniforms: go(mi.background.uniforms),
                vertexShader: mi.background.vertexShader,
                fragmentShader: mi.background.fragmentShader,
                side: Xi,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(c)),
          (c.material.uniforms.t2D.value = g),
          (c.material.uniforms.backgroundIntensity.value =
            h.backgroundIntensity),
          (c.material.toneMapped = lt.getTransfer(g.colorSpace) !== xt),
          g.matrixAutoUpdate === !0 && g.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(g.matrix),
          (f !== g || d !== g.version || p !== n.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (f = g),
            (d = g.version),
            (p = n.toneMapping)),
          c.layers.enableAll(),
          m.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function x(m, h) {
    m.getRGB(xl, xv(n)), i.buffers.color.setClear(xl.r, xl.g, xl.b, h, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (m, h = 1) {
      a.set(m), (l = h), x(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (m) {
      (l = m), x(a, l);
    },
    render: v,
  };
}
function X1(n, e, t, i) {
  const r = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    l = m(null);
  let c = l,
    u = !1;
  function f(H, Q, ie, te, W) {
    let K = !1;
    if (o) {
      const G = x(te, ie, Q);
      c !== G && ((c = G), p(c.object)),
        (K = h(H, te, ie, W)),
        K && _(H, te, ie, W);
    } else {
      const G = Q.wireframe === !0;
      (c.geometry !== te.id || c.program !== ie.id || c.wireframe !== G) &&
        ((c.geometry = te.id),
        (c.program = ie.id),
        (c.wireframe = G),
        (K = !0));
    }
    W !== null && t.update(W, n.ELEMENT_ARRAY_BUFFER),
      (K || u) &&
        ((u = !1),
        U(H, Q, ie, te),
        W !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t.get(W).buffer));
  }
  function d() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function p(H) {
    return i.isWebGL2 ? n.bindVertexArray(H) : s.bindVertexArrayOES(H);
  }
  function v(H) {
    return i.isWebGL2 ? n.deleteVertexArray(H) : s.deleteVertexArrayOES(H);
  }
  function x(H, Q, ie) {
    const te = ie.wireframe === !0;
    let W = a[H.id];
    W === void 0 && ((W = {}), (a[H.id] = W));
    let K = W[Q.id];
    K === void 0 && ((K = {}), (W[Q.id] = K));
    let G = K[te];
    return G === void 0 && ((G = m(d())), (K[te] = G)), G;
  }
  function m(H) {
    const Q = [],
      ie = [],
      te = [];
    for (let W = 0; W < r; W++) (Q[W] = 0), (ie[W] = 0), (te[W] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Q,
      enabledAttributes: ie,
      attributeDivisors: te,
      object: H,
      attributes: {},
      index: null,
    };
  }
  function h(H, Q, ie, te) {
    const W = c.attributes,
      K = Q.attributes;
    let G = 0;
    const z = ie.getAttributes();
    for (const V in z)
      if (z[V].location >= 0) {
        const ve = W[V];
        let we = K[V];
        if (
          (we === void 0 &&
            (V === "instanceMatrix" &&
              H.instanceMatrix &&
              (we = H.instanceMatrix),
            V === "instanceColor" && H.instanceColor && (we = H.instanceColor)),
          ve === void 0 || ve.attribute !== we || (we && ve.data !== we.data))
        )
          return !0;
        G++;
      }
    return c.attributesNum !== G || c.index !== te;
  }
  function _(H, Q, ie, te) {
    const W = {},
      K = Q.attributes;
    let G = 0;
    const z = ie.getAttributes();
    for (const V in z)
      if (z[V].location >= 0) {
        let ve = K[V];
        ve === void 0 &&
          (V === "instanceMatrix" &&
            H.instanceMatrix &&
            (ve = H.instanceMatrix),
          V === "instanceColor" && H.instanceColor && (ve = H.instanceColor));
        const we = {};
        (we.attribute = ve),
          ve && ve.data && (we.data = ve.data),
          (W[V] = we),
          G++;
      }
    (c.attributes = W), (c.attributesNum = G), (c.index = te);
  }
  function g() {
    const H = c.newAttributes;
    for (let Q = 0, ie = H.length; Q < ie; Q++) H[Q] = 0;
  }
  function E(H) {
    w(H, 0);
  }
  function w(H, Q) {
    const ie = c.newAttributes,
      te = c.enabledAttributes,
      W = c.attributeDivisors;
    (ie[H] = 1),
      te[H] === 0 && (n.enableVertexAttribArray(H), (te[H] = 1)),
      W[H] !== Q &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](H, Q),
        (W[H] = Q));
  }
  function L() {
    const H = c.newAttributes,
      Q = c.enabledAttributes;
    for (let ie = 0, te = Q.length; ie < te; ie++)
      Q[ie] !== H[ie] && (n.disableVertexAttribArray(ie), (Q[ie] = 0));
  }
  function A(H, Q, ie, te, W, K, G) {
    G === !0
      ? n.vertexAttribIPointer(H, Q, ie, W, K)
      : n.vertexAttribPointer(H, Q, ie, te, W, K);
  }
  function U(H, Q, ie, te) {
    if (
      i.isWebGL2 === !1 &&
      (H.isInstancedMesh || te.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    g();
    const W = te.attributes,
      K = ie.getAttributes(),
      G = Q.defaultAttributeValues;
    for (const z in K) {
      const V = K[z];
      if (V.location >= 0) {
        let _e = W[z];
        if (
          (_e === void 0 &&
            (z === "instanceMatrix" &&
              H.instanceMatrix &&
              (_e = H.instanceMatrix),
            z === "instanceColor" && H.instanceColor && (_e = H.instanceColor)),
          _e !== void 0)
        ) {
          const ve = _e.normalized,
            we = _e.itemSize,
            ye = t.get(_e);
          if (ye === void 0) continue;
          const ke = ye.buffer,
            Ne = ye.type,
            We = ye.bytesPerElement,
            pt =
              i.isWebGL2 === !0 &&
              (Ne === n.INT || Ne === n.UNSIGNED_INT || _e.gpuType === tv);
          if (_e.isInterleavedBufferAttribute) {
            const Ye = _e.data,
              j = Ye.stride,
              kt = _e.offset;
            if (Ye.isInstancedInterleavedBuffer) {
              for (let De = 0; De < V.locationSize; De++)
                w(V.location + De, Ye.meshPerAttribute);
              H.isInstancedMesh !== !0 &&
                te._maxInstanceCount === void 0 &&
                (te._maxInstanceCount = Ye.meshPerAttribute * Ye.count);
            } else
              for (let De = 0; De < V.locationSize; De++) E(V.location + De);
            n.bindBuffer(n.ARRAY_BUFFER, ke);
            for (let De = 0; De < V.locationSize; De++)
              A(
                V.location + De,
                we / V.locationSize,
                Ne,
                ve,
                j * We,
                (kt + (we / V.locationSize) * De) * We,
                pt
              );
          } else {
            if (_e.isInstancedBufferAttribute) {
              for (let Ye = 0; Ye < V.locationSize; Ye++)
                w(V.location + Ye, _e.meshPerAttribute);
              H.isInstancedMesh !== !0 &&
                te._maxInstanceCount === void 0 &&
                (te._maxInstanceCount = _e.meshPerAttribute * _e.count);
            } else
              for (let Ye = 0; Ye < V.locationSize; Ye++) E(V.location + Ye);
            n.bindBuffer(n.ARRAY_BUFFER, ke);
            for (let Ye = 0; Ye < V.locationSize; Ye++)
              A(
                V.location + Ye,
                we / V.locationSize,
                Ne,
                ve,
                we * We,
                (we / V.locationSize) * Ye * We,
                pt
              );
          }
        } else if (G !== void 0) {
          const ve = G[z];
          if (ve !== void 0)
            switch (ve.length) {
              case 2:
                n.vertexAttrib2fv(V.location, ve);
                break;
              case 3:
                n.vertexAttrib3fv(V.location, ve);
                break;
              case 4:
                n.vertexAttrib4fv(V.location, ve);
                break;
              default:
                n.vertexAttrib1fv(V.location, ve);
            }
        }
      }
    }
    L();
  }
  function M() {
    J();
    for (const H in a) {
      const Q = a[H];
      for (const ie in Q) {
        const te = Q[ie];
        for (const W in te) v(te[W].object), delete te[W];
        delete Q[ie];
      }
      delete a[H];
    }
  }
  function b(H) {
    if (a[H.id] === void 0) return;
    const Q = a[H.id];
    for (const ie in Q) {
      const te = Q[ie];
      for (const W in te) v(te[W].object), delete te[W];
      delete Q[ie];
    }
    delete a[H.id];
  }
  function $(H) {
    for (const Q in a) {
      const ie = a[Q];
      if (ie[H.id] === void 0) continue;
      const te = ie[H.id];
      for (const W in te) v(te[W].object), delete te[W];
      delete ie[H.id];
    }
  }
  function J() {
    se(), (u = !0), c !== l && ((c = l), p(c.object));
  }
  function se() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: f,
    reset: J,
    resetDefaultState: se,
    dispose: M,
    releaseStatesOfGeometry: b,
    releaseStatesOfProgram: $,
    initAttributes: g,
    enableAttribute: E,
    disableUnusedAttributes: L,
  };
}
function j1(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(c) {
    s = c;
  }
  function a(c, u) {
    n.drawArrays(s, c, u), t.update(u, s, 1);
  }
  function l(c, u, f) {
    if (f === 0) return;
    let d, p;
    if (r) (d = n), (p = "drawArraysInstanced");
    else if (
      ((d = e.get("ANGLE_instanced_arrays")),
      (p = "drawArraysInstancedANGLE"),
      d === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    d[p](s, c, u, f), t.update(u, s, f);
  }
  (this.setMode = o), (this.render = a), (this.renderInstances = l);
}
function Y1(n, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const A = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(A.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(A) {
    if (A === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      A = "mediump";
    }
    return A === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      l,
      "instead."
    ),
    (a = l));
  const c = o || e.has("WEBGL_draw_buffers"),
    u = t.logarithmicDepthBuffer === !0,
    f = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    d = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    p = n.getParameter(n.MAX_TEXTURE_SIZE),
    v = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    m = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    h = n.getParameter(n.MAX_VARYING_VECTORS),
    _ = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    g = d > 0,
    E = o || e.has("OES_texture_float"),
    w = g && E,
    L = o ? n.getParameter(n.MAX_SAMPLES) : 0;
  return {
    isWebGL2: o,
    drawBuffers: c,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: u,
    maxTextures: f,
    maxVertexTextures: d,
    maxTextureSize: p,
    maxCubemapSize: v,
    maxAttributes: x,
    maxVertexUniforms: m,
    maxVaryings: h,
    maxFragmentUniforms: _,
    vertexTextures: g,
    floatFragmentTextures: E,
    floatVertexTextures: w,
    maxSamples: L,
  };
}
function q1(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new or(),
    a = new et(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (f, d) {
      const p = f.length !== 0 || d || i !== 0 || r;
      return (r = d), (i = f.length), p;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (f, d) {
      t = u(f, d, 0);
    }),
    (this.setState = function (f, d, p) {
      const v = f.clippingPlanes,
        x = f.clipIntersection,
        m = f.clipShadows,
        h = n.get(f);
      if (!r || v === null || v.length === 0 || (s && !m)) s ? u(null) : c();
      else {
        const _ = s ? 0 : i,
          g = _ * 4;
        let E = h.clippingState || null;
        (l.value = E), (E = u(v, d, g, p));
        for (let w = 0; w !== g; ++w) E[w] = t[w];
        (h.clippingState = E),
          (this.numIntersection = x ? this.numPlanes : 0),
          (this.numPlanes += _);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function u(f, d, p, v) {
    const x = f !== null ? f.length : 0;
    let m = null;
    if (x !== 0) {
      if (((m = l.value), v !== !0 || m === null)) {
        const h = p + x * 4,
          _ = d.matrixWorldInverse;
        a.getNormalMatrix(_),
          (m === null || m.length < h) && (m = new Float32Array(h));
        for (let g = 0, E = p; g !== x; ++g, E += 4)
          o.copy(f[g]).applyMatrix4(_, a),
            o.normal.toArray(m, E),
            (m[E + 3] = o.constant);
      }
      (l.value = m), (l.needsUpdate = !0);
    }
    return (e.numPlanes = x), (e.numIntersection = 0), m;
  }
}
function K1(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === mc ? (o.mapping = co) : a === Qf && (o.mapping = uo), o;
  }
  function i(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === mc || a === Qf)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new cM(l.height / 2);
            return (
              c.fromEquirectangularTexture(n, o),
              e.set(o, c),
              o.addEventListener("dispose", r),
              t(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class hh extends Sv {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= u * this.view.offsetY),
        (l = a - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const js = 4,
  Fm = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  jr = 20,
  Bu = new hh(),
  km = new Ke();
let zu = null,
  Hu = 0,
  Vu = 0;
const Wr = (1 + Math.sqrt(5)) / 2,
  Is = 1 / Wr,
  Bm = [
    new B(1, 1, 1),
    new B(-1, 1, 1),
    new B(1, 1, -1),
    new B(-1, 1, -1),
    new B(0, Wr, Is),
    new B(0, Wr, -Is),
    new B(Is, 0, Wr),
    new B(-Is, 0, Wr),
    new B(Wr, Is, 0),
    new B(-Wr, Is, 0),
  ];
class zm {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    (zu = this._renderer.getRenderTarget()),
      (Hu = this._renderer.getActiveCubeFace()),
      (Vu = this._renderer.getActiveMipmapLevel()),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Gm()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Vm()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(zu, Hu, Vu),
      (e.scissorTest = !1),
      Sl(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === co || e.mapping === uo
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (zu = this._renderer.getRenderTarget()),
      (Hu = this._renderer.getActiveCubeFace()),
      (Vu = this._renderer.getActiveMipmapLevel());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: zt,
        minFilter: zt,
        generateMipmaps: !1,
        type: ki,
        format: Pn,
        colorSpace: Vt,
        depthBuffer: !1,
      },
      r = Hm(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Hm(e, t, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = Z1(s)),
        (this._blurMaterial = $1(s, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Dn(this._lodPlanes[0], e);
    this._renderer.compile(t, Bu);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new pn(90, 1, t, i),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      f = u.autoClear,
      d = u.toneMapping;
    u.getClearColor(km), (u.toneMapping = Mr), (u.autoClear = !1);
    const p = new Zr({
        name: "PMREM.Background",
        side: An,
        depthWrite: !1,
        depthTest: !1,
      }),
      v = new Dn(new Na(), p);
    let x = !1;
    const m = e.background;
    m
      ? m.isColor && (p.color.copy(m), (e.background = null), (x = !0))
      : (p.color.copy(km), (x = !0));
    for (let h = 0; h < 6; h++) {
      const _ = h % 3;
      _ === 0
        ? (a.up.set(0, l[h], 0), a.lookAt(c[h], 0, 0))
        : _ === 1
        ? (a.up.set(0, 0, l[h]), a.lookAt(0, c[h], 0))
        : (a.up.set(0, l[h], 0), a.lookAt(0, 0, c[h]));
      const g = this._cubeSize;
      Sl(r, _ * g, h > 2 ? g : 0, g, g),
        u.setRenderTarget(r),
        x && u.render(v, a),
        u.render(e, a);
    }
    v.geometry.dispose(),
      v.material.dispose(),
      (u.toneMapping = d),
      (u.autoClear = f),
      (e.background = m);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === co || e.mapping === uo;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Gm()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Vm());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new Dn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Sl(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, Bu);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        o = Bm[(r - 1) % Bm.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      f = new Dn(this._lodPlanes[r], c),
      d = c.uniforms,
      p = this._sizeLods[i] - 1,
      v = isFinite(s) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * jr - 1),
      x = s / v,
      m = isFinite(s) ? 1 + Math.floor(u * x) : jr;
    m > jr &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${jr}`
      );
    const h = [];
    let _ = 0;
    for (let A = 0; A < jr; ++A) {
      const U = A / x,
        M = Math.exp((-U * U) / 2);
      h.push(M), A === 0 ? (_ += M) : A < m && (_ += 2 * M);
    }
    for (let A = 0; A < h.length; A++) h[A] = h[A] / _;
    (d.envMap.value = e.texture),
      (d.samples.value = m),
      (d.weights.value = h),
      (d.latitudinal.value = o === "latitudinal"),
      a && (d.poleAxis.value = a);
    const { _lodMax: g } = this;
    (d.dTheta.value = v), (d.mipInt.value = g - i);
    const E = this._sizeLods[r],
      w = 3 * E * (r > g - js ? r - g + js : 0),
      L = 4 * (this._cubeSize - E);
    Sl(t, w, L, 3 * E, 2 * E), l.setRenderTarget(t), l.render(f, Bu);
  }
}
function Z1(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - js + 1 + Fm.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    o > n - js ? (l = Fm[o - n + js - 1]) : o === 0 && (l = 0), i.push(l);
    const c = 1 / (a - 2),
      u = -c,
      f = 1 + c,
      d = [u, u, f, u, f, f, u, u, f, f, u, f],
      p = 6,
      v = 6,
      x = 3,
      m = 2,
      h = 1,
      _ = new Float32Array(x * v * p),
      g = new Float32Array(m * v * p),
      E = new Float32Array(h * v * p);
    for (let L = 0; L < p; L++) {
      const A = ((L % 3) * 2) / 3 - 1,
        U = L > 2 ? 0 : -1,
        M = [
          A,
          U,
          0,
          A + 2 / 3,
          U,
          0,
          A + 2 / 3,
          U + 1,
          0,
          A,
          U,
          0,
          A + 2 / 3,
          U + 1,
          0,
          A,
          U + 1,
          0,
        ];
      _.set(M, x * v * L), g.set(d, m * v * L);
      const b = [L, L, L, L, L, L];
      E.set(b, h * v * L);
    }
    const w = new fi();
    w.setAttribute("position", new gn(_, x)),
      w.setAttribute("uv", new gn(g, m)),
      w.setAttribute("faceIndex", new gn(E, h)),
      e.push(w),
      r > js && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function Hm(n, e, t) {
  const i = new ls(n, e, t);
  return (
    (i.texture.mapping = kc),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function Sl(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function $1(n, e, t) {
  const i = new Float32Array(jr),
    r = new B(0, 1, 0);
  return new Cr({
    name: "SphericalGaussianBlur",
    defines: {
      n: jr,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: ph(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Er,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Vm() {
  return new Cr({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: ph(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Er,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Gm() {
  return new Cr({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: ph(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Er,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ph() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Q1(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === mc || l === Qf,
        u = l === co || l === uo;
      if (c || u)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let f = e.get(a);
          return (
            t === null && (t = new zm(n)),
            (f = c ? t.fromEquirectangular(a, f) : t.fromCubemap(a, f)),
            e.set(a, f),
            f.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const f = a.image;
            if ((c && f && f.height > 0) || (u && f && r(f))) {
              t === null && (t = new zm(n));
              const d = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, d), a.addEventListener("dispose", s), d.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: o };
}
function J1(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      );
    },
  };
}
function ew(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(f) {
    const d = f.target;
    d.index !== null && e.remove(d.index);
    for (const v in d.attributes) e.remove(d.attributes[v]);
    for (const v in d.morphAttributes) {
      const x = d.morphAttributes[v];
      for (let m = 0, h = x.length; m < h; m++) e.remove(x[m]);
    }
    d.removeEventListener("dispose", o), delete r[d.id];
    const p = s.get(d);
    p && (e.remove(p), s.delete(d)),
      i.releaseStatesOfGeometry(d),
      d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(f, d) {
    return (
      r[d.id] === !0 ||
        (d.addEventListener("dispose", o),
        (r[d.id] = !0),
        t.memory.geometries++),
      d
    );
  }
  function l(f) {
    const d = f.attributes;
    for (const v in d) e.update(d[v], n.ARRAY_BUFFER);
    const p = f.morphAttributes;
    for (const v in p) {
      const x = p[v];
      for (let m = 0, h = x.length; m < h; m++) e.update(x[m], n.ARRAY_BUFFER);
    }
  }
  function c(f) {
    const d = [],
      p = f.index,
      v = f.attributes.position;
    let x = 0;
    if (p !== null) {
      const _ = p.array;
      x = p.version;
      for (let g = 0, E = _.length; g < E; g += 3) {
        const w = _[g + 0],
          L = _[g + 1],
          A = _[g + 2];
        d.push(w, L, L, A, A, w);
      }
    } else if (v !== void 0) {
      const _ = v.array;
      x = v.version;
      for (let g = 0, E = _.length / 3 - 1; g < E; g += 3) {
        const w = g + 0,
          L = g + 1,
          A = g + 2;
        d.push(w, L, L, A, A, w);
      }
    } else return;
    const m = new (dv(d) ? yv : vv)(d, 1);
    m.version = x;
    const h = s.get(f);
    h && e.remove(h), s.set(f, m);
  }
  function u(f) {
    const d = s.get(f);
    if (d) {
      const p = f.index;
      p !== null && d.version < p.version && c(f);
    } else c(f);
    return s.get(f);
  }
  return { get: a, update: l, getWireframeAttribute: u };
}
function tw(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(d) {
    s = d;
  }
  let a, l;
  function c(d) {
    (a = d.type), (l = d.bytesPerElement);
  }
  function u(d, p) {
    n.drawElements(s, p, a, d * l), t.update(p, s, 1);
  }
  function f(d, p, v) {
    if (v === 0) return;
    let x, m;
    if (r) (x = n), (m = "drawElementsInstanced");
    else if (
      ((x = e.get("ANGLE_instanced_arrays")),
      (m = "drawElementsInstancedANGLE"),
      x === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    x[m](s, p, a, d * l, v), t.update(p, s, v);
  }
  (this.setMode = o),
    (this.setIndex = c),
    (this.render = u),
    (this.renderInstances = f);
}
function nw(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function iw(n, e) {
  return n[0] - e[0];
}
function rw(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function sw(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    o = new gt(),
    a = [];
  for (let c = 0; c < 8; c++) a[c] = [c, 0];
  function l(c, u, f) {
    const d = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const v =
          u.morphAttributes.position ||
          u.morphAttributes.normal ||
          u.morphAttributes.color,
        x = v !== void 0 ? v.length : 0;
      let m = s.get(u);
      if (m === void 0 || m.count !== x) {
        let Q = function () {
          se.dispose(), s.delete(u), u.removeEventListener("dispose", Q);
        };
        var p = Q;
        m !== void 0 && m.texture.dispose();
        const g = u.morphAttributes.position !== void 0,
          E = u.morphAttributes.normal !== void 0,
          w = u.morphAttributes.color !== void 0,
          L = u.morphAttributes.position || [],
          A = u.morphAttributes.normal || [],
          U = u.morphAttributes.color || [];
        let M = 0;
        g === !0 && (M = 1), E === !0 && (M = 2), w === !0 && (M = 3);
        let b = u.attributes.position.count * M,
          $ = 1;
        b > e.maxTextureSize &&
          (($ = Math.ceil(b / e.maxTextureSize)), (b = e.maxTextureSize));
        const J = new Float32Array(b * $ * 4 * x),
          se = new mv(J, b, $, x);
        (se.type = jn), (se.needsUpdate = !0);
        const H = M * 4;
        for (let ie = 0; ie < x; ie++) {
          const te = L[ie],
            W = A[ie],
            K = U[ie],
            G = b * $ * 4 * ie;
          for (let z = 0; z < te.count; z++) {
            const V = z * H;
            g === !0 &&
              (o.fromBufferAttribute(te, z),
              (J[G + V + 0] = o.x),
              (J[G + V + 1] = o.y),
              (J[G + V + 2] = o.z),
              (J[G + V + 3] = 0)),
              E === !0 &&
                (o.fromBufferAttribute(W, z),
                (J[G + V + 4] = o.x),
                (J[G + V + 5] = o.y),
                (J[G + V + 6] = o.z),
                (J[G + V + 7] = 0)),
              w === !0 &&
                (o.fromBufferAttribute(K, z),
                (J[G + V + 8] = o.x),
                (J[G + V + 9] = o.y),
                (J[G + V + 10] = o.z),
                (J[G + V + 11] = K.itemSize === 4 ? o.w : 1));
          }
        }
        (m = { count: x, texture: se, size: new Ge(b, $) }),
          s.set(u, m),
          u.addEventListener("dispose", Q);
      }
      let h = 0;
      for (let g = 0; g < d.length; g++) h += d[g];
      const _ = u.morphTargetsRelative ? 1 : 1 - h;
      f.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
        f.getUniforms().setValue(n, "morphTargetInfluences", d),
        f.getUniforms().setValue(n, "morphTargetsTexture", m.texture, t),
        f.getUniforms().setValue(n, "morphTargetsTextureSize", m.size);
    } else {
      const v = d === void 0 ? 0 : d.length;
      let x = i[u.id];
      if (x === void 0 || x.length !== v) {
        x = [];
        for (let E = 0; E < v; E++) x[E] = [E, 0];
        i[u.id] = x;
      }
      for (let E = 0; E < v; E++) {
        const w = x[E];
        (w[0] = E), (w[1] = d[E]);
      }
      x.sort(rw);
      for (let E = 0; E < 8; E++)
        E < v && x[E][1]
          ? ((a[E][0] = x[E][0]), (a[E][1] = x[E][1]))
          : ((a[E][0] = Number.MAX_SAFE_INTEGER), (a[E][1] = 0));
      a.sort(iw);
      const m = u.morphAttributes.position,
        h = u.morphAttributes.normal;
      let _ = 0;
      for (let E = 0; E < 8; E++) {
        const w = a[E],
          L = w[0],
          A = w[1];
        L !== Number.MAX_SAFE_INTEGER && A
          ? (m &&
              u.getAttribute("morphTarget" + E) !== m[L] &&
              u.setAttribute("morphTarget" + E, m[L]),
            h &&
              u.getAttribute("morphNormal" + E) !== h[L] &&
              u.setAttribute("morphNormal" + E, h[L]),
            (r[E] = A),
            (_ += A))
          : (m &&
              u.hasAttribute("morphTarget" + E) === !0 &&
              u.deleteAttribute("morphTarget" + E),
            h &&
              u.hasAttribute("morphNormal" + E) === !0 &&
              u.deleteAttribute("morphNormal" + E),
            (r[E] = 0));
      }
      const g = u.morphTargetsRelative ? 1 : 1 - _;
      f.getUniforms().setValue(n, "morphTargetBaseInfluence", g),
        f.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return { update: l };
}
function ow(n, e, t, i) {
  let r = new WeakMap();
  function s(l) {
    const c = i.render.frame,
      u = l.geometry,
      f = e.get(l, u);
    if (
      (r.get(f) !== c && (e.update(f), r.set(f, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        r.get(l) !== c &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const d = l.skeleton;
      r.get(d) !== c && (d.update(), r.set(d, c));
    }
    return f;
  }
  function o() {
    r = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: s, dispose: o };
}
const Tv = new tn(),
  wv = new mv(),
  Av = new GE(),
  Rv = new Ev(),
  Wm = [],
  Xm = [],
  jm = new Float32Array(16),
  Ym = new Float32Array(9),
  qm = new Float32Array(4);
function Mo(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = Wm[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (Wm[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function Gt(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Wt(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function Hc(n, e) {
  let t = Xm[e];
  t === void 0 && ((t = new Int32Array(e)), (Xm[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function aw(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function lw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Gt(t, e)) return;
    n.uniform2fv(this.addr, e), Wt(t, e);
  }
}
function cw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Gt(t, e)) return;
    n.uniform3fv(this.addr, e), Wt(t, e);
  }
}
function uw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Gt(t, e)) return;
    n.uniform4fv(this.addr, e), Wt(t, e);
  }
}
function fw(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Gt(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), Wt(t, e);
  } else {
    if (Gt(t, i)) return;
    qm.set(i), n.uniformMatrix2fv(this.addr, !1, qm), Wt(t, i);
  }
}
function dw(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Gt(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), Wt(t, e);
  } else {
    if (Gt(t, i)) return;
    Ym.set(i), n.uniformMatrix3fv(this.addr, !1, Ym), Wt(t, i);
  }
}
function hw(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Gt(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), Wt(t, e);
  } else {
    if (Gt(t, i)) return;
    jm.set(i), n.uniformMatrix4fv(this.addr, !1, jm), Wt(t, i);
  }
}
function pw(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function mw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Gt(t, e)) return;
    n.uniform2iv(this.addr, e), Wt(t, e);
  }
}
function gw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Gt(t, e)) return;
    n.uniform3iv(this.addr, e), Wt(t, e);
  }
}
function _w(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Gt(t, e)) return;
    n.uniform4iv(this.addr, e), Wt(t, e);
  }
}
function vw(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function yw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Gt(t, e)) return;
    n.uniform2uiv(this.addr, e), Wt(t, e);
  }
}
function xw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Gt(t, e)) return;
    n.uniform3uiv(this.addr, e), Wt(t, e);
  }
}
function Sw(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Gt(t, e)) return;
    n.uniform4uiv(this.addr, e), Wt(t, e);
  }
}
function Ew(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2D(e || Tv, r);
}
function Mw(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || Av, r);
}
function Tw(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || Rv, r);
}
function ww(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || wv, r);
}
function Aw(n) {
  switch (n) {
    case 5126:
      return aw;
    case 35664:
      return lw;
    case 35665:
      return cw;
    case 35666:
      return uw;
    case 35674:
      return fw;
    case 35675:
      return dw;
    case 35676:
      return hw;
    case 5124:
    case 35670:
      return pw;
    case 35667:
    case 35671:
      return mw;
    case 35668:
    case 35672:
      return gw;
    case 35669:
    case 35673:
      return _w;
    case 5125:
      return vw;
    case 36294:
      return yw;
    case 36295:
      return xw;
    case 36296:
      return Sw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Ew;
    case 35679:
    case 36299:
    case 36307:
      return Mw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Tw;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return ww;
  }
}
function Rw(n, e) {
  n.uniform1fv(this.addr, e);
}
function bw(n, e) {
  const t = Mo(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Cw(n, e) {
  const t = Mo(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Lw(n, e) {
  const t = Mo(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function Pw(n, e) {
  const t = Mo(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function Iw(n, e) {
  const t = Mo(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function Nw(n, e) {
  const t = Mo(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function Dw(n, e) {
  n.uniform1iv(this.addr, e);
}
function Uw(n, e) {
  n.uniform2iv(this.addr, e);
}
function Ow(n, e) {
  n.uniform3iv(this.addr, e);
}
function Fw(n, e) {
  n.uniform4iv(this.addr, e);
}
function kw(n, e) {
  n.uniform1uiv(this.addr, e);
}
function Bw(n, e) {
  n.uniform2uiv(this.addr, e);
}
function zw(n, e) {
  n.uniform3uiv(this.addr, e);
}
function Hw(n, e) {
  n.uniform4uiv(this.addr, e);
}
function Vw(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hc(t, r);
  Gt(i, s) || (n.uniform1iv(this.addr, s), Wt(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || Tv, s[o]);
}
function Gw(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hc(t, r);
  Gt(i, s) || (n.uniform1iv(this.addr, s), Wt(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || Av, s[o]);
}
function Ww(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hc(t, r);
  Gt(i, s) || (n.uniform1iv(this.addr, s), Wt(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || Rv, s[o]);
}
function Xw(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Hc(t, r);
  Gt(i, s) || (n.uniform1iv(this.addr, s), Wt(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || wv, s[o]);
}
function jw(n) {
  switch (n) {
    case 5126:
      return Rw;
    case 35664:
      return bw;
    case 35665:
      return Cw;
    case 35666:
      return Lw;
    case 35674:
      return Pw;
    case 35675:
      return Iw;
    case 35676:
      return Nw;
    case 5124:
    case 35670:
      return Dw;
    case 35667:
    case 35671:
      return Uw;
    case 35668:
    case 35672:
      return Ow;
    case 35669:
    case 35673:
      return Fw;
    case 5125:
      return kw;
    case 36294:
      return Bw;
    case 36295:
      return zw;
    case 36296:
      return Hw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Vw;
    case 35679:
    case 36299:
    case 36307:
      return Gw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Ww;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Xw;
  }
}
class Yw {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = Aw(t.type));
  }
}
class qw {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = jw(t.type));
  }
}
class Kw {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const Gu = /(\w+)(\])?(\[|\.)?/g;
function Km(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function Zw(n, e, t) {
  const i = n.name,
    r = i.length;
  for (Gu.lastIndex = 0; ; ) {
    const s = Gu.exec(i),
      o = Gu.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === r))) {
      Km(t, c === void 0 ? new Yw(a, n, e) : new qw(a, n, e));
      break;
    } else {
      let f = t.map[a];
      f === void 0 && ((f = new Kw(a)), Km(t, f)), (t = f);
    }
  }
}
class Gl {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      Zw(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function Zm(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
const $w = 37297;
let Qw = 0;
function Jw(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function eA(n) {
  const e = lt.getPrimaries(lt.workingColorSpace),
    t = lt.getPrimaries(n);
  let i;
  switch (
    (e === t
      ? (i = "")
      : e === yc && t === vc
      ? (i = "LinearDisplayP3ToLinearSRGB")
      : e === vc && t === yc && (i = "LinearSRGBToLinearDisplayP3"),
    n)
  ) {
    case Vt:
    case Bc:
      return [i, "LinearTransferOETF"];
    case Rt:
    case lh:
      return [i, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", n),
        [i, "LinearTransferOETF"]
      );
  }
}
function $m(n, e, t) {
  const i = n.getShaderParameter(e, n.COMPILE_STATUS),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      Jw(n.getShaderSource(e), o)
    );
  } else return r;
}
function tA(n, e) {
  const t = eA(e);
  return `vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function nA(n, e) {
  let t;
  switch (e) {
    case JS:
      t = "Linear";
      break;
    case Q0:
      t = "Reinhard";
      break;
    case eE:
      t = "OptimizedCineon";
      break;
    case tE:
      t = "ACESFilmic";
      break;
    case nE:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function iA(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(qo).join(`
`);
}
function rA(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function sA(n, e) {
  const t = {},
    i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function qo(n) {
  return n !== "";
}
function Qm(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Jm(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const oA = /^[ \t]*#include +<([\w\d./]+)>/gm;
function rd(n) {
  return n.replace(oA, lA);
}
const aA = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function lA(n, e) {
  let t = Qe[e];
  if (t === void 0) {
    const i = aA.get(e);
    if (i !== void 0)
      (t = Qe[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return rd(t);
}
const cA =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function eg(n) {
  return n.replace(cA, uA);
}
function uA(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function tg(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function fA(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === K0
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === Z0
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Ii && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function dA(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case co:
      case uo:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case kc:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function hA(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case uo:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function pA(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case $0:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case $S:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case QS:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function mA(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function gA(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = fA(t),
    c = dA(t),
    u = hA(t),
    f = pA(t),
    d = mA(t),
    p = t.isWebGL2 ? "" : iA(t),
    v = rA(s),
    x = r.createProgram();
  let m,
    h,
    _ = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((m = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
      ].filter(qo).join(`
`)),
      m.length > 0 &&
        (m += `
`),
      (h = [
        p,
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
      ].filter(qo).join(`
`)),
      h.length > 0 &&
        (h += `
`))
    : ((m = [
        tg(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(qo).join(`
`)),
      (h = [
        p,
        tg(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + f : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Mr ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Mr ? Qe.tonemapping_pars_fragment : "",
        t.toneMapping !== Mr ? nA("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Qe.colorspace_pars_fragment,
        tA("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(qo).join(`
`))),
    (o = rd(o)),
    (o = Qm(o, t)),
    (o = Jm(o, t)),
    (a = rd(a)),
    (a = Qm(a, t)),
    (a = Jm(a, t)),
    (o = eg(o)),
    (a = eg(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((_ = `#version 300 es
`),
      (m =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        m),
      (h =
        [
          "precision mediump sampler2DArray;",
          "#define varying in",
          t.glslVersion === vm
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === vm ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        h));
  const g = _ + m + o,
    E = _ + h + a,
    w = Zm(r, r.VERTEX_SHADER, g),
    L = Zm(r, r.FRAGMENT_SHADER, E);
  r.attachShader(x, w),
    r.attachShader(x, L),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(x, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(x, 0, "position"),
    r.linkProgram(x);
  function A($) {
    if (n.debug.checkShaderErrors) {
      const J = r.getProgramInfoLog(x).trim(),
        se = r.getShaderInfoLog(w).trim(),
        H = r.getShaderInfoLog(L).trim();
      let Q = !0,
        ie = !0;
      if (r.getProgramParameter(x, r.LINK_STATUS) === !1)
        if (((Q = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(r, x, w, L);
        else {
          const te = $m(r, w, "vertex"),
            W = $m(r, L, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(x, r.VALIDATE_STATUS) +
              `

Program Info Log: ` +
              J +
              `
` +
              te +
              `
` +
              W
          );
        }
      else
        J !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", J)
          : (se === "" || H === "") && (ie = !1);
      ie &&
        ($.diagnostics = {
          runnable: Q,
          programLog: J,
          vertexShader: { log: se, prefix: m },
          fragmentShader: { log: H, prefix: h },
        });
    }
    r.deleteShader(w), r.deleteShader(L), (U = new Gl(r, x)), (M = sA(r, x));
  }
  let U;
  this.getUniforms = function () {
    return U === void 0 && A(this), U;
  };
  let M;
  this.getAttributes = function () {
    return M === void 0 && A(this), M;
  };
  let b = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return b === !1 && (b = r.getProgramParameter(x, $w)), b;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(x),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = Qw++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = x),
    (this.vertexShader = w),
    (this.fragmentShader = L),
    this
  );
}
let _A = 0;
class vA {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new yA(e)), t.set(e, i)), i;
  }
}
class yA {
  constructor(e) {
    (this.id = _A++), (this.code = e), (this.usedTimes = 0);
  }
}
function xA(n, e, t, i, r, s, o) {
  const a = new gv(),
    l = new vA(),
    c = [],
    u = r.isWebGL2,
    f = r.logarithmicDepthBuffer,
    d = r.vertexTextures;
  let p = r.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function x(M) {
    return M === 0 ? "uv" : `uv${M}`;
  }
  function m(M, b, $, J, se) {
    const H = J.fog,
      Q = se.geometry,
      ie = M.isMeshStandardMaterial ? J.environment : null,
      te = (M.isMeshStandardMaterial ? t : e).get(M.envMap || ie),
      W = te && te.mapping === kc ? te.image.height : null,
      K = v[M.type];
    M.precision !== null &&
      ((p = r.getMaxPrecision(M.precision)),
      p !== M.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          M.precision,
          "not supported, using",
          p,
          "instead."
        ));
    const G =
        Q.morphAttributes.position ||
        Q.morphAttributes.normal ||
        Q.morphAttributes.color,
      z = G !== void 0 ? G.length : 0;
    let V = 0;
    Q.morphAttributes.position !== void 0 && (V = 1),
      Q.morphAttributes.normal !== void 0 && (V = 2),
      Q.morphAttributes.color !== void 0 && (V = 3);
    let _e, ve, we, ye;
    if (K) {
      const It = mi[K];
      (_e = It.vertexShader), (ve = It.fragmentShader);
    } else
      (_e = M.vertexShader),
        (ve = M.fragmentShader),
        l.update(M),
        (we = l.getVertexShaderID(M)),
        (ye = l.getFragmentShaderID(M));
    const ke = n.getRenderTarget(),
      Ne = se.isInstancedMesh === !0,
      We = !!M.map,
      pt = !!M.matcap,
      Ye = !!te,
      j = !!M.aoMap,
      kt = !!M.lightMap,
      De = !!M.bumpMap,
      He = !!M.normalMap,
      Ve = !!M.displacementMap,
      _t = !!M.emissiveMap,
      qe = !!M.metalnessMap,
      Xe = !!M.roughnessMap,
      it = M.anisotropy > 0,
      Pt = M.clearcoat > 0,
      Ut = M.iridescence > 0,
      I = M.sheen > 0,
      T = M.transmission > 0,
      q = it && !!M.anisotropyMap,
      pe = Pt && !!M.clearcoatMap,
      le = Pt && !!M.clearcoatNormalMap,
      he = Pt && !!M.clearcoatRoughnessMap,
      Ie = Ut && !!M.iridescenceMap,
      ge = Ut && !!M.iridescenceThicknessMap,
      Ae = I && !!M.sheenColorMap,
      F = I && !!M.sheenRoughnessMap,
      fe = !!M.specularMap,
      ne = !!M.specularColorMap,
      Be = !!M.specularIntensityMap,
      Pe = T && !!M.transmissionMap,
      Le = T && !!M.thicknessMap,
      Te = !!M.gradientMap,
      Re = !!M.alphaMap,
      oe = M.alphaTest > 0,
      k = !!M.alphaHash,
      xe = !!M.extensions,
      ce = !!Q.attributes.uv1,
      ee = !!Q.attributes.uv2,
      me = !!Q.attributes.uv3;
    let Ue = Mr;
    return (
      M.toneMapped &&
        (ke === null || ke.isXRRenderTarget === !0) &&
        (Ue = n.toneMapping),
      {
        isWebGL2: u,
        shaderID: K,
        shaderType: M.type,
        shaderName: M.name,
        vertexShader: _e,
        fragmentShader: ve,
        defines: M.defines,
        customVertexShaderID: we,
        customFragmentShaderID: ye,
        isRawShaderMaterial: M.isRawShaderMaterial === !0,
        glslVersion: M.glslVersion,
        precision: p,
        instancing: Ne,
        instancingColor: Ne && se.instanceColor !== null,
        supportsVertexTextures: d,
        outputColorSpace:
          ke === null
            ? n.outputColorSpace
            : ke.isXRRenderTarget === !0
            ? ke.texture.colorSpace
            : Vt,
        map: We,
        matcap: pt,
        envMap: Ye,
        envMapMode: Ye && te.mapping,
        envMapCubeUVHeight: W,
        aoMap: j,
        lightMap: kt,
        bumpMap: De,
        normalMap: He,
        displacementMap: d && Ve,
        emissiveMap: _t,
        normalMapObjectSpace: He && M.normalMapType === gE,
        normalMapTangentSpace: He && M.normalMapType === uv,
        metalnessMap: qe,
        roughnessMap: Xe,
        anisotropy: it,
        anisotropyMap: q,
        clearcoat: Pt,
        clearcoatMap: pe,
        clearcoatNormalMap: le,
        clearcoatRoughnessMap: he,
        iridescence: Ut,
        iridescenceMap: Ie,
        iridescenceThicknessMap: ge,
        sheen: I,
        sheenColorMap: Ae,
        sheenRoughnessMap: F,
        specularMap: fe,
        specularColorMap: ne,
        specularIntensityMap: Be,
        transmission: T,
        transmissionMap: Pe,
        thicknessMap: Le,
        gradientMap: Te,
        opaque: M.transparent === !1 && M.blending === Js,
        alphaMap: Re,
        alphaTest: oe,
        alphaHash: k,
        combine: M.combine,
        mapUv: We && x(M.map.channel),
        aoMapUv: j && x(M.aoMap.channel),
        lightMapUv: kt && x(M.lightMap.channel),
        bumpMapUv: De && x(M.bumpMap.channel),
        normalMapUv: He && x(M.normalMap.channel),
        displacementMapUv: Ve && x(M.displacementMap.channel),
        emissiveMapUv: _t && x(M.emissiveMap.channel),
        metalnessMapUv: qe && x(M.metalnessMap.channel),
        roughnessMapUv: Xe && x(M.roughnessMap.channel),
        anisotropyMapUv: q && x(M.anisotropyMap.channel),
        clearcoatMapUv: pe && x(M.clearcoatMap.channel),
        clearcoatNormalMapUv: le && x(M.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: he && x(M.clearcoatRoughnessMap.channel),
        iridescenceMapUv: Ie && x(M.iridescenceMap.channel),
        iridescenceThicknessMapUv: ge && x(M.iridescenceThicknessMap.channel),
        sheenColorMapUv: Ae && x(M.sheenColorMap.channel),
        sheenRoughnessMapUv: F && x(M.sheenRoughnessMap.channel),
        specularMapUv: fe && x(M.specularMap.channel),
        specularColorMapUv: ne && x(M.specularColorMap.channel),
        specularIntensityMapUv: Be && x(M.specularIntensityMap.channel),
        transmissionMapUv: Pe && x(M.transmissionMap.channel),
        thicknessMapUv: Le && x(M.thicknessMap.channel),
        alphaMapUv: Re && x(M.alphaMap.channel),
        vertexTangents: !!Q.attributes.tangent && (He || it),
        vertexColors: M.vertexColors,
        vertexAlphas:
          M.vertexColors === !0 &&
          !!Q.attributes.color &&
          Q.attributes.color.itemSize === 4,
        vertexUv1s: ce,
        vertexUv2s: ee,
        vertexUv3s: me,
        pointsUvs: se.isPoints === !0 && !!Q.attributes.uv && (We || Re),
        fog: !!H,
        useFog: M.fog === !0,
        fogExp2: H && H.isFogExp2,
        flatShading: M.flatShading === !0,
        sizeAttenuation: M.sizeAttenuation === !0,
        logarithmicDepthBuffer: f,
        skinning: se.isSkinnedMesh === !0,
        morphTargets: Q.morphAttributes.position !== void 0,
        morphNormals: Q.morphAttributes.normal !== void 0,
        morphColors: Q.morphAttributes.color !== void 0,
        morphTargetsCount: z,
        morphTextureStride: V,
        numDirLights: b.directional.length,
        numPointLights: b.point.length,
        numSpotLights: b.spot.length,
        numSpotLightMaps: b.spotLightMap.length,
        numRectAreaLights: b.rectArea.length,
        numHemiLights: b.hemi.length,
        numDirLightShadows: b.directionalShadowMap.length,
        numPointLightShadows: b.pointShadowMap.length,
        numSpotLightShadows: b.spotShadowMap.length,
        numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
        numLightProbes: b.numLightProbes,
        numClippingPlanes: o.numPlanes,
        numClipIntersection: o.numIntersection,
        dithering: M.dithering,
        shadowMapEnabled: n.shadowMap.enabled && $.length > 0,
        shadowMapType: n.shadowMap.type,
        toneMapping: Ue,
        useLegacyLights: n._useLegacyLights,
        decodeVideoTexture:
          We &&
          M.map.isVideoTexture === !0 &&
          lt.getTransfer(M.map.colorSpace) === xt,
        premultipliedAlpha: M.premultipliedAlpha,
        doubleSided: M.side === oi,
        flipSided: M.side === An,
        useDepthPacking: M.depthPacking >= 0,
        depthPacking: M.depthPacking || 0,
        index0AttributeName: M.index0AttributeName,
        extensionDerivatives: xe && M.extensions.derivatives === !0,
        extensionFragDepth: xe && M.extensions.fragDepth === !0,
        extensionDrawBuffers: xe && M.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: xe && M.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: u || i.has("EXT_shader_texture_lod"),
        rendererExtensionParallelShaderCompile: i.has(
          "KHR_parallel_shader_compile"
        ),
        customProgramCacheKey: M.customProgramCacheKey(),
      }
    );
  }
  function h(M) {
    const b = [];
    if (
      (M.shaderID
        ? b.push(M.shaderID)
        : (b.push(M.customVertexShaderID), b.push(M.customFragmentShaderID)),
      M.defines !== void 0)
    )
      for (const $ in M.defines) b.push($), b.push(M.defines[$]);
    return (
      M.isRawShaderMaterial === !1 &&
        (_(b, M), g(b, M), b.push(n.outputColorSpace)),
      b.push(M.customProgramCacheKey),
      b.join()
    );
  }
  function _(M, b) {
    M.push(b.precision),
      M.push(b.outputColorSpace),
      M.push(b.envMapMode),
      M.push(b.envMapCubeUVHeight),
      M.push(b.mapUv),
      M.push(b.alphaMapUv),
      M.push(b.lightMapUv),
      M.push(b.aoMapUv),
      M.push(b.bumpMapUv),
      M.push(b.normalMapUv),
      M.push(b.displacementMapUv),
      M.push(b.emissiveMapUv),
      M.push(b.metalnessMapUv),
      M.push(b.roughnessMapUv),
      M.push(b.anisotropyMapUv),
      M.push(b.clearcoatMapUv),
      M.push(b.clearcoatNormalMapUv),
      M.push(b.clearcoatRoughnessMapUv),
      M.push(b.iridescenceMapUv),
      M.push(b.iridescenceThicknessMapUv),
      M.push(b.sheenColorMapUv),
      M.push(b.sheenRoughnessMapUv),
      M.push(b.specularMapUv),
      M.push(b.specularColorMapUv),
      M.push(b.specularIntensityMapUv),
      M.push(b.transmissionMapUv),
      M.push(b.thicknessMapUv),
      M.push(b.combine),
      M.push(b.fogExp2),
      M.push(b.sizeAttenuation),
      M.push(b.morphTargetsCount),
      M.push(b.morphAttributeCount),
      M.push(b.numDirLights),
      M.push(b.numPointLights),
      M.push(b.numSpotLights),
      M.push(b.numSpotLightMaps),
      M.push(b.numHemiLights),
      M.push(b.numRectAreaLights),
      M.push(b.numDirLightShadows),
      M.push(b.numPointLightShadows),
      M.push(b.numSpotLightShadows),
      M.push(b.numSpotLightShadowsWithMaps),
      M.push(b.numLightProbes),
      M.push(b.shadowMapType),
      M.push(b.toneMapping),
      M.push(b.numClippingPlanes),
      M.push(b.numClipIntersection),
      M.push(b.depthPacking);
  }
  function g(M, b) {
    a.disableAll(),
      b.isWebGL2 && a.enable(0),
      b.supportsVertexTextures && a.enable(1),
      b.instancing && a.enable(2),
      b.instancingColor && a.enable(3),
      b.matcap && a.enable(4),
      b.envMap && a.enable(5),
      b.normalMapObjectSpace && a.enable(6),
      b.normalMapTangentSpace && a.enable(7),
      b.clearcoat && a.enable(8),
      b.iridescence && a.enable(9),
      b.alphaTest && a.enable(10),
      b.vertexColors && a.enable(11),
      b.vertexAlphas && a.enable(12),
      b.vertexUv1s && a.enable(13),
      b.vertexUv2s && a.enable(14),
      b.vertexUv3s && a.enable(15),
      b.vertexTangents && a.enable(16),
      b.anisotropy && a.enable(17),
      b.alphaHash && a.enable(18),
      M.push(a.mask),
      a.disableAll(),
      b.fog && a.enable(0),
      b.useFog && a.enable(1),
      b.flatShading && a.enable(2),
      b.logarithmicDepthBuffer && a.enable(3),
      b.skinning && a.enable(4),
      b.morphTargets && a.enable(5),
      b.morphNormals && a.enable(6),
      b.morphColors && a.enable(7),
      b.premultipliedAlpha && a.enable(8),
      b.shadowMapEnabled && a.enable(9),
      b.useLegacyLights && a.enable(10),
      b.doubleSided && a.enable(11),
      b.flipSided && a.enable(12),
      b.useDepthPacking && a.enable(13),
      b.dithering && a.enable(14),
      b.transmission && a.enable(15),
      b.sheen && a.enable(16),
      b.opaque && a.enable(17),
      b.pointsUvs && a.enable(18),
      b.decodeVideoTexture && a.enable(19),
      M.push(a.mask);
  }
  function E(M) {
    const b = v[M.type];
    let $;
    if (b) {
      const J = mi[b];
      $ = sM.clone(J.uniforms);
    } else $ = M.uniforms;
    return $;
  }
  function w(M, b) {
    let $;
    for (let J = 0, se = c.length; J < se; J++) {
      const H = c[J];
      if (H.cacheKey === b) {
        ($ = H), ++$.usedTimes;
        break;
      }
    }
    return $ === void 0 && (($ = new gA(n, b, M, s)), c.push($)), $;
  }
  function L(M) {
    if (--M.usedTimes === 0) {
      const b = c.indexOf(M);
      (c[b] = c[c.length - 1]), c.pop(), M.destroy();
    }
  }
  function A(M) {
    l.remove(M);
  }
  function U() {
    l.dispose();
  }
  return {
    getParameters: m,
    getProgramCacheKey: h,
    getUniforms: E,
    acquireProgram: w,
    releaseProgram: L,
    releaseShaderCache: A,
    programs: c,
    dispose: U,
  };
}
function SA() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && ((o = {}), n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, a) {
    n.get(s)[o] = a;
  }
  function r() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function EA(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function ng(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function ig() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
  }
  function o(f, d, p, v, x, m) {
    let h = n[e];
    return (
      h === void 0
        ? ((h = {
            id: f.id,
            object: f,
            geometry: d,
            material: p,
            groupOrder: v,
            renderOrder: f.renderOrder,
            z: x,
            group: m,
          }),
          (n[e] = h))
        : ((h.id = f.id),
          (h.object = f),
          (h.geometry = d),
          (h.material = p),
          (h.groupOrder = v),
          (h.renderOrder = f.renderOrder),
          (h.z = x),
          (h.group = m)),
      e++,
      h
    );
  }
  function a(f, d, p, v, x, m) {
    const h = o(f, d, p, v, x, m);
    p.transmission > 0
      ? i.push(h)
      : p.transparent === !0
      ? r.push(h)
      : t.push(h);
  }
  function l(f, d, p, v, x, m) {
    const h = o(f, d, p, v, x, m);
    p.transmission > 0
      ? i.unshift(h)
      : p.transparent === !0
      ? r.unshift(h)
      : t.unshift(h);
  }
  function c(f, d) {
    t.length > 1 && t.sort(f || EA),
      i.length > 1 && i.sort(d || ng),
      r.length > 1 && r.sort(d || ng);
  }
  function u() {
    for (let f = e, d = n.length; f < d; f++) {
      const p = n[f];
      if (p.id === null) break;
      (p.id = null),
        (p.object = null),
        (p.geometry = null),
        (p.material = null),
        (p.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function MA() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new ig()), n.set(i, [o]))
        : r >= s.length
        ? ((o = new ig()), s.push(o))
        : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function TA() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new B(), color: new Ke() };
          break;
        case "SpotLight":
          t = {
            position: new B(),
            direction: new B(),
            color: new Ke(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new B(), color: new Ke(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new B(), skyColor: new Ke(), groundColor: new Ke() };
          break;
        case "RectAreaLight":
          t = {
            color: new Ke(),
            position: new B(),
            halfWidth: new B(),
            halfHeight: new B(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function wA() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Ge(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let AA = 0;
function RA(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function bA(n, e) {
  const t = new TA(),
    i = wA(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let u = 0; u < 9; u++) r.probe.push(new B());
  const s = new B(),
    o = new tt(),
    a = new tt();
  function l(u, f) {
    let d = 0,
      p = 0,
      v = 0;
    for (let J = 0; J < 9; J++) r.probe[J].set(0, 0, 0);
    let x = 0,
      m = 0,
      h = 0,
      _ = 0,
      g = 0,
      E = 0,
      w = 0,
      L = 0,
      A = 0,
      U = 0,
      M = 0;
    u.sort(RA);
    const b = f === !0 ? Math.PI : 1;
    for (let J = 0, se = u.length; J < se; J++) {
      const H = u[J],
        Q = H.color,
        ie = H.intensity,
        te = H.distance,
        W = H.shadow && H.shadow.map ? H.shadow.map.texture : null;
      if (H.isAmbientLight)
        (d += Q.r * ie * b), (p += Q.g * ie * b), (v += Q.b * ie * b);
      else if (H.isLightProbe) {
        for (let K = 0; K < 9; K++)
          r.probe[K].addScaledVector(H.sh.coefficients[K], ie);
        M++;
      } else if (H.isDirectionalLight) {
        const K = t.get(H);
        if (
          (K.color.copy(H.color).multiplyScalar(H.intensity * b), H.castShadow)
        ) {
          const G = H.shadow,
            z = i.get(H);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (r.directionalShadow[x] = z),
            (r.directionalShadowMap[x] = W),
            (r.directionalShadowMatrix[x] = H.shadow.matrix),
            E++;
        }
        (r.directional[x] = K), x++;
      } else if (H.isSpotLight) {
        const K = t.get(H);
        K.position.setFromMatrixPosition(H.matrixWorld),
          K.color.copy(Q).multiplyScalar(ie * b),
          (K.distance = te),
          (K.coneCos = Math.cos(H.angle)),
          (K.penumbraCos = Math.cos(H.angle * (1 - H.penumbra))),
          (K.decay = H.decay),
          (r.spot[h] = K);
        const G = H.shadow;
        if (
          (H.map &&
            ((r.spotLightMap[A] = H.map),
            A++,
            G.updateMatrices(H),
            H.castShadow && U++),
          (r.spotLightMatrix[h] = G.matrix),
          H.castShadow)
        ) {
          const z = i.get(H);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (r.spotShadow[h] = z),
            (r.spotShadowMap[h] = W),
            L++;
        }
        h++;
      } else if (H.isRectAreaLight) {
        const K = t.get(H);
        K.color.copy(Q).multiplyScalar(ie),
          K.halfWidth.set(H.width * 0.5, 0, 0),
          K.halfHeight.set(0, H.height * 0.5, 0),
          (r.rectArea[_] = K),
          _++;
      } else if (H.isPointLight) {
        const K = t.get(H);
        if (
          (K.color.copy(H.color).multiplyScalar(H.intensity * b),
          (K.distance = H.distance),
          (K.decay = H.decay),
          H.castShadow)
        ) {
          const G = H.shadow,
            z = i.get(H);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (z.shadowCameraNear = G.camera.near),
            (z.shadowCameraFar = G.camera.far),
            (r.pointShadow[m] = z),
            (r.pointShadowMap[m] = W),
            (r.pointShadowMatrix[m] = H.shadow.matrix),
            w++;
        }
        (r.point[m] = K), m++;
      } else if (H.isHemisphereLight) {
        const K = t.get(H);
        K.skyColor.copy(H.color).multiplyScalar(ie * b),
          K.groundColor.copy(H.groundColor).multiplyScalar(ie * b),
          (r.hemi[g] = K),
          g++;
      }
    }
    _ > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = Me.LTC_FLOAT_1), (r.rectAreaLTC2 = Me.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = Me.LTC_HALF_1), (r.rectAreaLTC2 = Me.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = d),
      (r.ambient[1] = p),
      (r.ambient[2] = v);
    const $ = r.hash;
    ($.directionalLength !== x ||
      $.pointLength !== m ||
      $.spotLength !== h ||
      $.rectAreaLength !== _ ||
      $.hemiLength !== g ||
      $.numDirectionalShadows !== E ||
      $.numPointShadows !== w ||
      $.numSpotShadows !== L ||
      $.numSpotMaps !== A ||
      $.numLightProbes !== M) &&
      ((r.directional.length = x),
      (r.spot.length = h),
      (r.rectArea.length = _),
      (r.point.length = m),
      (r.hemi.length = g),
      (r.directionalShadow.length = E),
      (r.directionalShadowMap.length = E),
      (r.pointShadow.length = w),
      (r.pointShadowMap.length = w),
      (r.spotShadow.length = L),
      (r.spotShadowMap.length = L),
      (r.directionalShadowMatrix.length = E),
      (r.pointShadowMatrix.length = w),
      (r.spotLightMatrix.length = L + A - U),
      (r.spotLightMap.length = A),
      (r.numSpotLightShadowsWithMaps = U),
      (r.numLightProbes = M),
      ($.directionalLength = x),
      ($.pointLength = m),
      ($.spotLength = h),
      ($.rectAreaLength = _),
      ($.hemiLength = g),
      ($.numDirectionalShadows = E),
      ($.numPointShadows = w),
      ($.numSpotShadows = L),
      ($.numSpotMaps = A),
      ($.numLightProbes = M),
      (r.version = AA++));
  }
  function c(u, f) {
    let d = 0,
      p = 0,
      v = 0,
      x = 0,
      m = 0;
    const h = f.matrixWorldInverse;
    for (let _ = 0, g = u.length; _ < g; _++) {
      const E = u[_];
      if (E.isDirectionalLight) {
        const w = r.directional[d];
        w.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          w.direction.sub(s),
          w.direction.transformDirection(h),
          d++;
      } else if (E.isSpotLight) {
        const w = r.spot[v];
        w.position.setFromMatrixPosition(E.matrixWorld),
          w.position.applyMatrix4(h),
          w.direction.setFromMatrixPosition(E.matrixWorld),
          s.setFromMatrixPosition(E.target.matrixWorld),
          w.direction.sub(s),
          w.direction.transformDirection(h),
          v++;
      } else if (E.isRectAreaLight) {
        const w = r.rectArea[x];
        w.position.setFromMatrixPosition(E.matrixWorld),
          w.position.applyMatrix4(h),
          a.identity(),
          o.copy(E.matrixWorld),
          o.premultiply(h),
          a.extractRotation(o),
          w.halfWidth.set(E.width * 0.5, 0, 0),
          w.halfHeight.set(0, E.height * 0.5, 0),
          w.halfWidth.applyMatrix4(a),
          w.halfHeight.applyMatrix4(a),
          x++;
      } else if (E.isPointLight) {
        const w = r.point[p];
        w.position.setFromMatrixPosition(E.matrixWorld),
          w.position.applyMatrix4(h),
          p++;
      } else if (E.isHemisphereLight) {
        const w = r.hemi[m];
        w.direction.setFromMatrixPosition(E.matrixWorld),
          w.direction.transformDirection(h),
          m++;
      }
    }
  }
  return { setup: l, setupView: c, state: r };
}
function rg(n, e) {
  const t = new bA(n, e),
    i = [],
    r = [];
  function s() {
    (i.length = 0), (r.length = 0);
  }
  function o(f) {
    i.push(f);
  }
  function a(f) {
    r.push(f);
  }
  function l(f) {
    t.setup(i, f);
  }
  function c(f) {
    t.setupView(i, f);
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a,
  };
}
function CA(n, e) {
  let t = new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let l;
    return (
      a === void 0
        ? ((l = new rg(n, e)), t.set(s, [l]))
        : o >= a.length
        ? ((l = new rg(n, e)), a.push(l))
        : (l = a[o]),
      l
    );
  }
  function r() {
    t = new WeakMap();
  }
  return { get: i, dispose: r };
}
class LA extends xi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = pE),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class PA extends xi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const IA = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  NA = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function DA(n, e, t) {
  let i = new fh();
  const r = new Ge(),
    s = new Ge(),
    o = new gt(),
    a = new LA({ depthPacking: mE }),
    l = new PA(),
    c = {},
    u = t.maxTextureSize,
    f = { [Xi]: An, [An]: Xi, [oi]: oi },
    d = new Cr({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Ge() },
        radius: { value: 4 },
      },
      vertexShader: IA,
      fragmentShader: NA,
    }),
    p = d.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const v = new fi();
  v.setAttribute(
    "position",
    new gn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const x = new Dn(v, d),
    m = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = K0);
  let h = this.type;
  this.render = function (w, L, A) {
    if (
      m.enabled === !1 ||
      (m.autoUpdate === !1 && m.needsUpdate === !1) ||
      w.length === 0
    )
      return;
    const U = n.getRenderTarget(),
      M = n.getActiveCubeFace(),
      b = n.getActiveMipmapLevel(),
      $ = n.state;
    $.setBlending(Er),
      $.buffers.color.setClear(1, 1, 1, 1),
      $.buffers.depth.setTest(!0),
      $.setScissorTest(!1);
    const J = h !== Ii && this.type === Ii,
      se = h === Ii && this.type !== Ii;
    for (let H = 0, Q = w.length; H < Q; H++) {
      const ie = w[H],
        te = ie.shadow;
      if (te === void 0) {
        console.warn("THREE.WebGLShadowMap:", ie, "has no shadow.");
        continue;
      }
      if (te.autoUpdate === !1 && te.needsUpdate === !1) continue;
      r.copy(te.mapSize);
      const W = te.getFrameExtents();
      if (
        (r.multiply(W),
        s.copy(te.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u &&
            ((s.x = Math.floor(u / W.x)),
            (r.x = s.x * W.x),
            (te.mapSize.x = s.x)),
          r.y > u &&
            ((s.y = Math.floor(u / W.y)),
            (r.y = s.y * W.y),
            (te.mapSize.y = s.y))),
        te.map === null || J === !0 || se === !0)
      ) {
        const G = this.type !== Ii ? { minFilter: qt, magFilter: qt } : {};
        te.map !== null && te.map.dispose(),
          (te.map = new ls(r.x, r.y, G)),
          (te.map.texture.name = ie.name + ".shadowMap"),
          te.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(te.map), n.clear();
      const K = te.getViewportCount();
      for (let G = 0; G < K; G++) {
        const z = te.getViewport(G);
        o.set(s.x * z.x, s.y * z.y, s.x * z.z, s.y * z.w),
          $.viewport(o),
          te.updateMatrices(ie, G),
          (i = te.getFrustum()),
          E(L, A, te.camera, ie, this.type);
      }
      te.isPointLightShadow !== !0 && this.type === Ii && _(te, A),
        (te.needsUpdate = !1);
    }
    (h = this.type), (m.needsUpdate = !1), n.setRenderTarget(U, M, b);
  };
  function _(w, L) {
    const A = e.update(x);
    d.defines.VSM_SAMPLES !== w.blurSamples &&
      ((d.defines.VSM_SAMPLES = w.blurSamples),
      (p.defines.VSM_SAMPLES = w.blurSamples),
      (d.needsUpdate = !0),
      (p.needsUpdate = !0)),
      w.mapPass === null && (w.mapPass = new ls(r.x, r.y)),
      (d.uniforms.shadow_pass.value = w.map.texture),
      (d.uniforms.resolution.value = w.mapSize),
      (d.uniforms.radius.value = w.radius),
      n.setRenderTarget(w.mapPass),
      n.clear(),
      n.renderBufferDirect(L, null, A, d, x, null),
      (p.uniforms.shadow_pass.value = w.mapPass.texture),
      (p.uniforms.resolution.value = w.mapSize),
      (p.uniforms.radius.value = w.radius),
      n.setRenderTarget(w.map),
      n.clear(),
      n.renderBufferDirect(L, null, A, p, x, null);
  }
  function g(w, L, A, U) {
    let M = null;
    const b =
      A.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
    if (b !== void 0) M = b;
    else if (
      ((M = A.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        L.clipShadows === !0 &&
        Array.isArray(L.clippingPlanes) &&
        L.clippingPlanes.length !== 0) ||
        (L.displacementMap && L.displacementScale !== 0) ||
        (L.alphaMap && L.alphaTest > 0) ||
        (L.map && L.alphaTest > 0))
    ) {
      const $ = M.uuid,
        J = L.uuid;
      let se = c[$];
      se === void 0 && ((se = {}), (c[$] = se));
      let H = se[J];
      H === void 0 && ((H = M.clone()), (se[J] = H)), (M = H);
    }
    if (
      ((M.visible = L.visible),
      (M.wireframe = L.wireframe),
      U === Ii
        ? (M.side = L.shadowSide !== null ? L.shadowSide : L.side)
        : (M.side = L.shadowSide !== null ? L.shadowSide : f[L.side]),
      (M.alphaMap = L.alphaMap),
      (M.alphaTest = L.alphaTest),
      (M.map = L.map),
      (M.clipShadows = L.clipShadows),
      (M.clippingPlanes = L.clippingPlanes),
      (M.clipIntersection = L.clipIntersection),
      (M.displacementMap = L.displacementMap),
      (M.displacementScale = L.displacementScale),
      (M.displacementBias = L.displacementBias),
      (M.wireframeLinewidth = L.wireframeLinewidth),
      (M.linewidth = L.linewidth),
      A.isPointLight === !0 && M.isMeshDistanceMaterial === !0)
    ) {
      const $ = n.properties.get(M);
      $.light = A;
    }
    return M;
  }
  function E(w, L, A, U, M) {
    if (w.visible === !1) return;
    if (
      w.layers.test(L.layers) &&
      (w.isMesh || w.isLine || w.isPoints) &&
      (w.castShadow || (w.receiveShadow && M === Ii)) &&
      (!w.frustumCulled || i.intersectsObject(w))
    ) {
      w.modelViewMatrix.multiplyMatrices(A.matrixWorldInverse, w.matrixWorld);
      const J = e.update(w),
        se = w.material;
      if (Array.isArray(se)) {
        const H = J.groups;
        for (let Q = 0, ie = H.length; Q < ie; Q++) {
          const te = H[Q],
            W = se[te.materialIndex];
          if (W && W.visible) {
            const K = g(w, W, U, M);
            n.renderBufferDirect(A, null, J, K, w, te);
          }
        }
      } else if (se.visible) {
        const H = g(w, se, U, M);
        n.renderBufferDirect(A, null, J, H, w, null);
      }
    }
    const $ = w.children;
    for (let J = 0, se = $.length; J < se; J++) E($[J], L, A, U, M);
  }
}
function UA(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let k = !1;
    const xe = new gt();
    let ce = null;
    const ee = new gt(0, 0, 0, 0);
    return {
      setMask: function (me) {
        ce !== me && !k && (n.colorMask(me, me, me, me), (ce = me));
      },
      setLocked: function (me) {
        k = me;
      },
      setClear: function (me, Ue, Je, It, yn) {
        yn === !0 && ((me *= It), (Ue *= It), (Je *= It)),
          xe.set(me, Ue, Je, It),
          ee.equals(xe) === !1 && (n.clearColor(me, Ue, Je, It), ee.copy(xe));
      },
      reset: function () {
        (k = !1), (ce = null), ee.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let k = !1,
      xe = null,
      ce = null,
      ee = null;
    return {
      setTest: function (me) {
        me ? We(n.DEPTH_TEST) : pt(n.DEPTH_TEST);
      },
      setMask: function (me) {
        xe !== me && !k && (n.depthMask(me), (xe = me));
      },
      setFunc: function (me) {
        if (ce !== me) {
          switch (me) {
            case WS:
              n.depthFunc(n.NEVER);
              break;
            case XS:
              n.depthFunc(n.ALWAYS);
              break;
            case jS:
              n.depthFunc(n.LESS);
              break;
            case pc:
              n.depthFunc(n.LEQUAL);
              break;
            case YS:
              n.depthFunc(n.EQUAL);
              break;
            case qS:
              n.depthFunc(n.GEQUAL);
              break;
            case KS:
              n.depthFunc(n.GREATER);
              break;
            case ZS:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          ce = me;
        }
      },
      setLocked: function (me) {
        k = me;
      },
      setClear: function (me) {
        ee !== me && (n.clearDepth(me), (ee = me));
      },
      reset: function () {
        (k = !1), (xe = null), (ce = null), (ee = null);
      },
    };
  }
  function o() {
    let k = !1,
      xe = null,
      ce = null,
      ee = null,
      me = null,
      Ue = null,
      Je = null,
      It = null,
      yn = null;
    return {
      setTest: function (dt) {
        k || (dt ? We(n.STENCIL_TEST) : pt(n.STENCIL_TEST));
      },
      setMask: function (dt) {
        xe !== dt && !k && (n.stencilMask(dt), (xe = dt));
      },
      setFunc: function (dt, $t, Bn) {
        (ce !== dt || ee !== $t || me !== Bn) &&
          (n.stencilFunc(dt, $t, Bn), (ce = dt), (ee = $t), (me = Bn));
      },
      setOp: function (dt, $t, Bn) {
        (Ue !== dt || Je !== $t || It !== Bn) &&
          (n.stencilOp(dt, $t, Bn), (Ue = dt), (Je = $t), (It = Bn));
      },
      setLocked: function (dt) {
        k = dt;
      },
      setClear: function (dt) {
        yn !== dt && (n.clearStencil(dt), (yn = dt));
      },
      reset: function () {
        (k = !1),
          (xe = null),
          (ce = null),
          (ee = null),
          (me = null),
          (Ue = null),
          (Je = null),
          (It = null),
          (yn = null);
      },
    };
  }
  const a = new r(),
    l = new s(),
    c = new o(),
    u = new WeakMap(),
    f = new WeakMap();
  let d = {},
    p = {},
    v = new WeakMap(),
    x = [],
    m = null,
    h = !1,
    _ = null,
    g = null,
    E = null,
    w = null,
    L = null,
    A = null,
    U = null,
    M = new Ke(0, 0, 0),
    b = 0,
    $ = !1,
    J = null,
    se = null,
    H = null,
    Q = null,
    ie = null;
  const te = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let W = !1,
    K = 0;
  const G = n.getParameter(n.VERSION);
  G.indexOf("WebGL") !== -1
    ? ((K = parseFloat(/^WebGL (\d)/.exec(G)[1])), (W = K >= 1))
    : G.indexOf("OpenGL ES") !== -1 &&
      ((K = parseFloat(/^OpenGL ES (\d)/.exec(G)[1])), (W = K >= 2));
  let z = null,
    V = {};
  const _e = n.getParameter(n.SCISSOR_BOX),
    ve = n.getParameter(n.VIEWPORT),
    we = new gt().fromArray(_e),
    ye = new gt().fromArray(ve);
  function ke(k, xe, ce, ee) {
    const me = new Uint8Array(4),
      Ue = n.createTexture();
    n.bindTexture(k, Ue),
      n.texParameteri(k, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(k, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let Je = 0; Je < ce; Je++)
      i && (k === n.TEXTURE_3D || k === n.TEXTURE_2D_ARRAY)
        ? n.texImage3D(xe, 0, n.RGBA, 1, 1, ee, 0, n.RGBA, n.UNSIGNED_BYTE, me)
        : n.texImage2D(
            xe + Je,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            me
          );
    return Ue;
  }
  const Ne = {};
  (Ne[n.TEXTURE_2D] = ke(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (Ne[n.TEXTURE_CUBE_MAP] = ke(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    i &&
      ((Ne[n.TEXTURE_2D_ARRAY] = ke(
        n.TEXTURE_2D_ARRAY,
        n.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Ne[n.TEXTURE_3D] = ke(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1))),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    We(n.DEPTH_TEST),
    l.setFunc(pc),
    qe(!1),
    Xe(Op),
    We(n.CULL_FACE),
    Ve(Er);
  function We(k) {
    d[k] !== !0 && (n.enable(k), (d[k] = !0));
  }
  function pt(k) {
    d[k] !== !1 && (n.disable(k), (d[k] = !1));
  }
  function Ye(k, xe) {
    return p[k] !== xe
      ? (n.bindFramebuffer(k, xe),
        (p[k] = xe),
        i &&
          (k === n.DRAW_FRAMEBUFFER && (p[n.FRAMEBUFFER] = xe),
          k === n.FRAMEBUFFER && (p[n.DRAW_FRAMEBUFFER] = xe)),
        !0)
      : !1;
  }
  function j(k, xe) {
    let ce = x,
      ee = !1;
    if (k)
      if (
        ((ce = v.get(xe)),
        ce === void 0 && ((ce = []), v.set(xe, ce)),
        k.isWebGLMultipleRenderTargets)
      ) {
        const me = k.texture;
        if (ce.length !== me.length || ce[0] !== n.COLOR_ATTACHMENT0) {
          for (let Ue = 0, Je = me.length; Ue < Je; Ue++)
            ce[Ue] = n.COLOR_ATTACHMENT0 + Ue;
          (ce.length = me.length), (ee = !0);
        }
      } else
        ce[0] !== n.COLOR_ATTACHMENT0 &&
          ((ce[0] = n.COLOR_ATTACHMENT0), (ee = !0));
    else ce[0] !== n.BACK && ((ce[0] = n.BACK), (ee = !0));
    ee &&
      (t.isWebGL2
        ? n.drawBuffers(ce)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(ce));
  }
  function kt(k) {
    return m !== k ? (n.useProgram(k), (m = k), !0) : !1;
  }
  const De = {
    [Xr]: n.FUNC_ADD,
    [CS]: n.FUNC_SUBTRACT,
    [LS]: n.FUNC_REVERSE_SUBTRACT,
  };
  if (i) (De[zp] = n.MIN), (De[Hp] = n.MAX);
  else {
    const k = e.get("EXT_blend_minmax");
    k !== null && ((De[zp] = k.MIN_EXT), (De[Hp] = k.MAX_EXT));
  }
  const He = {
    [PS]: n.ZERO,
    [IS]: n.ONE,
    [NS]: n.SRC_COLOR,
    [Zf]: n.SRC_ALPHA,
    [BS]: n.SRC_ALPHA_SATURATE,
    [FS]: n.DST_COLOR,
    [US]: n.DST_ALPHA,
    [DS]: n.ONE_MINUS_SRC_COLOR,
    [$f]: n.ONE_MINUS_SRC_ALPHA,
    [kS]: n.ONE_MINUS_DST_COLOR,
    [OS]: n.ONE_MINUS_DST_ALPHA,
    [zS]: n.CONSTANT_COLOR,
    [HS]: n.ONE_MINUS_CONSTANT_COLOR,
    [VS]: n.CONSTANT_ALPHA,
    [GS]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function Ve(k, xe, ce, ee, me, Ue, Je, It, yn, dt) {
    if (k === Er) {
      h === !0 && (pt(n.BLEND), (h = !1));
      return;
    }
    if ((h === !1 && (We(n.BLEND), (h = !0)), k !== bS)) {
      if (k !== _ || dt !== $) {
        if (
          ((g !== Xr || L !== Xr) &&
            (n.blendEquation(n.FUNC_ADD), (g = Xr), (L = Xr)),
          dt)
        )
          switch (k) {
            case Js:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Fp:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case kp:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Bp:
              n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
        else
          switch (k) {
            case Js:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Fp:
              n.blendFunc(n.SRC_ALPHA, n.ONE);
              break;
            case kp:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case Bp:
              n.blendFunc(n.ZERO, n.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", k);
              break;
          }
        (E = null),
          (w = null),
          (A = null),
          (U = null),
          M.set(0, 0, 0),
          (b = 0),
          (_ = k),
          ($ = dt);
      }
      return;
    }
    (me = me || xe),
      (Ue = Ue || ce),
      (Je = Je || ee),
      (xe !== g || me !== L) &&
        (n.blendEquationSeparate(De[xe], De[me]), (g = xe), (L = me)),
      (ce !== E || ee !== w || Ue !== A || Je !== U) &&
        (n.blendFuncSeparate(He[ce], He[ee], He[Ue], He[Je]),
        (E = ce),
        (w = ee),
        (A = Ue),
        (U = Je)),
      (It.equals(M) === !1 || yn !== b) &&
        (n.blendColor(It.r, It.g, It.b, yn), M.copy(It), (b = yn)),
      (_ = k),
      ($ = !1);
  }
  function _t(k, xe) {
    k.side === oi ? pt(n.CULL_FACE) : We(n.CULL_FACE);
    let ce = k.side === An;
    xe && (ce = !ce),
      qe(ce),
      k.blending === Js && k.transparent === !1
        ? Ve(Er)
        : Ve(
            k.blending,
            k.blendEquation,
            k.blendSrc,
            k.blendDst,
            k.blendEquationAlpha,
            k.blendSrcAlpha,
            k.blendDstAlpha,
            k.blendColor,
            k.blendAlpha,
            k.premultipliedAlpha
          ),
      l.setFunc(k.depthFunc),
      l.setTest(k.depthTest),
      l.setMask(k.depthWrite),
      a.setMask(k.colorWrite);
    const ee = k.stencilWrite;
    c.setTest(ee),
      ee &&
        (c.setMask(k.stencilWriteMask),
        c.setFunc(k.stencilFunc, k.stencilRef, k.stencilFuncMask),
        c.setOp(k.stencilFail, k.stencilZFail, k.stencilZPass)),
      Pt(k.polygonOffset, k.polygonOffsetFactor, k.polygonOffsetUnits),
      k.alphaToCoverage === !0
        ? We(n.SAMPLE_ALPHA_TO_COVERAGE)
        : pt(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function qe(k) {
    J !== k && (k ? n.frontFace(n.CW) : n.frontFace(n.CCW), (J = k));
  }
  function Xe(k) {
    k !== AS
      ? (We(n.CULL_FACE),
        k !== se &&
          (k === Op
            ? n.cullFace(n.BACK)
            : k === RS
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : pt(n.CULL_FACE),
      (se = k);
  }
  function it(k) {
    k !== H && (W && n.lineWidth(k), (H = k));
  }
  function Pt(k, xe, ce) {
    k
      ? (We(n.POLYGON_OFFSET_FILL),
        (Q !== xe || ie !== ce) &&
          (n.polygonOffset(xe, ce), (Q = xe), (ie = ce)))
      : pt(n.POLYGON_OFFSET_FILL);
  }
  function Ut(k) {
    k ? We(n.SCISSOR_TEST) : pt(n.SCISSOR_TEST);
  }
  function I(k) {
    k === void 0 && (k = n.TEXTURE0 + te - 1),
      z !== k && (n.activeTexture(k), (z = k));
  }
  function T(k, xe, ce) {
    ce === void 0 && (z === null ? (ce = n.TEXTURE0 + te - 1) : (ce = z));
    let ee = V[ce];
    ee === void 0 && ((ee = { type: void 0, texture: void 0 }), (V[ce] = ee)),
      (ee.type !== k || ee.texture !== xe) &&
        (z !== ce && (n.activeTexture(ce), (z = ce)),
        n.bindTexture(k, xe || Ne[k]),
        (ee.type = k),
        (ee.texture = xe));
  }
  function q() {
    const k = V[z];
    k !== void 0 &&
      k.type !== void 0 &&
      (n.bindTexture(k.type, null), (k.type = void 0), (k.texture = void 0));
  }
  function pe() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function le() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function he() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Ie() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function ge() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Ae() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function F() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function fe() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function ne() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Be() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (k) {
      console.error("THREE.WebGLState:", k);
    }
  }
  function Pe(k) {
    we.equals(k) === !1 && (n.scissor(k.x, k.y, k.z, k.w), we.copy(k));
  }
  function Le(k) {
    ye.equals(k) === !1 && (n.viewport(k.x, k.y, k.z, k.w), ye.copy(k));
  }
  function Te(k, xe) {
    let ce = f.get(xe);
    ce === void 0 && ((ce = new WeakMap()), f.set(xe, ce));
    let ee = ce.get(k);
    ee === void 0 && ((ee = n.getUniformBlockIndex(xe, k.name)), ce.set(k, ee));
  }
  function Re(k, xe) {
    const ee = f.get(xe).get(k);
    u.get(xe) !== ee &&
      (n.uniformBlockBinding(xe, ee, k.__bindingPointIndex), u.set(xe, ee));
  }
  function oe() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      i === !0 &&
        (n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (d = {}),
      (z = null),
      (V = {}),
      (p = {}),
      (v = new WeakMap()),
      (x = []),
      (m = null),
      (h = !1),
      (_ = null),
      (g = null),
      (E = null),
      (w = null),
      (L = null),
      (A = null),
      (U = null),
      (M = new Ke(0, 0, 0)),
      (b = 0),
      ($ = !1),
      (J = null),
      (se = null),
      (H = null),
      (Q = null),
      (ie = null),
      we.set(0, 0, n.canvas.width, n.canvas.height),
      ye.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: a, depth: l, stencil: c },
    enable: We,
    disable: pt,
    bindFramebuffer: Ye,
    drawBuffers: j,
    useProgram: kt,
    setBlending: Ve,
    setMaterial: _t,
    setFlipSided: qe,
    setCullFace: Xe,
    setLineWidth: it,
    setPolygonOffset: Pt,
    setScissorTest: Ut,
    activeTexture: I,
    bindTexture: T,
    unbindTexture: q,
    compressedTexImage2D: pe,
    compressedTexImage3D: le,
    texImage2D: ne,
    texImage3D: Be,
    updateUBOMapping: Te,
    uniformBlockBinding: Re,
    texStorage2D: F,
    texStorage3D: fe,
    texSubImage2D: he,
    texSubImage3D: Ie,
    compressedTexSubImage2D: ge,
    compressedTexSubImage3D: Ae,
    scissor: Pe,
    viewport: Le,
    reset: oe,
  };
}
function OA(n, e, t, i, r, s, o) {
  const a = r.isWebGL2,
    l = r.maxTextures,
    c = r.maxCubemapSize,
    u = r.maxTextureSize,
    f = r.maxSamples,
    d = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    p =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    v = new WeakMap();
  let x;
  const m = new WeakMap();
  let h = !1;
  try {
    h =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function _(I, T) {
    return h ? new OffscreenCanvas(I, T) : Aa("canvas");
  }
  function g(I, T, q, pe) {
    let le = 1;
    if (
      ((I.width > pe || I.height > pe) &&
        (le = pe / Math.max(I.width, I.height)),
      le < 1 || T === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && I instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && I instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && I instanceof ImageBitmap)
      ) {
        const he = T ? Sc : Math.floor,
          Ie = he(le * I.width),
          ge = he(le * I.height);
        x === void 0 && (x = _(Ie, ge));
        const Ae = q ? _(Ie, ge) : x;
        return (
          (Ae.width = Ie),
          (Ae.height = ge),
          Ae.getContext("2d").drawImage(I, 0, 0, Ie, ge),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              I.width +
              "x" +
              I.height +
              ") to (" +
              Ie +
              "x" +
              ge +
              ")."
          ),
          Ae
        );
      } else
        return (
          "data" in I &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                I.width +
                "x" +
                I.height +
                ")."
            ),
          I
        );
    return I;
  }
  function E(I) {
    return id(I.width) && id(I.height);
  }
  function w(I) {
    return a
      ? !1
      : I.wrapS !== Sn ||
          I.wrapT !== Sn ||
          (I.minFilter !== qt && I.minFilter !== zt);
  }
  function L(I, T) {
    return I.generateMipmaps && T && I.minFilter !== qt && I.minFilter !== zt;
  }
  function A(I) {
    n.generateMipmap(I);
  }
  function U(I, T, q, pe, le = !1) {
    if (a === !1) return T;
    if (I !== null) {
      if (n[I] !== void 0) return n[I];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          I +
          "'"
      );
    }
    let he = T;
    if (
      (T === n.RED &&
        (q === n.FLOAT && (he = n.R32F),
        q === n.HALF_FLOAT && (he = n.R16F),
        q === n.UNSIGNED_BYTE && (he = n.R8)),
      T === n.RED_INTEGER &&
        (q === n.UNSIGNED_BYTE && (he = n.R8UI),
        q === n.UNSIGNED_SHORT && (he = n.R16UI),
        q === n.UNSIGNED_INT && (he = n.R32UI),
        q === n.BYTE && (he = n.R8I),
        q === n.SHORT && (he = n.R16I),
        q === n.INT && (he = n.R32I)),
      T === n.RG &&
        (q === n.FLOAT && (he = n.RG32F),
        q === n.HALF_FLOAT && (he = n.RG16F),
        q === n.UNSIGNED_BYTE && (he = n.RG8)),
      T === n.RGBA)
    ) {
      const Ie = le ? _c : lt.getTransfer(pe);
      q === n.FLOAT && (he = n.RGBA32F),
        q === n.HALF_FLOAT && (he = n.RGBA16F),
        q === n.UNSIGNED_BYTE && (he = Ie === xt ? n.SRGB8_ALPHA8 : n.RGBA8),
        q === n.UNSIGNED_SHORT_4_4_4_4 && (he = n.RGBA4),
        q === n.UNSIGNED_SHORT_5_5_5_1 && (he = n.RGB5_A1);
    }
    return (
      (he === n.R16F ||
        he === n.R32F ||
        he === n.RG16F ||
        he === n.RG32F ||
        he === n.RGBA16F ||
        he === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      he
    );
  }
  function M(I, T, q) {
    return L(I, q) === !0 ||
      (I.isFramebufferTexture && I.minFilter !== qt && I.minFilter !== zt)
      ? Math.log2(Math.max(T.width, T.height)) + 1
      : I.mipmaps !== void 0 && I.mipmaps.length > 0
      ? I.mipmaps.length
      : I.isCompressedTexture && Array.isArray(I.image)
      ? T.mipmaps.length
      : 1;
  }
  function b(I) {
    return I === qt || I === Jf || I === Vl ? n.NEAREST : n.LINEAR;
  }
  function $(I) {
    const T = I.target;
    T.removeEventListener("dispose", $), se(T), T.isVideoTexture && v.delete(T);
  }
  function J(I) {
    const T = I.target;
    T.removeEventListener("dispose", J), Q(T);
  }
  function se(I) {
    const T = i.get(I);
    if (T.__webglInit === void 0) return;
    const q = I.source,
      pe = m.get(q);
    if (pe) {
      const le = pe[T.__cacheKey];
      le.usedTimes--,
        le.usedTimes === 0 && H(I),
        Object.keys(pe).length === 0 && m.delete(q);
    }
    i.remove(I);
  }
  function H(I) {
    const T = i.get(I);
    n.deleteTexture(T.__webglTexture);
    const q = I.source,
      pe = m.get(q);
    delete pe[T.__cacheKey], o.memory.textures--;
  }
  function Q(I) {
    const T = I.texture,
      q = i.get(I),
      pe = i.get(T);
    if (
      (pe.__webglTexture !== void 0 &&
        (n.deleteTexture(pe.__webglTexture), o.memory.textures--),
      I.depthTexture && I.depthTexture.dispose(),
      I.isWebGLCubeRenderTarget)
    )
      for (let le = 0; le < 6; le++) {
        if (Array.isArray(q.__webglFramebuffer[le]))
          for (let he = 0; he < q.__webglFramebuffer[le].length; he++)
            n.deleteFramebuffer(q.__webglFramebuffer[le][he]);
        else n.deleteFramebuffer(q.__webglFramebuffer[le]);
        q.__webglDepthbuffer && n.deleteRenderbuffer(q.__webglDepthbuffer[le]);
      }
    else {
      if (Array.isArray(q.__webglFramebuffer))
        for (let le = 0; le < q.__webglFramebuffer.length; le++)
          n.deleteFramebuffer(q.__webglFramebuffer[le]);
      else n.deleteFramebuffer(q.__webglFramebuffer);
      if (
        (q.__webglDepthbuffer && n.deleteRenderbuffer(q.__webglDepthbuffer),
        q.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(q.__webglMultisampledFramebuffer),
        q.__webglColorRenderbuffer)
      )
        for (let le = 0; le < q.__webglColorRenderbuffer.length; le++)
          q.__webglColorRenderbuffer[le] &&
            n.deleteRenderbuffer(q.__webglColorRenderbuffer[le]);
      q.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(q.__webglDepthRenderbuffer);
    }
    if (I.isWebGLMultipleRenderTargets)
      for (let le = 0, he = T.length; le < he; le++) {
        const Ie = i.get(T[le]);
        Ie.__webglTexture &&
          (n.deleteTexture(Ie.__webglTexture), o.memory.textures--),
          i.remove(T[le]);
      }
    i.remove(T), i.remove(I);
  }
  let ie = 0;
  function te() {
    ie = 0;
  }
  function W() {
    const I = ie;
    return (
      I >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            I +
            " texture units while this GPU supports only " +
            l
        ),
      (ie += 1),
      I
    );
  }
  function K(I) {
    const T = [];
    return (
      T.push(I.wrapS),
      T.push(I.wrapT),
      T.push(I.wrapR || 0),
      T.push(I.magFilter),
      T.push(I.minFilter),
      T.push(I.anisotropy),
      T.push(I.internalFormat),
      T.push(I.format),
      T.push(I.type),
      T.push(I.generateMipmaps),
      T.push(I.premultiplyAlpha),
      T.push(I.flipY),
      T.push(I.unpackAlignment),
      T.push(I.colorSpace),
      T.join()
    );
  }
  function G(I, T) {
    const q = i.get(I);
    if (
      (I.isVideoTexture && Pt(I),
      I.isRenderTargetTexture === !1 &&
        I.version > 0 &&
        q.__version !== I.version)
    ) {
      const pe = I.image;
      if (pe === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (pe.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        We(q, I, T);
        return;
      }
    }
    t.bindTexture(n.TEXTURE_2D, q.__webglTexture, n.TEXTURE0 + T);
  }
  function z(I, T) {
    const q = i.get(I);
    if (I.version > 0 && q.__version !== I.version) {
      We(q, I, T);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, q.__webglTexture, n.TEXTURE0 + T);
  }
  function V(I, T) {
    const q = i.get(I);
    if (I.version > 0 && q.__version !== I.version) {
      We(q, I, T);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, q.__webglTexture, n.TEXTURE0 + T);
  }
  function _e(I, T) {
    const q = i.get(I);
    if (I.version > 0 && q.__version !== I.version) {
      pt(q, I, T);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, q.__webglTexture, n.TEXTURE0 + T);
  }
  const ve = { [fo]: n.REPEAT, [Sn]: n.CLAMP_TO_EDGE, [gc]: n.MIRRORED_REPEAT },
    we = {
      [qt]: n.NEAREST,
      [Jf]: n.NEAREST_MIPMAP_NEAREST,
      [Vl]: n.NEAREST_MIPMAP_LINEAR,
      [zt]: n.LINEAR,
      [ev]: n.LINEAR_MIPMAP_NEAREST,
      [br]: n.LINEAR_MIPMAP_LINEAR,
    },
    ye = {
      [_E]: n.NEVER,
      [TE]: n.ALWAYS,
      [vE]: n.LESS,
      [xE]: n.LEQUAL,
      [yE]: n.EQUAL,
      [ME]: n.GEQUAL,
      [SE]: n.GREATER,
      [EE]: n.NOTEQUAL,
    };
  function ke(I, T, q) {
    if (
      (q
        ? (n.texParameteri(I, n.TEXTURE_WRAP_S, ve[T.wrapS]),
          n.texParameteri(I, n.TEXTURE_WRAP_T, ve[T.wrapT]),
          (I === n.TEXTURE_3D || I === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(I, n.TEXTURE_WRAP_R, ve[T.wrapR]),
          n.texParameteri(I, n.TEXTURE_MAG_FILTER, we[T.magFilter]),
          n.texParameteri(I, n.TEXTURE_MIN_FILTER, we[T.minFilter]))
        : (n.texParameteri(I, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE),
          n.texParameteri(I, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE),
          (I === n.TEXTURE_3D || I === n.TEXTURE_2D_ARRAY) &&
            n.texParameteri(I, n.TEXTURE_WRAP_R, n.CLAMP_TO_EDGE),
          (T.wrapS !== Sn || T.wrapT !== Sn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(I, n.TEXTURE_MAG_FILTER, b(T.magFilter)),
          n.texParameteri(I, n.TEXTURE_MIN_FILTER, b(T.minFilter)),
          T.minFilter !== qt &&
            T.minFilter !== zt &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      T.compareFunction &&
        (n.texParameteri(I, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(I, n.TEXTURE_COMPARE_FUNC, ye[T.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const pe = e.get("EXT_texture_filter_anisotropic");
      if (
        T.magFilter === qt ||
        (T.minFilter !== Vl && T.minFilter !== br) ||
        (T.type === jn && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          T.type === ki &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (T.anisotropy > 1 || i.get(T).__currentAnisotropy) &&
        (n.texParameterf(
          I,
          pe.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(T.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(T).__currentAnisotropy = T.anisotropy));
    }
  }
  function Ne(I, T) {
    let q = !1;
    I.__webglInit === void 0 &&
      ((I.__webglInit = !0), T.addEventListener("dispose", $));
    const pe = T.source;
    let le = m.get(pe);
    le === void 0 && ((le = {}), m.set(pe, le));
    const he = K(T);
    if (he !== I.__cacheKey) {
      le[he] === void 0 &&
        ((le[he] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (q = !0)),
        le[he].usedTimes++;
      const Ie = le[I.__cacheKey];
      Ie !== void 0 &&
        (le[I.__cacheKey].usedTimes--, Ie.usedTimes === 0 && H(T)),
        (I.__cacheKey = he),
        (I.__webglTexture = le[he].texture);
    }
    return q;
  }
  function We(I, T, q) {
    let pe = n.TEXTURE_2D;
    (T.isDataArrayTexture || T.isCompressedArrayTexture) &&
      (pe = n.TEXTURE_2D_ARRAY),
      T.isData3DTexture && (pe = n.TEXTURE_3D);
    const le = Ne(I, T),
      he = T.source;
    t.bindTexture(pe, I.__webglTexture, n.TEXTURE0 + q);
    const Ie = i.get(he);
    if (he.version !== Ie.__version || le === !0) {
      t.activeTexture(n.TEXTURE0 + q);
      const ge = lt.getPrimaries(lt.workingColorSpace),
        Ae = T.colorSpace === In ? null : lt.getPrimaries(T.colorSpace),
        F = T.colorSpace === In || ge === Ae ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, T.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, T.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, F);
      const fe = w(T) && E(T.image) === !1;
      let ne = g(T.image, fe, !1, u);
      ne = Ut(T, ne);
      const Be = E(ne) || a,
        Pe = s.convert(T.format, T.colorSpace);
      let Le = s.convert(T.type),
        Te = U(T.internalFormat, Pe, Le, T.colorSpace, T.isVideoTexture);
      ke(pe, T, Be);
      let Re;
      const oe = T.mipmaps,
        k = a && T.isVideoTexture !== !0,
        xe = Ie.__version === void 0 || le === !0,
        ce = M(T, ne, Be);
      if (T.isDepthTexture)
        (Te = n.DEPTH_COMPONENT),
          a
            ? T.type === jn
              ? (Te = n.DEPTH_COMPONENT32F)
              : T.type === dr
              ? (Te = n.DEPTH_COMPONENT24)
              : T.type === es
              ? (Te = n.DEPTH24_STENCIL8)
              : (Te = n.DEPTH_COMPONENT16)
            : T.type === jn &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          T.format === ts &&
            Te === n.DEPTH_COMPONENT &&
            T.type !== ah &&
            T.type !== dr &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (T.type = dr),
            (Le = s.convert(T.type))),
          T.format === ho &&
            Te === n.DEPTH_COMPONENT &&
            ((Te = n.DEPTH_STENCIL),
            T.type !== es &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (T.type = es),
              (Le = s.convert(T.type)))),
          xe &&
            (k
              ? t.texStorage2D(n.TEXTURE_2D, 1, Te, ne.width, ne.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  Te,
                  ne.width,
                  ne.height,
                  0,
                  Pe,
                  Le,
                  null
                ));
      else if (T.isDataTexture)
        if (oe.length > 0 && Be) {
          k &&
            xe &&
            t.texStorage2D(n.TEXTURE_2D, ce, Te, oe[0].width, oe[0].height);
          for (let ee = 0, me = oe.length; ee < me; ee++)
            (Re = oe[ee]),
              k
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    ee,
                    0,
                    0,
                    Re.width,
                    Re.height,
                    Pe,
                    Le,
                    Re.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    ee,
                    Te,
                    Re.width,
                    Re.height,
                    0,
                    Pe,
                    Le,
                    Re.data
                  );
          T.generateMipmaps = !1;
        } else
          k
            ? (xe && t.texStorage2D(n.TEXTURE_2D, ce, Te, ne.width, ne.height),
              t.texSubImage2D(
                n.TEXTURE_2D,
                0,
                0,
                0,
                ne.width,
                ne.height,
                Pe,
                Le,
                ne.data
              ))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                Te,
                ne.width,
                ne.height,
                0,
                Pe,
                Le,
                ne.data
              );
      else if (T.isCompressedTexture)
        if (T.isCompressedArrayTexture) {
          k &&
            xe &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              ce,
              Te,
              oe[0].width,
              oe[0].height,
              ne.depth
            );
          for (let ee = 0, me = oe.length; ee < me; ee++)
            (Re = oe[ee]),
              T.format !== Pn
                ? Pe !== null
                  ? k
                    ? t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        ee,
                        0,
                        0,
                        0,
                        Re.width,
                        Re.height,
                        ne.depth,
                        Pe,
                        Re.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        n.TEXTURE_2D_ARRAY,
                        ee,
                        Te,
                        Re.width,
                        Re.height,
                        ne.depth,
                        0,
                        Re.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : k
                ? t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    ee,
                    0,
                    0,
                    0,
                    Re.width,
                    Re.height,
                    ne.depth,
                    Pe,
                    Le,
                    Re.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    ee,
                    Te,
                    Re.width,
                    Re.height,
                    ne.depth,
                    0,
                    Pe,
                    Le,
                    Re.data
                  );
        } else {
          k &&
            xe &&
            t.texStorage2D(n.TEXTURE_2D, ce, Te, oe[0].width, oe[0].height);
          for (let ee = 0, me = oe.length; ee < me; ee++)
            (Re = oe[ee]),
              T.format !== Pn
                ? Pe !== null
                  ? k
                    ? t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        ee,
                        0,
                        0,
                        Re.width,
                        Re.height,
                        Pe,
                        Re.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        ee,
                        Te,
                        Re.width,
                        Re.height,
                        0,
                        Re.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : k
                ? t.texSubImage2D(
                    n.TEXTURE_2D,
                    ee,
                    0,
                    0,
                    Re.width,
                    Re.height,
                    Pe,
                    Le,
                    Re.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    ee,
                    Te,
                    Re.width,
                    Re.height,
                    0,
                    Pe,
                    Le,
                    Re.data
                  );
        }
      else if (T.isDataArrayTexture)
        k
          ? (xe &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                ce,
                Te,
                ne.width,
                ne.height,
                ne.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              ne.width,
              ne.height,
              ne.depth,
              Pe,
              Le,
              ne.data
            ))
          : t.texImage3D(
              n.TEXTURE_2D_ARRAY,
              0,
              Te,
              ne.width,
              ne.height,
              ne.depth,
              0,
              Pe,
              Le,
              ne.data
            );
      else if (T.isData3DTexture)
        k
          ? (xe &&
              t.texStorage3D(
                n.TEXTURE_3D,
                ce,
                Te,
                ne.width,
                ne.height,
                ne.depth
              ),
            t.texSubImage3D(
              n.TEXTURE_3D,
              0,
              0,
              0,
              0,
              ne.width,
              ne.height,
              ne.depth,
              Pe,
              Le,
              ne.data
            ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              Te,
              ne.width,
              ne.height,
              ne.depth,
              0,
              Pe,
              Le,
              ne.data
            );
      else if (T.isFramebufferTexture) {
        if (xe)
          if (k) t.texStorage2D(n.TEXTURE_2D, ce, Te, ne.width, ne.height);
          else {
            let ee = ne.width,
              me = ne.height;
            for (let Ue = 0; Ue < ce; Ue++)
              t.texImage2D(n.TEXTURE_2D, Ue, Te, ee, me, 0, Pe, Le, null),
                (ee >>= 1),
                (me >>= 1);
          }
      } else if (oe.length > 0 && Be) {
        k &&
          xe &&
          t.texStorage2D(n.TEXTURE_2D, ce, Te, oe[0].width, oe[0].height);
        for (let ee = 0, me = oe.length; ee < me; ee++)
          (Re = oe[ee]),
            k
              ? t.texSubImage2D(n.TEXTURE_2D, ee, 0, 0, Pe, Le, Re)
              : t.texImage2D(n.TEXTURE_2D, ee, Te, Pe, Le, Re);
        T.generateMipmaps = !1;
      } else
        k
          ? (xe && t.texStorage2D(n.TEXTURE_2D, ce, Te, ne.width, ne.height),
            t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Pe, Le, ne))
          : t.texImage2D(n.TEXTURE_2D, 0, Te, Pe, Le, ne);
      L(T, Be) && A(pe),
        (Ie.__version = he.version),
        T.onUpdate && T.onUpdate(T);
    }
    I.__version = T.version;
  }
  function pt(I, T, q) {
    if (T.image.length !== 6) return;
    const pe = Ne(I, T),
      le = T.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, I.__webglTexture, n.TEXTURE0 + q);
    const he = i.get(le);
    if (le.version !== he.__version || pe === !0) {
      t.activeTexture(n.TEXTURE0 + q);
      const Ie = lt.getPrimaries(lt.workingColorSpace),
        ge = T.colorSpace === In ? null : lt.getPrimaries(T.colorSpace),
        Ae =
          T.colorSpace === In || Ie === ge ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, T.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, T.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, T.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
      const F = T.isCompressedTexture || T.image[0].isCompressedTexture,
        fe = T.image[0] && T.image[0].isDataTexture,
        ne = [];
      for (let ee = 0; ee < 6; ee++)
        !F && !fe
          ? (ne[ee] = g(T.image[ee], !1, !0, c))
          : (ne[ee] = fe ? T.image[ee].image : T.image[ee]),
          (ne[ee] = Ut(T, ne[ee]));
      const Be = ne[0],
        Pe = E(Be) || a,
        Le = s.convert(T.format, T.colorSpace),
        Te = s.convert(T.type),
        Re = U(T.internalFormat, Le, Te, T.colorSpace),
        oe = a && T.isVideoTexture !== !0,
        k = he.__version === void 0 || pe === !0;
      let xe = M(T, Be, Pe);
      ke(n.TEXTURE_CUBE_MAP, T, Pe);
      let ce;
      if (F) {
        oe &&
          k &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, xe, Re, Be.width, Be.height);
        for (let ee = 0; ee < 6; ee++) {
          ce = ne[ee].mipmaps;
          for (let me = 0; me < ce.length; me++) {
            const Ue = ce[me];
            T.format !== Pn
              ? Le !== null
                ? oe
                  ? t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                      me,
                      0,
                      0,
                      Ue.width,
                      Ue.height,
                      Le,
                      Ue.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                      me,
                      Re,
                      Ue.width,
                      Ue.height,
                      0,
                      Ue.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : oe
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                  me,
                  0,
                  0,
                  Ue.width,
                  Ue.height,
                  Le,
                  Te,
                  Ue.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                  me,
                  Re,
                  Ue.width,
                  Ue.height,
                  0,
                  Le,
                  Te,
                  Ue.data
                );
          }
        }
      } else {
        (ce = T.mipmaps),
          oe &&
            k &&
            (ce.length > 0 && xe++,
            t.texStorage2D(
              n.TEXTURE_CUBE_MAP,
              xe,
              Re,
              ne[0].width,
              ne[0].height
            ));
        for (let ee = 0; ee < 6; ee++)
          if (fe) {
            oe
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                  0,
                  0,
                  0,
                  ne[ee].width,
                  ne[ee].height,
                  Le,
                  Te,
                  ne[ee].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                  0,
                  Re,
                  ne[ee].width,
                  ne[ee].height,
                  0,
                  Le,
                  Te,
                  ne[ee].data
                );
            for (let me = 0; me < ce.length; me++) {
              const Je = ce[me].image[ee].image;
              oe
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                    me + 1,
                    0,
                    0,
                    Je.width,
                    Je.height,
                    Le,
                    Te,
                    Je.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                    me + 1,
                    Re,
                    Je.width,
                    Je.height,
                    0,
                    Le,
                    Te,
                    Je.data
                  );
            }
          } else {
            oe
              ? t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                  0,
                  0,
                  0,
                  Le,
                  Te,
                  ne[ee]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                  0,
                  Re,
                  Le,
                  Te,
                  ne[ee]
                );
            for (let me = 0; me < ce.length; me++) {
              const Ue = ce[me];
              oe
                ? t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                    me + 1,
                    0,
                    0,
                    Le,
                    Te,
                    Ue.image[ee]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
                    me + 1,
                    Re,
                    Le,
                    Te,
                    Ue.image[ee]
                  );
            }
          }
      }
      L(T, Pe) && A(n.TEXTURE_CUBE_MAP),
        (he.__version = le.version),
        T.onUpdate && T.onUpdate(T);
    }
    I.__version = T.version;
  }
  function Ye(I, T, q, pe, le, he) {
    const Ie = s.convert(q.format, q.colorSpace),
      ge = s.convert(q.type),
      Ae = U(q.internalFormat, Ie, ge, q.colorSpace);
    if (!i.get(T).__hasExternalTextures) {
      const fe = Math.max(1, T.width >> he),
        ne = Math.max(1, T.height >> he);
      le === n.TEXTURE_3D || le === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(le, he, Ae, fe, ne, T.depth, 0, Ie, ge, null)
        : t.texImage2D(le, he, Ae, fe, ne, 0, Ie, ge, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, I),
      it(T)
        ? d.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            pe,
            le,
            i.get(q).__webglTexture,
            0,
            Xe(T)
          )
        : (le === n.TEXTURE_2D ||
            (le >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              le <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(
            n.FRAMEBUFFER,
            pe,
            le,
            i.get(q).__webglTexture,
            he
          ),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function j(I, T, q) {
    if (
      (n.bindRenderbuffer(n.RENDERBUFFER, I), T.depthBuffer && !T.stencilBuffer)
    ) {
      let pe = a === !0 ? n.DEPTH_COMPONENT24 : n.DEPTH_COMPONENT16;
      if (q || it(T)) {
        const le = T.depthTexture;
        le &&
          le.isDepthTexture &&
          (le.type === jn
            ? (pe = n.DEPTH_COMPONENT32F)
            : le.type === dr && (pe = n.DEPTH_COMPONENT24));
        const he = Xe(T);
        it(T)
          ? d.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              he,
              pe,
              T.width,
              T.height
            )
          : n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              he,
              pe,
              T.width,
              T.height
            );
      } else n.renderbufferStorage(n.RENDERBUFFER, pe, T.width, T.height);
      n.framebufferRenderbuffer(
        n.FRAMEBUFFER,
        n.DEPTH_ATTACHMENT,
        n.RENDERBUFFER,
        I
      );
    } else if (T.depthBuffer && T.stencilBuffer) {
      const pe = Xe(T);
      q && it(T) === !1
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            pe,
            n.DEPTH24_STENCIL8,
            T.width,
            T.height
          )
        : it(T)
        ? d.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            pe,
            n.DEPTH24_STENCIL8,
            T.width,
            T.height
          )
        : n.renderbufferStorage(
            n.RENDERBUFFER,
            n.DEPTH_STENCIL,
            T.width,
            T.height
          ),
        n.framebufferRenderbuffer(
          n.FRAMEBUFFER,
          n.DEPTH_STENCIL_ATTACHMENT,
          n.RENDERBUFFER,
          I
        );
    } else {
      const pe =
        T.isWebGLMultipleRenderTargets === !0 ? T.texture : [T.texture];
      for (let le = 0; le < pe.length; le++) {
        const he = pe[le],
          Ie = s.convert(he.format, he.colorSpace),
          ge = s.convert(he.type),
          Ae = U(he.internalFormat, Ie, ge, he.colorSpace),
          F = Xe(T);
        q && it(T) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              F,
              Ae,
              T.width,
              T.height
            )
          : it(T)
          ? d.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              F,
              Ae,
              T.width,
              T.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, Ae, T.width, T.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function kt(I, T) {
    if (T && T.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, I),
      !(T.depthTexture && T.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(T.depthTexture).__webglTexture ||
      T.depthTexture.image.width !== T.width ||
      T.depthTexture.image.height !== T.height) &&
      ((T.depthTexture.image.width = T.width),
      (T.depthTexture.image.height = T.height),
      (T.depthTexture.needsUpdate = !0)),
      G(T.depthTexture, 0);
    const pe = i.get(T.depthTexture).__webglTexture,
      le = Xe(T);
    if (T.depthTexture.format === ts)
      it(T)
        ? d.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            pe,
            0,
            le
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            pe,
            0
          );
    else if (T.depthTexture.format === ho)
      it(T)
        ? d.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            pe,
            0,
            le
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            pe,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function De(I) {
    const T = i.get(I),
      q = I.isWebGLCubeRenderTarget === !0;
    if (I.depthTexture && !T.__autoAllocateDepthBuffer) {
      if (q)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      kt(T.__webglFramebuffer, I);
    } else if (q) {
      T.__webglDepthbuffer = [];
      for (let pe = 0; pe < 6; pe++)
        t.bindFramebuffer(n.FRAMEBUFFER, T.__webglFramebuffer[pe]),
          (T.__webglDepthbuffer[pe] = n.createRenderbuffer()),
          j(T.__webglDepthbuffer[pe], I, !1);
    } else
      t.bindFramebuffer(n.FRAMEBUFFER, T.__webglFramebuffer),
        (T.__webglDepthbuffer = n.createRenderbuffer()),
        j(T.__webglDepthbuffer, I, !1);
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function He(I, T, q) {
    const pe = i.get(I);
    T !== void 0 &&
      Ye(
        pe.__webglFramebuffer,
        I,
        I.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      q !== void 0 && De(I);
  }
  function Ve(I) {
    const T = I.texture,
      q = i.get(I),
      pe = i.get(T);
    I.addEventListener("dispose", J),
      I.isWebGLMultipleRenderTargets !== !0 &&
        (pe.__webglTexture === void 0 &&
          (pe.__webglTexture = n.createTexture()),
        (pe.__version = T.version),
        o.memory.textures++);
    const le = I.isWebGLCubeRenderTarget === !0,
      he = I.isWebGLMultipleRenderTargets === !0,
      Ie = E(I) || a;
    if (le) {
      q.__webglFramebuffer = [];
      for (let ge = 0; ge < 6; ge++)
        if (a && T.mipmaps && T.mipmaps.length > 0) {
          q.__webglFramebuffer[ge] = [];
          for (let Ae = 0; Ae < T.mipmaps.length; Ae++)
            q.__webglFramebuffer[ge][Ae] = n.createFramebuffer();
        } else q.__webglFramebuffer[ge] = n.createFramebuffer();
    } else {
      if (a && T.mipmaps && T.mipmaps.length > 0) {
        q.__webglFramebuffer = [];
        for (let ge = 0; ge < T.mipmaps.length; ge++)
          q.__webglFramebuffer[ge] = n.createFramebuffer();
      } else q.__webglFramebuffer = n.createFramebuffer();
      if (he)
        if (r.drawBuffers) {
          const ge = I.texture;
          for (let Ae = 0, F = ge.length; Ae < F; Ae++) {
            const fe = i.get(ge[Ae]);
            fe.__webglTexture === void 0 &&
              ((fe.__webglTexture = n.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && I.samples > 0 && it(I) === !1) {
        const ge = he ? T : [T];
        (q.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (q.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, q.__webglMultisampledFramebuffer);
        for (let Ae = 0; Ae < ge.length; Ae++) {
          const F = ge[Ae];
          (q.__webglColorRenderbuffer[Ae] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, q.__webglColorRenderbuffer[Ae]);
          const fe = s.convert(F.format, F.colorSpace),
            ne = s.convert(F.type),
            Be = U(
              F.internalFormat,
              fe,
              ne,
              F.colorSpace,
              I.isXRRenderTarget === !0
            ),
            Pe = Xe(I);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Pe,
            Be,
            I.width,
            I.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Ae,
              n.RENDERBUFFER,
              q.__webglColorRenderbuffer[Ae]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          I.depthBuffer &&
            ((q.__webglDepthRenderbuffer = n.createRenderbuffer()),
            j(q.__webglDepthRenderbuffer, I, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (le) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, pe.__webglTexture),
        ke(n.TEXTURE_CUBE_MAP, T, Ie);
      for (let ge = 0; ge < 6; ge++)
        if (a && T.mipmaps && T.mipmaps.length > 0)
          for (let Ae = 0; Ae < T.mipmaps.length; Ae++)
            Ye(
              q.__webglFramebuffer[ge][Ae],
              I,
              T,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
              Ae
            );
        else
          Ye(
            q.__webglFramebuffer[ge],
            I,
            T,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + ge,
            0
          );
      L(T, Ie) && A(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (he) {
      const ge = I.texture;
      for (let Ae = 0, F = ge.length; Ae < F; Ae++) {
        const fe = ge[Ae],
          ne = i.get(fe);
        t.bindTexture(n.TEXTURE_2D, ne.__webglTexture),
          ke(n.TEXTURE_2D, fe, Ie),
          Ye(
            q.__webglFramebuffer,
            I,
            fe,
            n.COLOR_ATTACHMENT0 + Ae,
            n.TEXTURE_2D,
            0
          ),
          L(fe, Ie) && A(n.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let ge = n.TEXTURE_2D;
      if (
        ((I.isWebGL3DRenderTarget || I.isWebGLArrayRenderTarget) &&
          (a
            ? (ge = I.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        t.bindTexture(ge, pe.__webglTexture),
        ke(ge, T, Ie),
        a && T.mipmaps && T.mipmaps.length > 0)
      )
        for (let Ae = 0; Ae < T.mipmaps.length; Ae++)
          Ye(q.__webglFramebuffer[Ae], I, T, n.COLOR_ATTACHMENT0, ge, Ae);
      else Ye(q.__webglFramebuffer, I, T, n.COLOR_ATTACHMENT0, ge, 0);
      L(T, Ie) && A(ge), t.unbindTexture();
    }
    I.depthBuffer && De(I);
  }
  function _t(I) {
    const T = E(I) || a,
      q = I.isWebGLMultipleRenderTargets === !0 ? I.texture : [I.texture];
    for (let pe = 0, le = q.length; pe < le; pe++) {
      const he = q[pe];
      if (L(he, T)) {
        const Ie = I.isWebGLCubeRenderTarget
            ? n.TEXTURE_CUBE_MAP
            : n.TEXTURE_2D,
          ge = i.get(he).__webglTexture;
        t.bindTexture(Ie, ge), A(Ie), t.unbindTexture();
      }
    }
  }
  function qe(I) {
    if (a && I.samples > 0 && it(I) === !1) {
      const T = I.isWebGLMultipleRenderTargets ? I.texture : [I.texture],
        q = I.width,
        pe = I.height;
      let le = n.COLOR_BUFFER_BIT;
      const he = [],
        Ie = I.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        ge = i.get(I),
        Ae = I.isWebGLMultipleRenderTargets === !0;
      if (Ae)
        for (let F = 0; F < T.length; F++)
          t.bindFramebuffer(n.FRAMEBUFFER, ge.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + F,
              n.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(n.FRAMEBUFFER, ge.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + F,
              n.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(n.READ_FRAMEBUFFER, ge.__webglMultisampledFramebuffer),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ge.__webglFramebuffer);
      for (let F = 0; F < T.length; F++) {
        he.push(n.COLOR_ATTACHMENT0 + F), I.depthBuffer && he.push(Ie);
        const fe =
          ge.__ignoreDepthValues !== void 0 ? ge.__ignoreDepthValues : !1;
        if (
          (fe === !1 &&
            (I.depthBuffer && (le |= n.DEPTH_BUFFER_BIT),
            I.stencilBuffer && (le |= n.STENCIL_BUFFER_BIT)),
          Ae &&
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              ge.__webglColorRenderbuffer[F]
            ),
          fe === !0 &&
            (n.invalidateFramebuffer(n.READ_FRAMEBUFFER, [Ie]),
            n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [Ie])),
          Ae)
        ) {
          const ne = i.get(T[F]).__webglTexture;
          n.framebufferTexture2D(
            n.DRAW_FRAMEBUFFER,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_2D,
            ne,
            0
          );
        }
        n.blitFramebuffer(0, 0, q, pe, 0, 0, q, pe, le, n.NEAREST),
          p && n.invalidateFramebuffer(n.READ_FRAMEBUFFER, he);
      }
      if (
        (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        Ae)
      )
        for (let F = 0; F < T.length; F++) {
          t.bindFramebuffer(n.FRAMEBUFFER, ge.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + F,
              n.RENDERBUFFER,
              ge.__webglColorRenderbuffer[F]
            );
          const fe = i.get(T[F]).__webglTexture;
          t.bindFramebuffer(n.FRAMEBUFFER, ge.__webglFramebuffer),
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + F,
              n.TEXTURE_2D,
              fe,
              0
            );
        }
      t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ge.__webglMultisampledFramebuffer);
    }
  }
  function Xe(I) {
    return Math.min(f, I.samples);
  }
  function it(I) {
    const T = i.get(I);
    return (
      a &&
      I.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      T.__useRenderToTexture !== !1
    );
  }
  function Pt(I) {
    const T = o.render.frame;
    v.get(I) !== T && (v.set(I, T), I.update());
  }
  function Ut(I, T) {
    const q = I.colorSpace,
      pe = I.format,
      le = I.type;
    return (
      I.isCompressedTexture === !0 ||
        I.isVideoTexture === !0 ||
        I.format === nd ||
        (q !== Vt &&
          q !== In &&
          (lt.getTransfer(q) === xt
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && pe === Pn
                ? ((I.format = nd),
                  (I.minFilter = zt),
                  (I.generateMipmaps = !1))
                : (T = hv.sRGBToLinear(T))
              : (pe !== Pn || le !== Tr) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                q
              ))),
      T
    );
  }
  (this.allocateTextureUnit = W),
    (this.resetTextureUnits = te),
    (this.setTexture2D = G),
    (this.setTexture2DArray = z),
    (this.setTexture3D = V),
    (this.setTextureCube = _e),
    (this.rebindTextures = He),
    (this.setupRenderTarget = Ve),
    (this.updateRenderTargetMipmap = _t),
    (this.updateMultisampleRenderTarget = qe),
    (this.setupDepthRenderbuffer = De),
    (this.setupFrameBufferTexture = Ye),
    (this.useMultisampledRTT = it);
}
function FA(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = In) {
    let a;
    const l = lt.getTransfer(o);
    if (s === Tr) return n.UNSIGNED_BYTE;
    if (s === nv) return n.UNSIGNED_SHORT_4_4_4_4;
    if (s === iv) return n.UNSIGNED_SHORT_5_5_5_1;
    if (s === rE) return n.BYTE;
    if (s === sE) return n.SHORT;
    if (s === ah) return n.UNSIGNED_SHORT;
    if (s === tv) return n.INT;
    if (s === dr) return n.UNSIGNED_INT;
    if (s === jn) return n.FLOAT;
    if (s === ki)
      return i
        ? n.HALF_FLOAT
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === oE) return n.ALPHA;
    if (s === Pn) return n.RGBA;
    if (s === aE) return n.LUMINANCE;
    if (s === lE) return n.LUMINANCE_ALPHA;
    if (s === ts) return n.DEPTH_COMPONENT;
    if (s === ho) return n.DEPTH_STENCIL;
    if (s === nd)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === rv) return n.RED;
    if (s === sv) return n.RED_INTEGER;
    if (s === cE) return n.RG;
    if (s === ov) return n.RG_INTEGER;
    if (s === av) return n.RGBA_INTEGER;
    if (s === gu || s === _u || s === vu || s === yu)
      if (l === xt)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === gu) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === _u) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === vu) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === yu) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === gu) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === _u) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === vu) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === yu) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Gp || s === Wp || s === Xp || s === jp)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === Gp) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Wp) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Xp) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === jp) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === uE)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === Yp || s === qp)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === Yp)
          return l === xt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === qp)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === Kp ||
      s === Zp ||
      s === $p ||
      s === Qp ||
      s === Jp ||
      s === em ||
      s === tm ||
      s === nm ||
      s === im ||
      s === rm ||
      s === sm ||
      s === om ||
      s === am ||
      s === lm
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === Kp)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Zp)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === $p)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === Qp)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Jp)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === em)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === tm)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === nm)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === im)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === rm)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === sm)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === om)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === am)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === lm)
          return l === xt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === xu || s === cm || s === um)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === xu)
          return l === xt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === cm) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === um) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (s === fE || s === fm || s === dm || s === hm)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === xu) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === fm) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === dm) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === hm) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === es
      ? i
        ? n.UNSIGNED_INT_24_8
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
      ? n[s]
      : null;
  }
  return { convert: r };
}
class kA extends pn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class $r extends Ct {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const BA = { type: "move" };
class Wu {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new $r()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new $r()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new B()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new B())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new $r()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new B()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new B())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const x of e.hand.values()) {
          const m = t.getJointPose(x, i),
            h = this._getHandJoint(c, x);
          m !== null &&
            (h.matrix.fromArray(m.transform.matrix),
            h.matrix.decompose(h.position, h.rotation, h.scale),
            (h.matrixWorldNeedsUpdate = !0),
            (h.jointRadius = m.radius)),
            (h.visible = m !== null);
        }
        const u = c.joints["index-finger-tip"],
          f = c.joints["thumb-tip"],
          d = u.position.distanceTo(f.position),
          p = 0.02,
          v = 0.005;
        c.inputState.pinching && d > p + v
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            d <= p - v &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(BA)));
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new $r();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class zA extends tn {
  constructor(e, t, i, r, s, o, a, l, c, u) {
    if (((u = u !== void 0 ? u : ts), u !== ts && u !== ho))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && u === ts && (i = dr),
      i === void 0 && u === ho && (i = es),
      super(null, r, s, o, a, l, u, i, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : qt),
      (this.minFilter = l !== void 0 ? l : qt),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class HA extends ds {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      c = null,
      u = null,
      f = null,
      d = null,
      p = null,
      v = null;
    const x = t.getContextAttributes();
    let m = null,
      h = null;
    const _ = [],
      g = [],
      E = new pn();
    E.layers.enable(1), (E.viewport = new gt());
    const w = new pn();
    w.layers.enable(2), (w.viewport = new gt());
    const L = [E, w],
      A = new kA();
    A.layers.enable(1), A.layers.enable(2);
    let U = null,
      M = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (z) {
        let V = _[z];
        return (
          V === void 0 && ((V = new Wu()), (_[z] = V)), V.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (z) {
        let V = _[z];
        return V === void 0 && ((V = new Wu()), (_[z] = V)), V.getGripSpace();
      }),
      (this.getHand = function (z) {
        let V = _[z];
        return V === void 0 && ((V = new Wu()), (_[z] = V)), V.getHandSpace();
      });
    function b(z) {
      const V = g.indexOf(z.inputSource);
      if (V === -1) return;
      const _e = _[V];
      _e !== void 0 &&
        (_e.update(z.inputSource, z.frame, c || o),
        _e.dispatchEvent({ type: z.type, data: z.inputSource }));
    }
    function $() {
      r.removeEventListener("select", b),
        r.removeEventListener("selectstart", b),
        r.removeEventListener("selectend", b),
        r.removeEventListener("squeeze", b),
        r.removeEventListener("squeezestart", b),
        r.removeEventListener("squeezeend", b),
        r.removeEventListener("end", $),
        r.removeEventListener("inputsourceschange", J);
      for (let z = 0; z < _.length; z++) {
        const V = g[z];
        V !== null && ((g[z] = null), _[z].disconnect(V));
      }
      (U = null),
        (M = null),
        e.setRenderTarget(m),
        (p = null),
        (d = null),
        (f = null),
        (r = null),
        (h = null),
        G.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (z) {
      (s = z),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (z) {
        (a = z),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || o;
      }),
      (this.setReferenceSpace = function (z) {
        c = z;
      }),
      (this.getBaseLayer = function () {
        return d !== null ? d : p;
      }),
      (this.getBinding = function () {
        return f;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (z) {
        if (((r = z), r !== null)) {
          if (
            ((m = e.getRenderTarget()),
            r.addEventListener("select", b),
            r.addEventListener("selectstart", b),
            r.addEventListener("selectend", b),
            r.addEventListener("squeeze", b),
            r.addEventListener("squeezestart", b),
            r.addEventListener("squeezeend", b),
            r.addEventListener("end", $),
            r.addEventListener("inputsourceschange", J),
            x.xrCompatible !== !0 && (await t.makeXRCompatible()),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const V = {
              antialias: r.renderState.layers === void 0 ? x.antialias : !0,
              alpha: !0,
              depth: x.depth,
              stencil: x.stencil,
              framebufferScaleFactor: s,
            };
            (p = new XRWebGLLayer(r, t, V)),
              r.updateRenderState({ baseLayer: p }),
              (h = new ls(p.framebufferWidth, p.framebufferHeight, {
                format: Pn,
                type: Tr,
                colorSpace: e.outputColorSpace,
                stencilBuffer: x.stencil,
              }));
          } else {
            let V = null,
              _e = null,
              ve = null;
            x.depth &&
              ((ve = x.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (V = x.stencil ? ho : ts),
              (_e = x.stencil ? es : dr));
            const we = {
              colorFormat: t.RGBA8,
              depthFormat: ve,
              scaleFactor: s,
            };
            (f = new XRWebGLBinding(r, t)),
              (d = f.createProjectionLayer(we)),
              r.updateRenderState({ layers: [d] }),
              (h = new ls(d.textureWidth, d.textureHeight, {
                format: Pn,
                type: Tr,
                depthTexture: new zA(
                  d.textureWidth,
                  d.textureHeight,
                  _e,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  V
                ),
                stencilBuffer: x.stencil,
                colorSpace: e.outputColorSpace,
                samples: x.antialias ? 4 : 0,
              }));
            const ye = e.properties.get(h);
            ye.__ignoreDepthValues = d.ignoreDepthValues;
          }
          (h.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await r.requestReferenceSpace(a)),
            G.setContext(r),
            G.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      });
    function J(z) {
      for (let V = 0; V < z.removed.length; V++) {
        const _e = z.removed[V],
          ve = g.indexOf(_e);
        ve >= 0 && ((g[ve] = null), _[ve].disconnect(_e));
      }
      for (let V = 0; V < z.added.length; V++) {
        const _e = z.added[V];
        let ve = g.indexOf(_e);
        if (ve === -1) {
          for (let ye = 0; ye < _.length; ye++)
            if (ye >= g.length) {
              g.push(_e), (ve = ye);
              break;
            } else if (g[ye] === null) {
              (g[ye] = _e), (ve = ye);
              break;
            }
          if (ve === -1) break;
        }
        const we = _[ve];
        we && we.connect(_e);
      }
    }
    const se = new B(),
      H = new B();
    function Q(z, V, _e) {
      se.setFromMatrixPosition(V.matrixWorld),
        H.setFromMatrixPosition(_e.matrixWorld);
      const ve = se.distanceTo(H),
        we = V.projectionMatrix.elements,
        ye = _e.projectionMatrix.elements,
        ke = we[14] / (we[10] - 1),
        Ne = we[14] / (we[10] + 1),
        We = (we[9] + 1) / we[5],
        pt = (we[9] - 1) / we[5],
        Ye = (we[8] - 1) / we[0],
        j = (ye[8] + 1) / ye[0],
        kt = ke * Ye,
        De = ke * j,
        He = ve / (-Ye + j),
        Ve = He * -Ye;
      V.matrixWorld.decompose(z.position, z.quaternion, z.scale),
        z.translateX(Ve),
        z.translateZ(He),
        z.matrixWorld.compose(z.position, z.quaternion, z.scale),
        z.matrixWorldInverse.copy(z.matrixWorld).invert();
      const _t = ke + He,
        qe = Ne + He,
        Xe = kt - Ve,
        it = De + (ve - Ve),
        Pt = ((We * Ne) / qe) * _t,
        Ut = ((pt * Ne) / qe) * _t;
      z.projectionMatrix.makePerspective(Xe, it, Pt, Ut, _t, qe),
        z.projectionMatrixInverse.copy(z.projectionMatrix).invert();
    }
    function ie(z, V) {
      V === null
        ? z.matrixWorld.copy(z.matrix)
        : z.matrixWorld.multiplyMatrices(V.matrixWorld, z.matrix),
        z.matrixWorldInverse.copy(z.matrixWorld).invert();
    }
    this.updateCamera = function (z) {
      if (r === null) return;
      (A.near = w.near = E.near = z.near),
        (A.far = w.far = E.far = z.far),
        (U !== A.near || M !== A.far) &&
          (r.updateRenderState({ depthNear: A.near, depthFar: A.far }),
          (U = A.near),
          (M = A.far));
      const V = z.parent,
        _e = A.cameras;
      ie(A, V);
      for (let ve = 0; ve < _e.length; ve++) ie(_e[ve], V);
      _e.length === 2
        ? Q(A, E, w)
        : A.projectionMatrix.copy(E.projectionMatrix),
        te(z, A, V);
    };
    function te(z, V, _e) {
      _e === null
        ? z.matrix.copy(V.matrixWorld)
        : (z.matrix.copy(_e.matrixWorld),
          z.matrix.invert(),
          z.matrix.multiply(V.matrixWorld)),
        z.matrix.decompose(z.position, z.quaternion, z.scale),
        z.updateMatrixWorld(!0),
        z.projectionMatrix.copy(V.projectionMatrix),
        z.projectionMatrixInverse.copy(V.projectionMatrixInverse),
        z.isPerspectiveCamera &&
          ((z.fov = mo * 2 * Math.atan(1 / z.projectionMatrix.elements[5])),
          (z.zoom = 1));
    }
    (this.getCamera = function () {
      return A;
    }),
      (this.getFoveation = function () {
        if (!(d === null && p === null)) return l;
      }),
      (this.setFoveation = function (z) {
        (l = z),
          d !== null && (d.fixedFoveation = z),
          p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = z);
      });
    let W = null;
    function K(z, V) {
      if (((u = V.getViewerPose(c || o)), (v = V), u !== null)) {
        const _e = u.views;
        p !== null &&
          (e.setRenderTargetFramebuffer(h, p.framebuffer),
          e.setRenderTarget(h));
        let ve = !1;
        _e.length !== A.cameras.length && ((A.cameras.length = 0), (ve = !0));
        for (let we = 0; we < _e.length; we++) {
          const ye = _e[we];
          let ke = null;
          if (p !== null) ke = p.getViewport(ye);
          else {
            const We = f.getViewSubImage(d, ye);
            (ke = We.viewport),
              we === 0 &&
                (e.setRenderTargetTextures(
                  h,
                  We.colorTexture,
                  d.ignoreDepthValues ? void 0 : We.depthStencilTexture
                ),
                e.setRenderTarget(h));
          }
          let Ne = L[we];
          Ne === void 0 &&
            ((Ne = new pn()),
            Ne.layers.enable(we),
            (Ne.viewport = new gt()),
            (L[we] = Ne)),
            Ne.matrix.fromArray(ye.transform.matrix),
            Ne.matrix.decompose(Ne.position, Ne.quaternion, Ne.scale),
            Ne.projectionMatrix.fromArray(ye.projectionMatrix),
            Ne.projectionMatrixInverse.copy(Ne.projectionMatrix).invert(),
            Ne.viewport.set(ke.x, ke.y, ke.width, ke.height),
            we === 0 &&
              (A.matrix.copy(Ne.matrix),
              A.matrix.decompose(A.position, A.quaternion, A.scale)),
            ve === !0 && A.cameras.push(Ne);
        }
      }
      for (let _e = 0; _e < _.length; _e++) {
        const ve = g[_e],
          we = _[_e];
        ve !== null && we !== void 0 && we.update(ve, V, c || o);
      }
      W && W(z, V),
        V.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: V }),
        (v = null);
    }
    const G = new Mv();
    G.setAnimationLoop(K),
      (this.setAnimationLoop = function (z) {
        W = z;
      }),
      (this.dispose = function () {});
  }
}
function VA(n, e) {
  function t(m, h) {
    m.matrixAutoUpdate === !0 && m.updateMatrix(), h.value.copy(m.matrix);
  }
  function i(m, h) {
    h.color.getRGB(m.fogColor.value, xv(n)),
      h.isFog
        ? ((m.fogNear.value = h.near), (m.fogFar.value = h.far))
        : h.isFogExp2 && (m.fogDensity.value = h.density);
  }
  function r(m, h, _, g, E) {
    h.isMeshBasicMaterial || h.isMeshLambertMaterial
      ? s(m, h)
      : h.isMeshToonMaterial
      ? (s(m, h), f(m, h))
      : h.isMeshPhongMaterial
      ? (s(m, h), u(m, h))
      : h.isMeshStandardMaterial
      ? (s(m, h), d(m, h), h.isMeshPhysicalMaterial && p(m, h, E))
      : h.isMeshMatcapMaterial
      ? (s(m, h), v(m, h))
      : h.isMeshDepthMaterial
      ? s(m, h)
      : h.isMeshDistanceMaterial
      ? (s(m, h), x(m, h))
      : h.isMeshNormalMaterial
      ? s(m, h)
      : h.isLineBasicMaterial
      ? (o(m, h), h.isLineDashedMaterial && a(m, h))
      : h.isPointsMaterial
      ? l(m, h, _, g)
      : h.isSpriteMaterial
      ? c(m, h)
      : h.isShadowMaterial
      ? (m.color.value.copy(h.color), (m.opacity.value = h.opacity))
      : h.isShaderMaterial && (h.uniformsNeedUpdate = !1);
  }
  function s(m, h) {
    (m.opacity.value = h.opacity),
      h.color && m.diffuse.value.copy(h.color),
      h.emissive &&
        m.emissive.value.copy(h.emissive).multiplyScalar(h.emissiveIntensity),
      h.map && ((m.map.value = h.map), t(h.map, m.mapTransform)),
      h.alphaMap &&
        ((m.alphaMap.value = h.alphaMap), t(h.alphaMap, m.alphaMapTransform)),
      h.bumpMap &&
        ((m.bumpMap.value = h.bumpMap),
        t(h.bumpMap, m.bumpMapTransform),
        (m.bumpScale.value = h.bumpScale),
        h.side === An && (m.bumpScale.value *= -1)),
      h.normalMap &&
        ((m.normalMap.value = h.normalMap),
        t(h.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(h.normalScale),
        h.side === An && m.normalScale.value.negate()),
      h.displacementMap &&
        ((m.displacementMap.value = h.displacementMap),
        t(h.displacementMap, m.displacementMapTransform),
        (m.displacementScale.value = h.displacementScale),
        (m.displacementBias.value = h.displacementBias)),
      h.emissiveMap &&
        ((m.emissiveMap.value = h.emissiveMap),
        t(h.emissiveMap, m.emissiveMapTransform)),
      h.specularMap &&
        ((m.specularMap.value = h.specularMap),
        t(h.specularMap, m.specularMapTransform)),
      h.alphaTest > 0 && (m.alphaTest.value = h.alphaTest);
    const _ = e.get(h).envMap;
    if (
      (_ &&
        ((m.envMap.value = _),
        (m.flipEnvMap.value =
          _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
        (m.reflectivity.value = h.reflectivity),
        (m.ior.value = h.ior),
        (m.refractionRatio.value = h.refractionRatio)),
      h.lightMap)
    ) {
      m.lightMap.value = h.lightMap;
      const g = n._useLegacyLights === !0 ? Math.PI : 1;
      (m.lightMapIntensity.value = h.lightMapIntensity * g),
        t(h.lightMap, m.lightMapTransform);
    }
    h.aoMap &&
      ((m.aoMap.value = h.aoMap),
      (m.aoMapIntensity.value = h.aoMapIntensity),
      t(h.aoMap, m.aoMapTransform));
  }
  function o(m, h) {
    m.diffuse.value.copy(h.color),
      (m.opacity.value = h.opacity),
      h.map && ((m.map.value = h.map), t(h.map, m.mapTransform));
  }
  function a(m, h) {
    (m.dashSize.value = h.dashSize),
      (m.totalSize.value = h.dashSize + h.gapSize),
      (m.scale.value = h.scale);
  }
  function l(m, h, _, g) {
    m.diffuse.value.copy(h.color),
      (m.opacity.value = h.opacity),
      (m.size.value = h.size * _),
      (m.scale.value = g * 0.5),
      h.map && ((m.map.value = h.map), t(h.map, m.uvTransform)),
      h.alphaMap &&
        ((m.alphaMap.value = h.alphaMap), t(h.alphaMap, m.alphaMapTransform)),
      h.alphaTest > 0 && (m.alphaTest.value = h.alphaTest);
  }
  function c(m, h) {
    m.diffuse.value.copy(h.color),
      (m.opacity.value = h.opacity),
      (m.rotation.value = h.rotation),
      h.map && ((m.map.value = h.map), t(h.map, m.mapTransform)),
      h.alphaMap &&
        ((m.alphaMap.value = h.alphaMap), t(h.alphaMap, m.alphaMapTransform)),
      h.alphaTest > 0 && (m.alphaTest.value = h.alphaTest);
  }
  function u(m, h) {
    m.specular.value.copy(h.specular),
      (m.shininess.value = Math.max(h.shininess, 1e-4));
  }
  function f(m, h) {
    h.gradientMap && (m.gradientMap.value = h.gradientMap);
  }
  function d(m, h) {
    (m.metalness.value = h.metalness),
      h.metalnessMap &&
        ((m.metalnessMap.value = h.metalnessMap),
        t(h.metalnessMap, m.metalnessMapTransform)),
      (m.roughness.value = h.roughness),
      h.roughnessMap &&
        ((m.roughnessMap.value = h.roughnessMap),
        t(h.roughnessMap, m.roughnessMapTransform)),
      e.get(h).envMap && (m.envMapIntensity.value = h.envMapIntensity);
  }
  function p(m, h, _) {
    (m.ior.value = h.ior),
      h.sheen > 0 &&
        (m.sheenColor.value.copy(h.sheenColor).multiplyScalar(h.sheen),
        (m.sheenRoughness.value = h.sheenRoughness),
        h.sheenColorMap &&
          ((m.sheenColorMap.value = h.sheenColorMap),
          t(h.sheenColorMap, m.sheenColorMapTransform)),
        h.sheenRoughnessMap &&
          ((m.sheenRoughnessMap.value = h.sheenRoughnessMap),
          t(h.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
      h.clearcoat > 0 &&
        ((m.clearcoat.value = h.clearcoat),
        (m.clearcoatRoughness.value = h.clearcoatRoughness),
        h.clearcoatMap &&
          ((m.clearcoatMap.value = h.clearcoatMap),
          t(h.clearcoatMap, m.clearcoatMapTransform)),
        h.clearcoatRoughnessMap &&
          ((m.clearcoatRoughnessMap.value = h.clearcoatRoughnessMap),
          t(h.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        h.clearcoatNormalMap &&
          ((m.clearcoatNormalMap.value = h.clearcoatNormalMap),
          t(h.clearcoatNormalMap, m.clearcoatNormalMapTransform),
          m.clearcoatNormalScale.value.copy(h.clearcoatNormalScale),
          h.side === An && m.clearcoatNormalScale.value.negate())),
      h.iridescence > 0 &&
        ((m.iridescence.value = h.iridescence),
        (m.iridescenceIOR.value = h.iridescenceIOR),
        (m.iridescenceThicknessMinimum.value = h.iridescenceThicknessRange[0]),
        (m.iridescenceThicknessMaximum.value = h.iridescenceThicknessRange[1]),
        h.iridescenceMap &&
          ((m.iridescenceMap.value = h.iridescenceMap),
          t(h.iridescenceMap, m.iridescenceMapTransform)),
        h.iridescenceThicknessMap &&
          ((m.iridescenceThicknessMap.value = h.iridescenceThicknessMap),
          t(h.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
      h.transmission > 0 &&
        ((m.transmission.value = h.transmission),
        (m.transmissionSamplerMap.value = _.texture),
        m.transmissionSamplerSize.value.set(_.width, _.height),
        h.transmissionMap &&
          ((m.transmissionMap.value = h.transmissionMap),
          t(h.transmissionMap, m.transmissionMapTransform)),
        (m.thickness.value = h.thickness),
        h.thicknessMap &&
          ((m.thicknessMap.value = h.thicknessMap),
          t(h.thicknessMap, m.thicknessMapTransform)),
        (m.attenuationDistance.value = h.attenuationDistance),
        m.attenuationColor.value.copy(h.attenuationColor)),
      h.anisotropy > 0 &&
        (m.anisotropyVector.value.set(
          h.anisotropy * Math.cos(h.anisotropyRotation),
          h.anisotropy * Math.sin(h.anisotropyRotation)
        ),
        h.anisotropyMap &&
          ((m.anisotropyMap.value = h.anisotropyMap),
          t(h.anisotropyMap, m.anisotropyMapTransform))),
      (m.specularIntensity.value = h.specularIntensity),
      m.specularColor.value.copy(h.specularColor),
      h.specularColorMap &&
        ((m.specularColorMap.value = h.specularColorMap),
        t(h.specularColorMap, m.specularColorMapTransform)),
      h.specularIntensityMap &&
        ((m.specularIntensityMap.value = h.specularIntensityMap),
        t(h.specularIntensityMap, m.specularIntensityMapTransform));
  }
  function v(m, h) {
    h.matcap && (m.matcap.value = h.matcap);
  }
  function x(m, h) {
    const _ = e.get(h).light;
    m.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
      (m.nearDistance.value = _.shadow.camera.near),
      (m.farDistance.value = _.shadow.camera.far);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function GA(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(_, g) {
    const E = g.program;
    i.uniformBlockBinding(_, E);
  }
  function c(_, g) {
    let E = r[_.id];
    E === void 0 &&
      (v(_), (E = u(_)), (r[_.id] = E), _.addEventListener("dispose", m));
    const w = g.program;
    i.updateUBOMapping(_, w);
    const L = e.render.frame;
    s[_.id] !== L && (d(_), (s[_.id] = L));
  }
  function u(_) {
    const g = f();
    _.__bindingPointIndex = g;
    const E = n.createBuffer(),
      w = _.__size,
      L = _.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, E),
      n.bufferData(n.UNIFORM_BUFFER, w, L),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, g, E),
      E
    );
  }
  function f() {
    for (let _ = 0; _ < a; _++) if (o.indexOf(_) === -1) return o.push(_), _;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function d(_) {
    const g = r[_.id],
      E = _.uniforms,
      w = _.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, g);
    for (let L = 0, A = E.length; L < A; L++) {
      const U = E[L];
      if (p(U, L, w) === !0) {
        const M = U.__offset,
          b = Array.isArray(U.value) ? U.value : [U.value];
        let $ = 0;
        for (let J = 0; J < b.length; J++) {
          const se = b[J],
            H = x(se);
          typeof se == "number"
            ? ((U.__data[0] = se),
              n.bufferSubData(n.UNIFORM_BUFFER, M + $, U.__data))
            : se.isMatrix3
            ? ((U.__data[0] = se.elements[0]),
              (U.__data[1] = se.elements[1]),
              (U.__data[2] = se.elements[2]),
              (U.__data[3] = se.elements[0]),
              (U.__data[4] = se.elements[3]),
              (U.__data[5] = se.elements[4]),
              (U.__data[6] = se.elements[5]),
              (U.__data[7] = se.elements[0]),
              (U.__data[8] = se.elements[6]),
              (U.__data[9] = se.elements[7]),
              (U.__data[10] = se.elements[8]),
              (U.__data[11] = se.elements[0]))
            : (se.toArray(U.__data, $),
              ($ += H.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        n.bufferSubData(n.UNIFORM_BUFFER, M, U.__data);
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function p(_, g, E) {
    const w = _.value;
    if (E[g] === void 0) {
      if (typeof w == "number") E[g] = w;
      else {
        const L = Array.isArray(w) ? w : [w],
          A = [];
        for (let U = 0; U < L.length; U++) A.push(L[U].clone());
        E[g] = A;
      }
      return !0;
    } else if (typeof w == "number") {
      if (E[g] !== w) return (E[g] = w), !0;
    } else {
      const L = Array.isArray(E[g]) ? E[g] : [E[g]],
        A = Array.isArray(w) ? w : [w];
      for (let U = 0; U < L.length; U++) {
        const M = L[U];
        if (M.equals(A[U]) === !1) return M.copy(A[U]), !0;
      }
    }
    return !1;
  }
  function v(_) {
    const g = _.uniforms;
    let E = 0;
    const w = 16;
    let L = 0;
    for (let A = 0, U = g.length; A < U; A++) {
      const M = g[A],
        b = { boundary: 0, storage: 0 },
        $ = Array.isArray(M.value) ? M.value : [M.value];
      for (let J = 0, se = $.length; J < se; J++) {
        const H = $[J],
          Q = x(H);
        (b.boundary += Q.boundary), (b.storage += Q.storage);
      }
      if (
        ((M.__data = new Float32Array(
          b.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (M.__offset = E),
        A > 0)
      ) {
        L = E % w;
        const J = w - L;
        L !== 0 && J - b.boundary < 0 && ((E += w - L), (M.__offset = E));
      }
      E += b.storage;
    }
    return (
      (L = E % w), L > 0 && (E += w - L), (_.__size = E), (_.__cache = {}), this
    );
  }
  function x(_) {
    const g = { boundary: 0, storage: 0 };
    return (
      typeof _ == "number"
        ? ((g.boundary = 4), (g.storage = 4))
        : _.isVector2
        ? ((g.boundary = 8), (g.storage = 8))
        : _.isVector3 || _.isColor
        ? ((g.boundary = 16), (g.storage = 12))
        : _.isVector4
        ? ((g.boundary = 16), (g.storage = 16))
        : _.isMatrix3
        ? ((g.boundary = 48), (g.storage = 48))
        : _.isMatrix4
        ? ((g.boundary = 64), (g.storage = 64))
        : _.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            _
          ),
      g
    );
  }
  function m(_) {
    const g = _.target;
    g.removeEventListener("dispose", m);
    const E = o.indexOf(g.__bindingPointIndex);
    o.splice(E, 1), n.deleteBuffer(r[g.id]), delete r[g.id], delete s[g.id];
  }
  function h() {
    for (const _ in r) n.deleteBuffer(r[_]);
    (o = []), (r = {}), (s = {});
  }
  return { bind: l, update: c, dispose: h };
}
class bv {
  constructor(e = {}) {
    const {
      canvas: t = kE(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: f = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let d;
    i !== null ? (d = i.getContextAttributes().alpha) : (d = o);
    const p = new Uint32Array(4),
      v = new Int32Array(4);
    let x = null,
      m = null;
    const h = [],
      _ = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Rt),
      (this._useLegacyLights = !1),
      (this.toneMapping = Mr),
      (this.toneMappingExposure = 1);
    const g = this;
    let E = !1,
      w = 0,
      L = 0,
      A = null,
      U = -1,
      M = null;
    const b = new gt(),
      $ = new gt();
    let J = null;
    const se = new Ke(0);
    let H = 0,
      Q = t.width,
      ie = t.height,
      te = 1,
      W = null,
      K = null;
    const G = new gt(0, 0, Q, ie),
      z = new gt(0, 0, Q, ie);
    let V = !1;
    const _e = new fh();
    let ve = !1,
      we = !1,
      ye = null;
    const ke = new tt(),
      Ne = new Ge(),
      We = new B(),
      pt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Ye() {
      return A === null ? te : 1;
    }
    let j = i;
    function kt(y, C) {
      for (let P = 0; P < y.length; P++) {
        const N = y[P],
          O = t.getContext(N, C);
        if (O !== null) return O;
      }
      return null;
    }
    try {
      const y = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: f,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${oh}`),
        t.addEventListener("webglcontextlost", oe, !1),
        t.addEventListener("webglcontextrestored", k, !1),
        t.addEventListener("webglcontextcreationerror", xe, !1),
        j === null)
      ) {
        const C = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (g.isWebGL1Renderer === !0 && C.shift(), (j = kt(C, y)), j === null)
        )
          throw kt(C)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        j instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        j.getShaderPrecisionFormat === void 0 &&
          (j.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (y) {
      throw (console.error("THREE.WebGLRenderer: " + y.message), y);
    }
    let De,
      He,
      Ve,
      _t,
      qe,
      Xe,
      it,
      Pt,
      Ut,
      I,
      T,
      q,
      pe,
      le,
      he,
      Ie,
      ge,
      Ae,
      F,
      fe,
      ne,
      Be,
      Pe,
      Le;
    function Te() {
      (De = new J1(j)),
        (He = new Y1(j, De, e)),
        De.init(He),
        (Be = new FA(j, De, He)),
        (Ve = new UA(j, De, He)),
        (_t = new nw(j)),
        (qe = new SA()),
        (Xe = new OA(j, De, Ve, qe, He, Be, _t)),
        (it = new K1(g)),
        (Pt = new Q1(g)),
        (Ut = new dM(j, He)),
        (Pe = new X1(j, De, Ut, He)),
        (I = new ew(j, Ut, _t, Pe)),
        (T = new ow(j, I, Ut, _t)),
        (F = new sw(j, He, Xe)),
        (Ie = new q1(qe)),
        (q = new xA(g, it, Pt, De, He, Pe, Ie)),
        (pe = new VA(g, qe)),
        (le = new MA()),
        (he = new CA(De, He)),
        (Ae = new W1(g, it, Pt, Ve, T, d, l)),
        (ge = new DA(g, T, He)),
        (Le = new GA(j, _t, He, Ve)),
        (fe = new j1(j, De, _t, He)),
        (ne = new tw(j, De, _t, He)),
        (_t.programs = q.programs),
        (g.capabilities = He),
        (g.extensions = De),
        (g.properties = qe),
        (g.renderLists = le),
        (g.shadowMap = ge),
        (g.state = Ve),
        (g.info = _t);
    }
    Te();
    const Re = new HA(g, j);
    (this.xr = Re),
      (this.getContext = function () {
        return j;
      }),
      (this.getContextAttributes = function () {
        return j.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const y = De.get("WEBGL_lose_context");
        y && y.loseContext();
      }),
      (this.forceContextRestore = function () {
        const y = De.get("WEBGL_lose_context");
        y && y.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return te;
      }),
      (this.setPixelRatio = function (y) {
        y !== void 0 && ((te = y), this.setSize(Q, ie, !1));
      }),
      (this.getSize = function (y) {
        return y.set(Q, ie);
      }),
      (this.setSize = function (y, C, P = !0) {
        if (Re.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Q = y),
          (ie = C),
          (t.width = Math.floor(y * te)),
          (t.height = Math.floor(C * te)),
          P === !0 && ((t.style.width = y + "px"), (t.style.height = C + "px")),
          this.setViewport(0, 0, y, C);
      }),
      (this.getDrawingBufferSize = function (y) {
        return y.set(Q * te, ie * te).floor();
      }),
      (this.setDrawingBufferSize = function (y, C, P) {
        (Q = y),
          (ie = C),
          (te = P),
          (t.width = Math.floor(y * P)),
          (t.height = Math.floor(C * P)),
          this.setViewport(0, 0, y, C);
      }),
      (this.getCurrentViewport = function (y) {
        return y.copy(b);
      }),
      (this.getViewport = function (y) {
        return y.copy(G);
      }),
      (this.setViewport = function (y, C, P, N) {
        y.isVector4 ? G.set(y.x, y.y, y.z, y.w) : G.set(y, C, P, N),
          Ve.viewport(b.copy(G).multiplyScalar(te).floor());
      }),
      (this.getScissor = function (y) {
        return y.copy(z);
      }),
      (this.setScissor = function (y, C, P, N) {
        y.isVector4 ? z.set(y.x, y.y, y.z, y.w) : z.set(y, C, P, N),
          Ve.scissor($.copy(z).multiplyScalar(te).floor());
      }),
      (this.getScissorTest = function () {
        return V;
      }),
      (this.setScissorTest = function (y) {
        Ve.setScissorTest((V = y));
      }),
      (this.setOpaqueSort = function (y) {
        W = y;
      }),
      (this.setTransparentSort = function (y) {
        K = y;
      }),
      (this.getClearColor = function (y) {
        return y.copy(Ae.getClearColor());
      }),
      (this.setClearColor = function () {
        Ae.setClearColor.apply(Ae, arguments);
      }),
      (this.getClearAlpha = function () {
        return Ae.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Ae.setClearAlpha.apply(Ae, arguments);
      }),
      (this.clear = function (y = !0, C = !0, P = !0) {
        let N = 0;
        if (y) {
          let O = !1;
          if (A !== null) {
            const Y = A.texture.format;
            O = Y === av || Y === ov || Y === sv;
          }
          if (O) {
            const Y = A.texture.type,
              X =
                Y === Tr ||
                Y === dr ||
                Y === ah ||
                Y === es ||
                Y === nv ||
                Y === iv,
              Z = Ae.getClearColor(),
              re = Ae.getClearAlpha(),
              ae = Z.r,
              de = Z.g,
              Se = Z.b;
            X
              ? ((p[0] = ae),
                (p[1] = de),
                (p[2] = Se),
                (p[3] = re),
                j.clearBufferuiv(j.COLOR, 0, p))
              : ((v[0] = ae),
                (v[1] = de),
                (v[2] = Se),
                (v[3] = re),
                j.clearBufferiv(j.COLOR, 0, v));
          } else N |= j.COLOR_BUFFER_BIT;
        }
        C && (N |= j.DEPTH_BUFFER_BIT),
          P &&
            ((N |= j.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          j.clear(N);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", oe, !1),
          t.removeEventListener("webglcontextrestored", k, !1),
          t.removeEventListener("webglcontextcreationerror", xe, !1),
          le.dispose(),
          he.dispose(),
          qe.dispose(),
          it.dispose(),
          Pt.dispose(),
          T.dispose(),
          Pe.dispose(),
          Le.dispose(),
          q.dispose(),
          Re.dispose(),
          Re.removeEventListener("sessionstart", yn),
          Re.removeEventListener("sessionend", dt),
          ye && (ye.dispose(), (ye = null)),
          $t.stop();
      });
    function oe(y) {
      y.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (E = !0);
    }
    function k() {
      console.log("THREE.WebGLRenderer: Context Restored."), (E = !1);
      const y = _t.autoReset,
        C = ge.enabled,
        P = ge.autoUpdate,
        N = ge.needsUpdate,
        O = ge.type;
      Te(),
        (_t.autoReset = y),
        (ge.enabled = C),
        (ge.autoUpdate = P),
        (ge.needsUpdate = N),
        (ge.type = O);
    }
    function xe(y) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        y.statusMessage
      );
    }
    function ce(y) {
      const C = y.target;
      C.removeEventListener("dispose", ce), ee(C);
    }
    function ee(y) {
      me(y), qe.remove(y);
    }
    function me(y) {
      const C = qe.get(y).programs;
      C !== void 0 &&
        (C.forEach(function (P) {
          q.releaseProgram(P);
        }),
        y.isShaderMaterial && q.releaseShaderCache(y));
    }
    this.renderBufferDirect = function (y, C, P, N, O, Y) {
      C === null && (C = pt);
      const X = O.isMesh && O.matrixWorld.determinant() < 0,
        Z = S(y, C, P, N, O);
      Ve.setMaterial(N, X);
      let re = P.index,
        ae = 1;
      if (N.wireframe === !0) {
        if (((re = I.getWireframeAttribute(P)), re === void 0)) return;
        ae = 2;
      }
      const de = P.drawRange,
        Se = P.attributes.position;
      let Ee = de.start * ae,
        be = (de.start + de.count) * ae;
      Y !== null &&
        ((Ee = Math.max(Ee, Y.start * ae)),
        (be = Math.min(be, (Y.start + Y.count) * ae))),
        re !== null
          ? ((Ee = Math.max(Ee, 0)), (be = Math.min(be, re.count)))
          : Se != null &&
            ((Ee = Math.max(Ee, 0)), (be = Math.min(be, Se.count)));
      const Oe = be - Ee;
      if (Oe < 0 || Oe === 1 / 0) return;
      Pe.setup(O, N, Z, P, re);
      let at,
        je = fe;
      if (
        (re !== null && ((at = Ut.get(re)), (je = ne), je.setIndex(at)),
        O.isMesh)
      )
        N.wireframe === !0
          ? (Ve.setLineWidth(N.wireframeLinewidth * Ye()), je.setMode(j.LINES))
          : je.setMode(j.TRIANGLES);
      else if (O.isLine) {
        let ze = N.linewidth;
        ze === void 0 && (ze = 1),
          Ve.setLineWidth(ze * Ye()),
          O.isLineSegments
            ? je.setMode(j.LINES)
            : O.isLineLoop
            ? je.setMode(j.LINE_LOOP)
            : je.setMode(j.LINE_STRIP);
      } else
        O.isPoints
          ? je.setMode(j.POINTS)
          : O.isSprite && je.setMode(j.TRIANGLES);
      if (O.isInstancedMesh) je.renderInstances(Ee, Oe, O.count);
      else if (P.isInstancedBufferGeometry) {
        const ze = P._maxInstanceCount !== void 0 ? P._maxInstanceCount : 1 / 0,
          ct = Math.min(P.instanceCount, ze);
        je.renderInstances(Ee, Oe, ct);
      } else je.render(Ee, Oe);
    };
    function Ue(y, C, P) {
      y.transparent === !0 && y.side === oi && y.forceSinglePass === !1
        ? ((y.side = An),
          (y.needsUpdate = !0),
          $e(y, C, P),
          (y.side = Xi),
          (y.needsUpdate = !0),
          $e(y, C, P),
          (y.side = oi))
        : $e(y, C, P);
    }
    (this.compile = function (y, C, P = null) {
      P === null && (P = y),
        (m = he.get(P)),
        m.init(),
        _.push(m),
        P.traverseVisible(function (O) {
          O.isLight &&
            O.layers.test(C.layers) &&
            (m.pushLight(O), O.castShadow && m.pushShadow(O));
        }),
        y !== P &&
          y.traverseVisible(function (O) {
            O.isLight &&
              O.layers.test(C.layers) &&
              (m.pushLight(O), O.castShadow && m.pushShadow(O));
          }),
        m.setupLights(g._useLegacyLights);
      const N = new Set();
      return (
        y.traverse(function (O) {
          const Y = O.material;
          if (Y)
            if (Array.isArray(Y))
              for (let X = 0; X < Y.length; X++) {
                const Z = Y[X];
                Ue(Z, P, O), N.add(Z);
              }
            else Ue(Y, P, O), N.add(Y);
        }),
        _.pop(),
        (m = null),
        N
      );
    }),
      (this.compileAsync = function (y, C, P = null) {
        const N = this.compile(y, C, P);
        return new Promise((O) => {
          function Y() {
            if (
              (N.forEach(function (X) {
                qe.get(X).currentProgram.isReady() && N.delete(X);
              }),
              N.size === 0)
            ) {
              O(y);
              return;
            }
            setTimeout(Y, 10);
          }
          De.get("KHR_parallel_shader_compile") !== null
            ? Y()
            : setTimeout(Y, 10);
        });
      });
    let Je = null;
    function It(y) {
      Je && Je(y);
    }
    function yn() {
      $t.stop();
    }
    function dt() {
      $t.start();
    }
    const $t = new Mv();
    $t.setAnimationLoop(It),
      typeof self < "u" && $t.setContext(self),
      (this.setAnimationLoop = function (y) {
        (Je = y), Re.setAnimationLoop(y), y === null ? $t.stop() : $t.start();
      }),
      Re.addEventListener("sessionstart", yn),
      Re.addEventListener("sessionend", dt),
      (this.render = function (y, C) {
        if (C !== void 0 && C.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (E === !0) return;
        y.matrixWorldAutoUpdate === !0 && y.updateMatrixWorld(),
          C.parent === null &&
            C.matrixWorldAutoUpdate === !0 &&
            C.updateMatrixWorld(),
          Re.enabled === !0 &&
            Re.isPresenting === !0 &&
            (Re.cameraAutoUpdate === !0 && Re.updateCamera(C),
            (C = Re.getCamera())),
          y.isScene === !0 && y.onBeforeRender(g, y, C, A),
          (m = he.get(y, _.length)),
          m.init(),
          _.push(m),
          ke.multiplyMatrices(C.projectionMatrix, C.matrixWorldInverse),
          _e.setFromProjectionMatrix(ke),
          (we = this.localClippingEnabled),
          (ve = Ie.init(this.clippingPlanes, we)),
          (x = le.get(y, h.length)),
          x.init(),
          h.push(x),
          Bn(y, C, 0, g.sortObjects),
          x.finish(),
          g.sortObjects === !0 && x.sort(W, K),
          this.info.render.frame++,
          ve === !0 && Ie.beginShadows();
        const P = m.state.shadowsArray;
        if (
          (ge.render(P, y, C),
          ve === !0 && Ie.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          Ae.render(x, y),
          m.setupLights(g._useLegacyLights),
          C.isArrayCamera)
        ) {
          const N = C.cameras;
          for (let O = 0, Y = N.length; O < Y; O++) {
            const X = N[O];
            Or(x, y, X, X.viewport);
          }
        } else Or(x, y, C);
        A !== null &&
          (Xe.updateMultisampleRenderTarget(A), Xe.updateRenderTargetMipmap(A)),
          y.isScene === !0 && y.onAfterRender(g, y, C),
          Pe.resetDefaultState(),
          (U = -1),
          (M = null),
          _.pop(),
          _.length > 0 ? (m = _[_.length - 1]) : (m = null),
          h.pop(),
          h.length > 0 ? (x = h[h.length - 1]) : (x = null);
      });
    function Bn(y, C, P, N) {
      if (y.visible === !1) return;
      if (y.layers.test(C.layers)) {
        if (y.isGroup) P = y.renderOrder;
        else if (y.isLOD) y.autoUpdate === !0 && y.update(C);
        else if (y.isLight) m.pushLight(y), y.castShadow && m.pushShadow(y);
        else if (y.isSprite) {
          if (!y.frustumCulled || _e.intersectsSprite(y)) {
            N && We.setFromMatrixPosition(y.matrixWorld).applyMatrix4(ke);
            const X = T.update(y),
              Z = y.material;
            Z.visible && x.push(y, X, Z, P, We.z, null);
          }
        } else if (
          (y.isMesh || y.isLine || y.isPoints) &&
          (!y.frustumCulled || _e.intersectsObject(y))
        ) {
          const X = T.update(y),
            Z = y.material;
          if (
            (N &&
              (y.boundingSphere !== void 0
                ? (y.boundingSphere === null && y.computeBoundingSphere(),
                  We.copy(y.boundingSphere.center))
                : (X.boundingSphere === null && X.computeBoundingSphere(),
                  We.copy(X.boundingSphere.center)),
              We.applyMatrix4(y.matrixWorld).applyMatrix4(ke)),
            Array.isArray(Z))
          ) {
            const re = X.groups;
            for (let ae = 0, de = re.length; ae < de; ae++) {
              const Se = re[ae],
                Ee = Z[Se.materialIndex];
              Ee && Ee.visible && x.push(y, X, Ee, P, We.z, Se);
            }
          } else Z.visible && x.push(y, X, Z, P, We.z, null);
        }
      }
      const Y = y.children;
      for (let X = 0, Z = Y.length; X < Z; X++) Bn(Y[X], C, P, N);
    }
    function Or(y, C, P, N) {
      const O = y.opaque,
        Y = y.transmissive,
        X = y.transparent;
      m.setupLightsView(P),
        ve === !0 && Ie.setGlobalState(g.clippingPlanes, P),
        Y.length > 0 && Gc(O, Y, C, P),
        N && Ve.viewport(b.copy(N)),
        O.length > 0 && di(O, C, P),
        Y.length > 0 && di(Y, C, P),
        X.length > 0 && di(X, C, P),
        Ve.buffers.depth.setTest(!0),
        Ve.buffers.depth.setMask(!0),
        Ve.buffers.color.setMask(!0),
        Ve.setPolygonOffset(!1);
    }
    function Gc(y, C, P, N) {
      if ((P.isScene === !0 ? P.overrideMaterial : null) !== null) return;
      const Y = He.isWebGL2;
      ye === null &&
        (ye = new ls(1, 1, {
          generateMipmaps: !0,
          type: De.has("EXT_color_buffer_half_float") ? ki : Tr,
          minFilter: br,
          samples: Y ? 4 : 0,
        })),
        g.getDrawingBufferSize(Ne),
        Y ? ye.setSize(Ne.x, Ne.y) : ye.setSize(Sc(Ne.x), Sc(Ne.y));
      const X = g.getRenderTarget();
      g.setRenderTarget(ye),
        g.getClearColor(se),
        (H = g.getClearAlpha()),
        H < 1 && g.setClearColor(16777215, 0.5),
        g.clear();
      const Z = g.toneMapping;
      (g.toneMapping = Mr),
        di(y, P, N),
        Xe.updateMultisampleRenderTarget(ye),
        Xe.updateRenderTargetMipmap(ye);
      let re = !1;
      for (let ae = 0, de = C.length; ae < de; ae++) {
        const Se = C[ae],
          Ee = Se.object,
          be = Se.geometry,
          Oe = Se.material,
          at = Se.group;
        if (Oe.side === oi && Ee.layers.test(N.layers)) {
          const je = Oe.side;
          (Oe.side = An),
            (Oe.needsUpdate = !0),
            qi(Ee, P, N, be, Oe, at),
            (Oe.side = je),
            (Oe.needsUpdate = !0),
            (re = !0);
        }
      }
      re === !0 &&
        (Xe.updateMultisampleRenderTarget(ye), Xe.updateRenderTargetMipmap(ye)),
        g.setRenderTarget(X),
        g.setClearColor(se, H),
        (g.toneMapping = Z);
    }
    function di(y, C, P) {
      const N = C.isScene === !0 ? C.overrideMaterial : null;
      for (let O = 0, Y = y.length; O < Y; O++) {
        const X = y[O],
          Z = X.object,
          re = X.geometry,
          ae = N === null ? X.material : N,
          de = X.group;
        Z.layers.test(P.layers) && qi(Z, C, P, re, ae, de);
      }
    }
    function qi(y, C, P, N, O, Y) {
      y.onBeforeRender(g, C, P, N, O, Y),
        y.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, y.matrixWorld),
        y.normalMatrix.getNormalMatrix(y.modelViewMatrix),
        O.onBeforeRender(g, C, P, N, y, Y),
        O.transparent === !0 && O.side === oi && O.forceSinglePass === !1
          ? ((O.side = An),
            (O.needsUpdate = !0),
            g.renderBufferDirect(P, C, N, O, y, Y),
            (O.side = Xi),
            (O.needsUpdate = !0),
            g.renderBufferDirect(P, C, N, O, y, Y),
            (O.side = oi))
          : g.renderBufferDirect(P, C, N, O, y, Y),
        y.onAfterRender(g, C, P, N, O, Y);
    }
    function $e(y, C, P) {
      C.isScene !== !0 && (C = pt);
      const N = qe.get(y),
        O = m.state.lights,
        Y = m.state.shadowsArray,
        X = O.state.version,
        Z = q.getParameters(y, O.state, Y, C, P),
        re = q.getProgramCacheKey(Z);
      let ae = N.programs;
      (N.environment = y.isMeshStandardMaterial ? C.environment : null),
        (N.fog = C.fog),
        (N.envMap = (y.isMeshStandardMaterial ? Pt : it).get(
          y.envMap || N.environment
        )),
        ae === void 0 &&
          (y.addEventListener("dispose", ce),
          (ae = new Map()),
          (N.programs = ae));
      let de = ae.get(re);
      if (de !== void 0) {
        if (N.currentProgram === de && N.lightsStateVersion === X)
          return Oa(y, Z), de;
      } else
        (Z.uniforms = q.getUniforms(y)),
          y.onBuild(P, Z, g),
          y.onBeforeCompile(Z, g),
          (de = q.acquireProgram(Z, re)),
          ae.set(re, de),
          (N.uniforms = Z.uniforms);
      const Se = N.uniforms;
      return (
        ((!y.isShaderMaterial && !y.isRawShaderMaterial) ||
          y.clipping === !0) &&
          (Se.clippingPlanes = Ie.uniform),
        Oa(y, Z),
        (N.needsLights = D(y)),
        (N.lightsStateVersion = X),
        N.needsLights &&
          ((Se.ambientLightColor.value = O.state.ambient),
          (Se.lightProbe.value = O.state.probe),
          (Se.directionalLights.value = O.state.directional),
          (Se.directionalLightShadows.value = O.state.directionalShadow),
          (Se.spotLights.value = O.state.spot),
          (Se.spotLightShadows.value = O.state.spotShadow),
          (Se.rectAreaLights.value = O.state.rectArea),
          (Se.ltc_1.value = O.state.rectAreaLTC1),
          (Se.ltc_2.value = O.state.rectAreaLTC2),
          (Se.pointLights.value = O.state.point),
          (Se.pointLightShadows.value = O.state.pointShadow),
          (Se.hemisphereLights.value = O.state.hemi),
          (Se.directionalShadowMap.value = O.state.directionalShadowMap),
          (Se.directionalShadowMatrix.value = O.state.directionalShadowMatrix),
          (Se.spotShadowMap.value = O.state.spotShadowMap),
          (Se.spotLightMatrix.value = O.state.spotLightMatrix),
          (Se.spotLightMap.value = O.state.spotLightMap),
          (Se.pointShadowMap.value = O.state.pointShadowMap),
          (Se.pointShadowMatrix.value = O.state.pointShadowMatrix)),
        (N.currentProgram = de),
        (N.uniformsList = null),
        de
      );
    }
    function Ro(y) {
      if (y.uniformsList === null) {
        const C = y.currentProgram.getUniforms();
        y.uniformsList = Gl.seqWithValue(C.seq, y.uniforms);
      }
      return y.uniformsList;
    }
    function Oa(y, C) {
      const P = qe.get(y);
      (P.outputColorSpace = C.outputColorSpace),
        (P.instancing = C.instancing),
        (P.instancingColor = C.instancingColor),
        (P.skinning = C.skinning),
        (P.morphTargets = C.morphTargets),
        (P.morphNormals = C.morphNormals),
        (P.morphColors = C.morphColors),
        (P.morphTargetsCount = C.morphTargetsCount),
        (P.numClippingPlanes = C.numClippingPlanes),
        (P.numIntersection = C.numClipIntersection),
        (P.vertexAlphas = C.vertexAlphas),
        (P.vertexTangents = C.vertexTangents),
        (P.toneMapping = C.toneMapping);
    }
    function S(y, C, P, N, O) {
      C.isScene !== !0 && (C = pt), Xe.resetTextureUnits();
      const Y = C.fog,
        X = N.isMeshStandardMaterial ? C.environment : null,
        Z =
          A === null
            ? g.outputColorSpace
            : A.isXRRenderTarget === !0
            ? A.texture.colorSpace
            : Vt,
        re = (N.isMeshStandardMaterial ? Pt : it).get(N.envMap || X),
        ae =
          N.vertexColors === !0 &&
          !!P.attributes.color &&
          P.attributes.color.itemSize === 4,
        de = !!P.attributes.tangent && (!!N.normalMap || N.anisotropy > 0),
        Se = !!P.morphAttributes.position,
        Ee = !!P.morphAttributes.normal,
        be = !!P.morphAttributes.color;
      let Oe = Mr;
      N.toneMapped &&
        (A === null || A.isXRRenderTarget === !0) &&
        (Oe = g.toneMapping);
      const at =
          P.morphAttributes.position ||
          P.morphAttributes.normal ||
          P.morphAttributes.color,
        je = at !== void 0 ? at.length : 0,
        ze = qe.get(N),
        ct = m.state.lights;
      if (ve === !0 && (we === !0 || y !== M)) {
        const Tt = y === M && N.id === U;
        Ie.setState(N, y, Tt);
      }
      let Fe = !1;
      N.version === ze.__version
        ? ((ze.needsLights && ze.lightsStateVersion !== ct.state.version) ||
            ze.outputColorSpace !== Z ||
            (O.isInstancedMesh && ze.instancing === !1) ||
            (!O.isInstancedMesh && ze.instancing === !0) ||
            (O.isSkinnedMesh && ze.skinning === !1) ||
            (!O.isSkinnedMesh && ze.skinning === !0) ||
            (O.isInstancedMesh &&
              ze.instancingColor === !0 &&
              O.instanceColor === null) ||
            (O.isInstancedMesh &&
              ze.instancingColor === !1 &&
              O.instanceColor !== null) ||
            ze.envMap !== re ||
            (N.fog === !0 && ze.fog !== Y) ||
            (ze.numClippingPlanes !== void 0 &&
              (ze.numClippingPlanes !== Ie.numPlanes ||
                ze.numIntersection !== Ie.numIntersection)) ||
            ze.vertexAlphas !== ae ||
            ze.vertexTangents !== de ||
            ze.morphTargets !== Se ||
            ze.morphNormals !== Ee ||
            ze.morphColors !== be ||
            ze.toneMapping !== Oe ||
            (He.isWebGL2 === !0 && ze.morphTargetsCount !== je)) &&
          (Fe = !0)
        : ((Fe = !0), (ze.__version = N.version));
      let mt = ze.currentProgram;
      Fe === !0 && (mt = $e(N, C, O));
      let un = !1,
        Mt = !1,
        st = !1;
      const Ze = mt.getUniforms(),
        Qt = ze.uniforms;
      if (
        (Ve.useProgram(mt.program) && ((un = !0), (Mt = !0), (st = !0)),
        N.id !== U && ((U = N.id), (Mt = !0)),
        un || M !== y)
      ) {
        Ze.setValue(j, "projectionMatrix", y.projectionMatrix),
          Ze.setValue(j, "viewMatrix", y.matrixWorldInverse);
        const Tt = Ze.map.cameraPosition;
        Tt !== void 0 &&
          Tt.setValue(j, We.setFromMatrixPosition(y.matrixWorld)),
          He.logarithmicDepthBuffer &&
            Ze.setValue(
              j,
              "logDepthBufFC",
              2 / (Math.log(y.far + 1) / Math.LN2)
            ),
          (N.isMeshPhongMaterial ||
            N.isMeshToonMaterial ||
            N.isMeshLambertMaterial ||
            N.isMeshBasicMaterial ||
            N.isMeshStandardMaterial ||
            N.isShaderMaterial) &&
            Ze.setValue(j, "isOrthographic", y.isOrthographicCamera === !0),
          M !== y && ((M = y), (Mt = !0), (st = !0));
      }
      if (O.isSkinnedMesh) {
        Ze.setOptional(j, O, "bindMatrix"),
          Ze.setOptional(j, O, "bindMatrixInverse");
        const Tt = O.skeleton;
        Tt &&
          (He.floatVertexTextures
            ? (Tt.boneTexture === null && Tt.computeBoneTexture(),
              Ze.setValue(j, "boneTexture", Tt.boneTexture, Xe),
              Ze.setValue(j, "boneTextureSize", Tt.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const wi = P.morphAttributes;
      if (
        ((wi.position !== void 0 ||
          wi.normal !== void 0 ||
          (wi.color !== void 0 && He.isWebGL2 === !0)) &&
          F.update(O, P, mt),
        (Mt || ze.receiveShadow !== O.receiveShadow) &&
          ((ze.receiveShadow = O.receiveShadow),
          Ze.setValue(j, "receiveShadow", O.receiveShadow)),
        N.isMeshGouraudMaterial &&
          N.envMap !== null &&
          ((Qt.envMap.value = re),
          (Qt.flipEnvMap.value =
            re.isCubeTexture && re.isRenderTargetTexture === !1 ? -1 : 1)),
        Mt &&
          (Ze.setValue(j, "toneMappingExposure", g.toneMappingExposure),
          ze.needsLights && R(Qt, st),
          Y && N.fog === !0 && pe.refreshFogUniforms(Qt, Y),
          pe.refreshMaterialUniforms(Qt, N, te, ie, ye),
          Gl.upload(j, Ro(ze), Qt, Xe)),
        N.isShaderMaterial &&
          N.uniformsNeedUpdate === !0 &&
          (Gl.upload(j, Ro(ze), Qt, Xe), (N.uniformsNeedUpdate = !1)),
        N.isSpriteMaterial && Ze.setValue(j, "center", O.center),
        Ze.setValue(j, "modelViewMatrix", O.modelViewMatrix),
        Ze.setValue(j, "normalMatrix", O.normalMatrix),
        Ze.setValue(j, "modelMatrix", O.matrixWorld),
        N.isShaderMaterial || N.isRawShaderMaterial)
      ) {
        const Tt = N.uniformsGroups;
        for (let Ki = 0, Zv = Tt.length; Ki < Zv; Ki++)
          if (He.isWebGL2) {
            const Ah = Tt[Ki];
            Le.update(Ah, mt), Le.bind(Ah, mt);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return mt;
    }
    function R(y, C) {
      (y.ambientLightColor.needsUpdate = C),
        (y.lightProbe.needsUpdate = C),
        (y.directionalLights.needsUpdate = C),
        (y.directionalLightShadows.needsUpdate = C),
        (y.pointLights.needsUpdate = C),
        (y.pointLightShadows.needsUpdate = C),
        (y.spotLights.needsUpdate = C),
        (y.spotLightShadows.needsUpdate = C),
        (y.rectAreaLights.needsUpdate = C),
        (y.hemisphereLights.needsUpdate = C);
    }
    function D(y) {
      return (
        y.isMeshLambertMaterial ||
        y.isMeshToonMaterial ||
        y.isMeshPhongMaterial ||
        y.isMeshStandardMaterial ||
        y.isShadowMaterial ||
        (y.isShaderMaterial && y.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return w;
    }),
      (this.getActiveMipmapLevel = function () {
        return L;
      }),
      (this.getRenderTarget = function () {
        return A;
      }),
      (this.setRenderTargetTextures = function (y, C, P) {
        (qe.get(y.texture).__webglTexture = C),
          (qe.get(y.depthTexture).__webglTexture = P);
        const N = qe.get(y);
        (N.__hasExternalTextures = !0),
          N.__hasExternalTextures &&
            ((N.__autoAllocateDepthBuffer = P === void 0),
            N.__autoAllocateDepthBuffer ||
              (De.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (N.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (y, C) {
        const P = qe.get(y);
        (P.__webglFramebuffer = C), (P.__useDefaultFramebuffer = C === void 0);
      }),
      (this.setRenderTarget = function (y, C = 0, P = 0) {
        (A = y), (w = C), (L = P);
        let N = !0,
          O = null,
          Y = !1,
          X = !1;
        if (y) {
          const re = qe.get(y);
          re.__useDefaultFramebuffer !== void 0
            ? (Ve.bindFramebuffer(j.FRAMEBUFFER, null), (N = !1))
            : re.__webglFramebuffer === void 0
            ? Xe.setupRenderTarget(y)
            : re.__hasExternalTextures &&
              Xe.rebindTextures(
                y,
                qe.get(y.texture).__webglTexture,
                qe.get(y.depthTexture).__webglTexture
              );
          const ae = y.texture;
          (ae.isData3DTexture ||
            ae.isDataArrayTexture ||
            ae.isCompressedArrayTexture) &&
            (X = !0);
          const de = qe.get(y).__webglFramebuffer;
          y.isWebGLCubeRenderTarget
            ? (Array.isArray(de[C]) ? (O = de[C][P]) : (O = de[C]), (Y = !0))
            : He.isWebGL2 && y.samples > 0 && Xe.useMultisampledRTT(y) === !1
            ? (O = qe.get(y).__webglMultisampledFramebuffer)
            : Array.isArray(de)
            ? (O = de[P])
            : (O = de),
            b.copy(y.viewport),
            $.copy(y.scissor),
            (J = y.scissorTest);
        } else
          b.copy(G).multiplyScalar(te).floor(),
            $.copy(z).multiplyScalar(te).floor(),
            (J = V);
        if (
          (Ve.bindFramebuffer(j.FRAMEBUFFER, O) &&
            He.drawBuffers &&
            N &&
            Ve.drawBuffers(y, O),
          Ve.viewport(b),
          Ve.scissor($),
          Ve.setScissorTest(J),
          Y)
        ) {
          const re = qe.get(y.texture);
          j.framebufferTexture2D(
            j.FRAMEBUFFER,
            j.COLOR_ATTACHMENT0,
            j.TEXTURE_CUBE_MAP_POSITIVE_X + C,
            re.__webglTexture,
            P
          );
        } else if (X) {
          const re = qe.get(y.texture),
            ae = C || 0;
          j.framebufferTextureLayer(
            j.FRAMEBUFFER,
            j.COLOR_ATTACHMENT0,
            re.__webglTexture,
            P || 0,
            ae
          );
        }
        U = -1;
      }),
      (this.readRenderTargetPixels = function (y, C, P, N, O, Y, X) {
        if (!(y && y.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Z = qe.get(y).__webglFramebuffer;
        if ((y.isWebGLCubeRenderTarget && X !== void 0 && (Z = Z[X]), Z)) {
          Ve.bindFramebuffer(j.FRAMEBUFFER, Z);
          try {
            const re = y.texture,
              ae = re.format,
              de = re.type;
            if (
              ae !== Pn &&
              Be.convert(ae) !==
                j.getParameter(j.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const Se =
              de === ki &&
              (De.has("EXT_color_buffer_half_float") ||
                (He.isWebGL2 && De.has("EXT_color_buffer_float")));
            if (
              de !== Tr &&
              Be.convert(de) !==
                j.getParameter(j.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                de === jn &&
                (He.isWebGL2 ||
                  De.has("OES_texture_float") ||
                  De.has("WEBGL_color_buffer_float"))
              ) &&
              !Se
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            C >= 0 &&
              C <= y.width - N &&
              P >= 0 &&
              P <= y.height - O &&
              j.readPixels(C, P, N, O, Be.convert(ae), Be.convert(de), Y);
          } finally {
            const re = A !== null ? qe.get(A).__webglFramebuffer : null;
            Ve.bindFramebuffer(j.FRAMEBUFFER, re);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (y, C, P = 0) {
        const N = Math.pow(2, -P),
          O = Math.floor(C.image.width * N),
          Y = Math.floor(C.image.height * N);
        Xe.setTexture2D(C, 0),
          j.copyTexSubImage2D(j.TEXTURE_2D, P, 0, 0, y.x, y.y, O, Y),
          Ve.unbindTexture();
      }),
      (this.copyTextureToTexture = function (y, C, P, N = 0) {
        const O = C.image.width,
          Y = C.image.height,
          X = Be.convert(P.format),
          Z = Be.convert(P.type);
        Xe.setTexture2D(P, 0),
          j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, P.flipY),
          j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, P.premultiplyAlpha),
          j.pixelStorei(j.UNPACK_ALIGNMENT, P.unpackAlignment),
          C.isDataTexture
            ? j.texSubImage2D(
                j.TEXTURE_2D,
                N,
                y.x,
                y.y,
                O,
                Y,
                X,
                Z,
                C.image.data
              )
            : C.isCompressedTexture
            ? j.compressedTexSubImage2D(
                j.TEXTURE_2D,
                N,
                y.x,
                y.y,
                C.mipmaps[0].width,
                C.mipmaps[0].height,
                X,
                C.mipmaps[0].data
              )
            : j.texSubImage2D(j.TEXTURE_2D, N, y.x, y.y, X, Z, C.image),
          N === 0 && P.generateMipmaps && j.generateMipmap(j.TEXTURE_2D),
          Ve.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (y, C, P, N, O = 0) {
        if (g.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const Y = y.max.x - y.min.x + 1,
          X = y.max.y - y.min.y + 1,
          Z = y.max.z - y.min.z + 1,
          re = Be.convert(N.format),
          ae = Be.convert(N.type);
        let de;
        if (N.isData3DTexture) Xe.setTexture3D(N, 0), (de = j.TEXTURE_3D);
        else if (N.isDataArrayTexture)
          Xe.setTexture2DArray(N, 0), (de = j.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL, N.flipY),
          j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha),
          j.pixelStorei(j.UNPACK_ALIGNMENT, N.unpackAlignment);
        const Se = j.getParameter(j.UNPACK_ROW_LENGTH),
          Ee = j.getParameter(j.UNPACK_IMAGE_HEIGHT),
          be = j.getParameter(j.UNPACK_SKIP_PIXELS),
          Oe = j.getParameter(j.UNPACK_SKIP_ROWS),
          at = j.getParameter(j.UNPACK_SKIP_IMAGES),
          je = P.isCompressedTexture ? P.mipmaps[0] : P.image;
        j.pixelStorei(j.UNPACK_ROW_LENGTH, je.width),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, je.height),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, y.min.x),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, y.min.y),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, y.min.z),
          P.isDataTexture || P.isData3DTexture
            ? j.texSubImage3D(de, O, C.x, C.y, C.z, Y, X, Z, re, ae, je.data)
            : P.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              j.compressedTexSubImage3D(
                de,
                O,
                C.x,
                C.y,
                C.z,
                Y,
                X,
                Z,
                re,
                je.data
              ))
            : j.texSubImage3D(de, O, C.x, C.y, C.z, Y, X, Z, re, ae, je),
          j.pixelStorei(j.UNPACK_ROW_LENGTH, Se),
          j.pixelStorei(j.UNPACK_IMAGE_HEIGHT, Ee),
          j.pixelStorei(j.UNPACK_SKIP_PIXELS, be),
          j.pixelStorei(j.UNPACK_SKIP_ROWS, Oe),
          j.pixelStorei(j.UNPACK_SKIP_IMAGES, at),
          O === 0 && N.generateMipmaps && j.generateMipmap(de),
          Ve.unbindTexture();
      }),
      (this.initTexture = function (y) {
        y.isCubeTexture
          ? Xe.setTextureCube(y, 0)
          : y.isData3DTexture
          ? Xe.setTexture3D(y, 0)
          : y.isDataArrayTexture || y.isCompressedArrayTexture
          ? Xe.setTexture2DArray(y, 0)
          : Xe.setTexture2D(y, 0),
          Ve.unbindTexture();
      }),
      (this.resetState = function () {
        (w = 0), (L = 0), (A = null), Ve.reset(), Pe.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Bi;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = e === lh ? "display-p3" : "srgb"),
      (t.unpackColorSpace =
        lt.workingColorSpace === Bc ? "display-p3" : "srgb");
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === Rt ? ns : cv
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === ns ? Rt : Vt);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class WA extends bv {}
WA.prototype.isWebGL1Renderer = !0;
class XA extends Ct {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class jA {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = td),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = ci());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ci()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ci()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const fn = new B();
class mh {
  constructor(e, t, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      fn.fromBufferAttribute(this, t),
        fn.applyMatrix4(e),
        this.setXYZ(t, fn.x, fn.y, fn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      fn.fromBufferAttribute(this, t),
        fn.applyNormalMatrix(e),
        this.setXYZ(t, fn.x, fn.y, fn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      fn.fromBufferAttribute(this, t),
        fn.transformDirection(e),
        this.setXYZ(t, fn.x, fn.y, fn.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = ht(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = _i(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = ht(t, this.array)), (i = ht(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = ht(t, this.array)),
        (i = ht(i, this.array)),
        (r = ht(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = ht(t, this.array)),
        (i = ht(i, this.array)),
        (r = ht(r, this.array)),
        (s = ht(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new gn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new mh(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const sg = new B(),
  og = new gt(),
  ag = new gt(),
  YA = new B(),
  lg = new tt(),
  El = new B(),
  Xu = new Ei(),
  cg = new tt(),
  ju = new Ia();
class qA extends Dn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = Vp),
      (this.bindMatrix = new tt()),
      (this.bindMatrixInverse = new tt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Yi()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, El), this.boundingBox.expandByPoint(El);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Ei()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      this.getVertexPosition(i, El), this.boundingSphere.expandByPoint(El);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      r = this.matrixWorld;
    i !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      Xu.copy(this.boundingSphere),
      Xu.applyMatrix4(r),
      e.ray.intersectsSphere(Xu) !== !1 &&
        (cg.copy(r).invert(),
        ju.copy(e.ray).applyMatrix4(cg),
        !(
          this.boundingBox !== null && ju.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, ju)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new gt(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === Vp
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === iE
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    og.fromBufferAttribute(r.attributes.skinIndex, e),
      ag.fromBufferAttribute(r.attributes.skinWeight, e),
      sg.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = ag.getComponent(s);
      if (o !== 0) {
        const a = og.getComponent(s);
        lg.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(YA.copy(sg).applyMatrix4(lg), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class Cv extends Ct {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Lv extends tn {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = qt, u = qt, f, d) {
    super(null, o, a, l, c, u, r, s, f, d),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const ug = new tt(),
  KA = new tt();
class gh {
  constructor(e = [], t = []) {
    (this.uuid = ci()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new tt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new tt();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : KA;
      ug.multiplyMatrices(a, t[s]), ug.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new gh(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = fv(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Lv(t, e, e, Pn, jn);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new Cv())),
        this.bones.push(o),
        this.boneInverses.push(new tt().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class sd extends gn {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const Ns = new tt(),
  fg = new tt(),
  Ml = [],
  dg = new Yi(),
  ZA = new tt(),
  zo = new Dn(),
  Ho = new Ei();
class $A extends Dn {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new sd(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, ZA);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Yi()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, Ns),
        dg.copy(e.boundingBox).applyMatrix4(Ns),
        this.boundingBox.union(dg);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Ei()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, Ns),
        Ho.copy(e.boundingSphere).applyMatrix4(Ns),
        this.boundingSphere.union(Ho);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((zo.geometry = this.geometry),
      (zo.material = this.material),
      zo.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Ho.copy(this.boundingSphere),
        Ho.applyMatrix4(i),
        e.ray.intersectsSphere(Ho) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, Ns),
          fg.multiplyMatrices(i, Ns),
          (zo.matrixWorld = fg),
          zo.raycast(e, Ml);
        for (let o = 0, a = Ml.length; o < a; o++) {
          const l = Ml[o];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        Ml.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new sd(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Pv extends xi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const hg = new B(),
  pg = new B(),
  mg = new tt(),
  Yu = new Ia(),
  Tl = new Ei();
class _h extends Ct {
  constructor(e = new fi(), t = new Pv()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        hg.fromBufferAttribute(t, r - 1),
          pg.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += hg.distanceTo(pg));
      e.setAttribute("lineDistance", new qn(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Tl.copy(i.boundingSphere),
      Tl.applyMatrix4(r),
      (Tl.radius += s),
      e.ray.intersectsSphere(Tl) === !1)
    )
      return;
    mg.copy(r).invert(), Yu.copy(e.ray).applyMatrix4(mg);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = new B(),
      u = new B(),
      f = new B(),
      d = new B(),
      p = this.isLineSegments ? 2 : 1,
      v = i.index,
      m = i.attributes.position;
    if (v !== null) {
      const h = Math.max(0, o.start),
        _ = Math.min(v.count, o.start + o.count);
      for (let g = h, E = _ - 1; g < E; g += p) {
        const w = v.getX(g),
          L = v.getX(g + 1);
        if (
          (c.fromBufferAttribute(m, w),
          u.fromBufferAttribute(m, L),
          Yu.distanceSqToSegment(c, u, d, f) > l)
        )
          continue;
        d.applyMatrix4(this.matrixWorld);
        const U = e.ray.origin.distanceTo(d);
        U < e.near ||
          U > e.far ||
          t.push({
            distance: U,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: g,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const h = Math.max(0, o.start),
        _ = Math.min(m.count, o.start + o.count);
      for (let g = h, E = _ - 1; g < E; g += p) {
        if (
          (c.fromBufferAttribute(m, g),
          u.fromBufferAttribute(m, g + 1),
          Yu.distanceSqToSegment(c, u, d, f) > l)
        )
          continue;
        d.applyMatrix4(this.matrixWorld);
        const L = e.ray.origin.distanceTo(d);
        L < e.near ||
          L > e.far ||
          t.push({
            distance: L,
            point: f.clone().applyMatrix4(this.matrixWorld),
            index: g,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const gg = new B(),
  _g = new B();
class QA extends _h {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        gg.fromBufferAttribute(t, r),
          _g.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + gg.distanceTo(_g));
      e.setAttribute("lineDistance", new qn(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class JA extends _h {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Iv extends xi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const vg = new tt(),
  od = new Ia(),
  wl = new Ei(),
  Al = new B();
class eR extends Ct {
  constructor(e = new fi(), t = new Iv()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      wl.copy(i.boundingSphere),
      wl.applyMatrix4(r),
      (wl.radius += s),
      e.ray.intersectsSphere(wl) === !1)
    )
      return;
    vg.copy(r).invert(), od.copy(e.ray).applyMatrix4(vg);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = i.index,
      f = i.attributes.position;
    if (c !== null) {
      const d = Math.max(0, o.start),
        p = Math.min(c.count, o.start + o.count);
      for (let v = d, x = p; v < x; v++) {
        const m = c.getX(v);
        Al.fromBufferAttribute(f, m), yg(Al, m, l, r, e, t, this);
      }
    } else {
      const d = Math.max(0, o.start),
        p = Math.min(f.count, o.start + o.count);
      for (let v = d, x = p; v < x; v++)
        Al.fromBufferAttribute(f, v), yg(Al, v, l, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function yg(n, e, t, i, r, s, o) {
  const a = od.distanceSqToPoint(n);
  if (a < t) {
    const l = new B();
    od.closestPointToPoint(n, l), l.applyMatrix4(i);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class vh extends fi {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
    const s = [],
      o = [];
    a(r),
      c(i),
      u(),
      this.setAttribute("position", new qn(s, 3)),
      this.setAttribute("normal", new qn(s.slice(), 3)),
      this.setAttribute("uv", new qn(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(_) {
      const g = new B(),
        E = new B(),
        w = new B();
      for (let L = 0; L < t.length; L += 3)
        p(t[L + 0], g), p(t[L + 1], E), p(t[L + 2], w), l(g, E, w, _);
    }
    function l(_, g, E, w) {
      const L = w + 1,
        A = [];
      for (let U = 0; U <= L; U++) {
        A[U] = [];
        const M = _.clone().lerp(E, U / L),
          b = g.clone().lerp(E, U / L),
          $ = L - U;
        for (let J = 0; J <= $; J++)
          J === 0 && U === L
            ? (A[U][J] = M)
            : (A[U][J] = M.clone().lerp(b, J / $));
      }
      for (let U = 0; U < L; U++)
        for (let M = 0; M < 2 * (L - U) - 1; M++) {
          const b = Math.floor(M / 2);
          M % 2 === 0
            ? (d(A[U][b + 1]), d(A[U + 1][b]), d(A[U][b]))
            : (d(A[U][b + 1]), d(A[U + 1][b + 1]), d(A[U + 1][b]));
        }
    }
    function c(_) {
      const g = new B();
      for (let E = 0; E < s.length; E += 3)
        (g.x = s[E + 0]),
          (g.y = s[E + 1]),
          (g.z = s[E + 2]),
          g.normalize().multiplyScalar(_),
          (s[E + 0] = g.x),
          (s[E + 1] = g.y),
          (s[E + 2] = g.z);
    }
    function u() {
      const _ = new B();
      for (let g = 0; g < s.length; g += 3) {
        (_.x = s[g + 0]), (_.y = s[g + 1]), (_.z = s[g + 2]);
        const E = m(_) / 2 / Math.PI + 0.5,
          w = h(_) / Math.PI + 0.5;
        o.push(E, 1 - w);
      }
      v(), f();
    }
    function f() {
      for (let _ = 0; _ < o.length; _ += 6) {
        const g = o[_ + 0],
          E = o[_ + 2],
          w = o[_ + 4],
          L = Math.max(g, E, w),
          A = Math.min(g, E, w);
        L > 0.9 &&
          A < 0.1 &&
          (g < 0.2 && (o[_ + 0] += 1),
          E < 0.2 && (o[_ + 2] += 1),
          w < 0.2 && (o[_ + 4] += 1));
      }
    }
    function d(_) {
      s.push(_.x, _.y, _.z);
    }
    function p(_, g) {
      const E = _ * 3;
      (g.x = e[E + 0]), (g.y = e[E + 1]), (g.z = e[E + 2]);
    }
    function v() {
      const _ = new B(),
        g = new B(),
        E = new B(),
        w = new B(),
        L = new Ge(),
        A = new Ge(),
        U = new Ge();
      for (let M = 0, b = 0; M < s.length; M += 9, b += 6) {
        _.set(s[M + 0], s[M + 1], s[M + 2]),
          g.set(s[M + 3], s[M + 4], s[M + 5]),
          E.set(s[M + 6], s[M + 7], s[M + 8]),
          L.set(o[b + 0], o[b + 1]),
          A.set(o[b + 2], o[b + 3]),
          U.set(o[b + 4], o[b + 5]),
          w.copy(_).add(g).add(E).divideScalar(3);
        const $ = m(w);
        x(L, b + 0, _, $), x(A, b + 2, g, $), x(U, b + 4, E, $);
      }
    }
    function x(_, g, E, w) {
      w < 0 && _.x === 1 && (o[g] = _.x - 1),
        E.x === 0 && E.z === 0 && (o[g] = w / 2 / Math.PI + 0.5);
    }
    function m(_) {
      return Math.atan2(_.z, -_.x);
    }
    function h(_) {
      return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new vh(e.vertices, e.indices, e.radius, e.details);
  }
}
class yh extends vh {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new yh(e.radius, e.detail);
  }
}
class Vc extends xi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Ke(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ke(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = uv),
      (this.normalScale = new Ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Dr extends Vc {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Ge(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return Kt((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Ke(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Ke(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Ke(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function Rl(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function tR(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function nR(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function xg(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = n[a + l];
  }
  return r;
}
function Nv(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]);
      while (s !== void 0);
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]);
      while (s !== void 0);
}
class Da {
  constructor(e, t, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === l) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            (o = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class iR extends Da {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: pm, endingEnd: pm });
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case mm:
          (s = e), (a = 2 * t - i);
          break;
        case gm:
          (s = r.length - 2), (a = t + r[s] - r[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case mm:
          (o = e), (l = 2 * i - t);
          break;
        case gm:
          (o = 1), (l = i + r[1] - r[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const c = (i - t) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - i)),
      (this._offsetPrev = s * u),
      (this._offsetNext = o * u);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = this._offsetPrev,
      f = this._offsetNext,
      d = this._weightPrev,
      p = this._weightNext,
      v = (i - t) / (r - t),
      x = v * v,
      m = x * v,
      h = -d * m + 2 * d * x - d * v,
      _ = (1 + d) * m + (-1.5 - 2 * d) * x + (-0.5 + d) * v + 1,
      g = (-1 - p) * m + (1.5 + p) * x + 0.5 * v,
      E = p * m - p * x;
    for (let w = 0; w !== a; ++w)
      s[w] = h * o[u + w] + _ * o[c + w] + g * o[l + w] + E * o[f + w];
    return s;
  }
}
class rR extends Da {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = (i - t) / (r - t),
      f = 1 - u;
    for (let d = 0; d !== a; ++d) s[d] = o[c + d] * f + o[l + d] * u;
    return s;
  }
}
class sR extends Da {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Mi {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Rl(t, this.TimeBufferType)),
      (this.values = Rl(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: Rl(e.times, Array),
        values: Rl(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new sR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new rR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new iR(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case wa:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case po:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Su:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return wa;
      case this.InterpolantFactoryMethodLinear:
        return po;
      case this.InterpolantFactoryMethodSmooth:
        return Su;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = i.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (r !== void 0 && tR(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.getValueSize(),
      r = this.getInterpolation() === Su,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a],
        u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (r) l = !0;
        else {
          const f = a * i,
            d = f - i,
            p = f + i;
          for (let v = 0; v !== i; ++v) {
            const x = t[f + v];
            if (x !== t[d + v] || x !== t[p + v]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const f = a * i,
            d = o * i;
          for (let p = 0; p !== i; ++p) t[d + p] = t[f + p];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      i = this.constructor,
      r = new i(this.name, e, t);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
Mi.prototype.TimeBufferType = Float32Array;
Mi.prototype.ValueBufferType = Float32Array;
Mi.prototype.DefaultInterpolation = po;
class To extends Mi {}
To.prototype.ValueTypeName = "bool";
To.prototype.ValueBufferType = Array;
To.prototype.DefaultInterpolation = wa;
To.prototype.InterpolantFactoryMethodLinear = void 0;
To.prototype.InterpolantFactoryMethodSmooth = void 0;
class Dv extends Mi {}
Dv.prototype.ValueTypeName = "color";
class _o extends Mi {}
_o.prototype.ValueTypeName = "number";
class oR extends Da {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - t) / (r - t);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4) Si.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
}
class cs extends Mi {
  InterpolantFactoryMethodLinear(e) {
    return new oR(this.times, this.values, this.getValueSize(), e);
  }
}
cs.prototype.ValueTypeName = "quaternion";
cs.prototype.DefaultInterpolation = po;
cs.prototype.InterpolantFactoryMethodSmooth = void 0;
class wo extends Mi {}
wo.prototype.ValueTypeName = "string";
wo.prototype.ValueBufferType = Array;
wo.prototype.DefaultInterpolation = wa;
wo.prototype.InterpolantFactoryMethodLinear = void 0;
wo.prototype.InterpolantFactoryMethodSmooth = void 0;
class vo extends Mi {}
vo.prototype.ValueTypeName = "vector";
class aR {
  constructor(e, t = -1, i, r = dE) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = ci()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(cR(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(Mi.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        c = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
      const u = nR(l);
      (l = xg(l, 1, u)),
        (c = xg(c, 1, u)),
        !r && l[0] === 0 && (l.push(s), c.push(c[0])),
        o.push(
          new _o(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / i)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = c.name.match(s);
      if (u && u.length > 1) {
        const f = u[1];
        let d = r[f];
        d || (r[f] = d = []), d.push(c);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (f, d, p, v, x) {
        if (p.length !== 0) {
          const m = [],
            h = [];
          Nv(p, m, h, v), m.length !== 0 && x.push(new f(d, m, h));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let f = 0; f < c.length; f++) {
      const d = c[f].keys;
      if (!(!d || d.length === 0))
        if (d[0].morphTargets) {
          const p = {};
          let v;
          for (v = 0; v < d.length; v++)
            if (d[v].morphTargets)
              for (let x = 0; x < d[v].morphTargets.length; x++)
                p[d[v].morphTargets[x]] = -1;
          for (const x in p) {
            const m = [],
              h = [];
            for (let _ = 0; _ !== d[v].morphTargets.length; ++_) {
              const g = d[v];
              m.push(g.time), h.push(g.morphTarget === x ? 1 : 0);
            }
            r.push(new _o(".morphTargetInfluence[" + x + "]", m, h));
          }
          l = p.length * o;
        } else {
          const p = ".bones[" + t[f].name + "]";
          i(vo, p + ".position", d, "pos", r),
            i(cs, p + ".quaternion", d, "rot", r),
            i(vo, p + ".scale", d, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function lR(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return _o;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return vo;
    case "color":
      return Dv;
    case "quaternion":
      return cs;
    case "bool":
    case "boolean":
      return To;
    case "string":
      return wo;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function cR(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = lR(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    Nv(n.keys, t, i, "value"), (n.times = t), (n.values = i);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const yo = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class uR {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (u) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(u, o, a), (s = !0);
      }),
      (this.itemEnd = function (u) {
        o++,
          r.onProgress !== void 0 && r.onProgress(u, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (u) {
        r.onError !== void 0 && r.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, f) {
        return c.push(u, f), this;
      }),
      (this.removeHandler = function (u) {
        const f = c.indexOf(u);
        return f !== -1 && c.splice(f, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let f = 0, d = c.length; f < d; f += 2) {
          const p = c[f],
            v = c[f + 1];
          if ((p.global && (p.lastIndex = 0), p.test(u))) return v;
        }
        return null;
      });
  }
}
const Uv = new uR();
class hs {
  constructor(e) {
    (this.manager = e !== void 0 ? e : Uv),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
hs.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Pi = {};
class fR extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class xh extends hs {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = yo.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (Pi[e] !== void 0) {
      Pi[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    (Pi[e] = []), Pi[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = Pi[e],
            f = c.body.getReader(),
            d = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
            p = d ? parseInt(d) : 0,
            v = p !== 0;
          let x = 0;
          const m = new ReadableStream({
            start(h) {
              _();
              function _() {
                f.read().then(({ done: g, value: E }) => {
                  if (g) h.close();
                  else {
                    x += E.byteLength;
                    const w = new ProgressEvent("progress", {
                      lengthComputable: v,
                      loaded: x,
                      total: p,
                    });
                    for (let L = 0, A = u.length; L < A; L++) {
                      const U = u[L];
                      U.onProgress && U.onProgress(w);
                    }
                    h.enqueue(E), _();
                  }
                });
              }
            },
          });
          return new Response(m);
        } else
          throw new fR(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const f = /charset="?([^;"\s]*)"?/i.exec(a),
                d = f && f[1] ? f[1].toLowerCase() : void 0,
                p = new TextDecoder(d);
              return c.arrayBuffer().then((v) => p.decode(v));
            }
        }
      })
      .then((c) => {
        yo.add(e, c);
        const u = Pi[e];
        delete Pi[e];
        for (let f = 0, d = u.length; f < d; f++) {
          const p = u[f];
          p.onLoad && p.onLoad(c);
        }
      })
      .catch((c) => {
        const u = Pi[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete Pi[e];
        for (let f = 0, d = u.length; f < d; f++) {
          const p = u[f];
          p.onError && p.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class dR extends hs {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = yo.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = Aa("img");
    function l() {
      u(), yo.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(f) {
      u(), r && r(f), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class hR extends hs {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Lv(),
      a = new xh(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          let c;
          try {
            c = s.parse(l);
          } catch (u) {
            if (r !== void 0) r(u);
            else {
              console.error(u);
              return;
            }
          }
          c.image !== void 0
            ? (o.image = c.image)
            : c.data !== void 0 &&
              ((o.image.width = c.width),
              (o.image.height = c.height),
              (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : Sn),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : Sn),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : zt),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : zt),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0
              ? (o.colorSpace = c.colorSpace)
              : c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = br)),
            c.mipmapCount === 1 && (o.minFilter = zt),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, c);
        },
        i,
        r
      ),
      o
    );
  }
}
class Ov extends hs {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new tn(),
      o = new dR(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        i,
        r
      ),
      s
    );
  }
}
class Sh extends Ct {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Ke(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
const qu = new tt(),
  Sg = new B(),
  Eg = new B();
class Eh {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Ge(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new tt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new fh()),
      (this._frameExtents = new Ge(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new gt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    Sg.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Sg),
      Eg.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(Eg),
      t.updateMatrixWorld(),
      qu.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(qu),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(qu);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class pR extends Eh {
  constructor() {
    super(new pn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = mo * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class mR extends Sh {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Ct.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ct()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new pR());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const Mg = new tt(),
  Vo = new B(),
  Ku = new B();
class gR extends Eh {
  constructor() {
    super(new pn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Ge(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new gt(2, 1, 1, 1),
        new gt(0, 1, 1, 1),
        new gt(3, 1, 1, 1),
        new gt(1, 1, 1, 1),
        new gt(3, 0, 1, 1),
        new gt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new B(1, 0, 0),
        new B(-1, 0, 0),
        new B(0, 0, 1),
        new B(0, 0, -1),
        new B(0, 1, 0),
        new B(0, -1, 0),
      ]),
      (this._cubeUps = [
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 1, 0),
        new B(0, 0, 1),
        new B(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Vo.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Vo),
      Ku.copy(i.position),
      Ku.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(Ku),
      i.updateMatrixWorld(),
      r.makeTranslation(-Vo.x, -Vo.y, -Vo.z),
      Mg.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Mg);
  }
}
class _R extends Sh {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new gR());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class vR extends Eh {
  constructor() {
    super(new hh(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class Fv extends Sh {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Ct.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Ct()),
      (this.shadow = new vR());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class ad {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class yR extends hs {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = yo.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          yo.add(e, l), t && t(l), s.manager.itemEnd(e);
        })
        .catch(function (l) {
          r && r(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
const Mh = "\\[\\]\\.:\\/",
  xR = new RegExp("[" + Mh + "]", "g"),
  Th = "[^" + Mh + "]",
  SR = "[^" + Mh.replace("\\.", "") + "]",
  ER = /((?:WC+[\/:])*)/.source.replace("WC", Th),
  MR = /(WCOD+)?/.source.replace("WCOD", SR),
  TR = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Th),
  wR = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Th),
  AR = new RegExp("^" + ER + MR + TR + wR + "$"),
  RR = ["material", "materials", "bones", "map"];
class bR {
  constructor(e, t, i) {
    const r = i || ut.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class ut {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || ut.parseTrackName(t)),
      (this.node = ut.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new ut.Composite(e, t, i)
      : new ut(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(xR, "");
  }
  static parseTrackName(e) {
    const t = AR.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      RR.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = i(a.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = ut.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
ut.Composite = bR;
ut.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
ut.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
ut.prototype.GetterByBindingType = [
  ut.prototype._getValue_direct,
  ut.prototype._getValue_array,
  ut.prototype._getValue_arrayElement,
  ut.prototype._getValue_toArray,
];
ut.prototype.SetterByBindingTypeAndVersioning = [
  [
    ut.prototype._setValue_direct,
    ut.prototype._setValue_direct_setNeedsUpdate,
    ut.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    ut.prototype._setValue_array,
    ut.prototype._setValue_array_setNeedsUpdate,
    ut.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    ut.prototype._setValue_arrayElement,
    ut.prototype._setValue_arrayElement_setNeedsUpdate,
    ut.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    ut.prototype._setValue_fromArray,
    ut.prototype._setValue_fromArray_setNeedsUpdate,
    ut.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class Tg {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(Kt(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: oh } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = oh));
const wg = { type: "change" },
  Zu = { type: "start" },
  Ag = { type: "end" },
  bl = new Ia(),
  Rg = new or(),
  CR = Math.cos(70 * uh.DEG2RAD);
class LR extends ds {
  constructor(e, t) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new B()),
      (this.cursor = new B()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minTargetRadius = 0),
      (this.maxTargetRadius = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.zoomToCursor = !1),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: ms.ROTATE,
        MIDDLE: ms.DOLLY,
        RIGHT: ms.PAN,
      }),
      (this.touches = { ONE: gs.ROTATE, TWO: gs.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return a.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return a.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (F) {
        F.addEventListener("keydown", T), (this._domElementKeyEvents = F);
      }),
      (this.stopListenToKeyEvents = function () {
        this._domElementKeyEvents.removeEventListener("keydown", T),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = function () {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object.zoom);
      }),
      (this.reset = function () {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          (i.object.zoom = i.zoom0),
          i.object.updateProjectionMatrix(),
          i.dispatchEvent(wg),
          i.update(),
          (s = r.NONE);
      }),
      (this.update = (function () {
        const F = new B(),
          fe = new Si().setFromUnitVectors(e.up, new B(0, 1, 0)),
          ne = fe.clone().invert(),
          Be = new B(),
          Pe = new Si(),
          Le = new B(),
          Te = 2 * Math.PI;
        return function (oe = null) {
          const k = i.object.position;
          F.copy(k).sub(i.target),
            F.applyQuaternion(fe),
            a.setFromVector3(F),
            i.autoRotate && s === r.NONE && $(M(oe)),
            i.enableDamping
              ? ((a.theta += l.theta * i.dampingFactor),
                (a.phi += l.phi * i.dampingFactor))
              : ((a.theta += l.theta), (a.phi += l.phi));
          let xe = i.minAzimuthAngle,
            ce = i.maxAzimuthAngle;
          isFinite(xe) &&
            isFinite(ce) &&
            (xe < -Math.PI ? (xe += Te) : xe > Math.PI && (xe -= Te),
            ce < -Math.PI ? (ce += Te) : ce > Math.PI && (ce -= Te),
            xe <= ce
              ? (a.theta = Math.max(xe, Math.min(ce, a.theta)))
              : (a.theta =
                  a.theta > (xe + ce) / 2
                    ? Math.max(xe, a.theta)
                    : Math.min(ce, a.theta))),
            (a.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, a.phi)
            )),
            a.makeSafe(),
            i.enableDamping === !0
              ? i.target.addScaledVector(u, i.dampingFactor)
              : i.target.add(u),
            i.target.sub(i.cursor),
            i.target.clampLength(i.minTargetRadius, i.maxTargetRadius),
            i.target.add(i.cursor),
            (i.zoomToCursor && L) || i.object.isOrthographicCamera
              ? (a.radius = K(a.radius))
              : (a.radius = K(a.radius * c)),
            F.setFromSpherical(a),
            F.applyQuaternion(ne),
            k.copy(i.target).add(F),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((l.theta *= 1 - i.dampingFactor),
                (l.phi *= 1 - i.dampingFactor),
                u.multiplyScalar(1 - i.dampingFactor))
              : (l.set(0, 0, 0), u.set(0, 0, 0));
          let ee = !1;
          if (i.zoomToCursor && L) {
            let me = null;
            if (i.object.isPerspectiveCamera) {
              const Ue = F.length();
              me = K(Ue * c);
              const Je = Ue - me;
              i.object.position.addScaledVector(E, Je),
                i.object.updateMatrixWorld();
            } else if (i.object.isOrthographicCamera) {
              const Ue = new B(w.x, w.y, 0);
              Ue.unproject(i.object),
                (i.object.zoom = Math.max(
                  i.minZoom,
                  Math.min(i.maxZoom, i.object.zoom / c)
                )),
                i.object.updateProjectionMatrix(),
                (ee = !0);
              const Je = new B(w.x, w.y, 0);
              Je.unproject(i.object),
                i.object.position.sub(Je).add(Ue),
                i.object.updateMatrixWorld(),
                (me = F.length());
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (i.zoomToCursor = !1);
            me !== null &&
              (this.screenSpacePanning
                ? i.target
                    .set(0, 0, -1)
                    .transformDirection(i.object.matrix)
                    .multiplyScalar(me)
                    .add(i.object.position)
                : (bl.origin.copy(i.object.position),
                  bl.direction
                    .set(0, 0, -1)
                    .transformDirection(i.object.matrix),
                  Math.abs(i.object.up.dot(bl.direction)) < CR
                    ? e.lookAt(i.target)
                    : (Rg.setFromNormalAndCoplanarPoint(i.object.up, i.target),
                      bl.intersectPlane(Rg, i.target))));
          } else
            i.object.isOrthographicCamera &&
              ((i.object.zoom = Math.max(
                i.minZoom,
                Math.min(i.maxZoom, i.object.zoom / c)
              )),
              i.object.updateProjectionMatrix(),
              (ee = !0));
          return (
            (c = 1),
            (L = !1),
            ee ||
            Be.distanceToSquared(i.object.position) > o ||
            8 * (1 - Pe.dot(i.object.quaternion)) > o ||
            Le.distanceToSquared(i.target) > 0
              ? (i.dispatchEvent(wg),
                Be.copy(i.object.position),
                Pe.copy(i.object.quaternion),
                Le.copy(i.target),
                (ee = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.dispose = function () {
        i.domElement.removeEventListener("contextmenu", le),
          i.domElement.removeEventListener("pointerdown", qe),
          i.domElement.removeEventListener("pointercancel", it),
          i.domElement.removeEventListener("wheel", I),
          i.domElement.removeEventListener("pointermove", Xe),
          i.domElement.removeEventListener("pointerup", it),
          i._domElementKeyEvents !== null &&
            (i._domElementKeyEvents.removeEventListener("keydown", T),
            (i._domElementKeyEvents = null));
      });
    const i = this,
      r = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let s = r.NONE;
    const o = 1e-6,
      a = new Tg(),
      l = new Tg();
    let c = 1;
    const u = new B(),
      f = new Ge(),
      d = new Ge(),
      p = new Ge(),
      v = new Ge(),
      x = new Ge(),
      m = new Ge(),
      h = new Ge(),
      _ = new Ge(),
      g = new Ge(),
      E = new B(),
      w = new Ge();
    let L = !1;
    const A = [],
      U = {};
    function M(F) {
      return F !== null
        ? ((2 * Math.PI) / 60) * i.autoRotateSpeed * F
        : ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function b() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function $(F) {
      l.theta -= F;
    }
    function J(F) {
      l.phi -= F;
    }
    const se = (function () {
        const F = new B();
        return function (ne, Be) {
          F.setFromMatrixColumn(Be, 0), F.multiplyScalar(-ne), u.add(F);
        };
      })(),
      H = (function () {
        const F = new B();
        return function (ne, Be) {
          i.screenSpacePanning === !0
            ? F.setFromMatrixColumn(Be, 1)
            : (F.setFromMatrixColumn(Be, 0), F.crossVectors(i.object.up, F)),
            F.multiplyScalar(ne),
            u.add(F);
        };
      })(),
      Q = (function () {
        const F = new B();
        return function (ne, Be) {
          const Pe = i.domElement;
          if (i.object.isPerspectiveCamera) {
            const Le = i.object.position;
            F.copy(Le).sub(i.target);
            let Te = F.length();
            (Te *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              se((2 * ne * Te) / Pe.clientHeight, i.object.matrix),
              H((2 * Be * Te) / Pe.clientHeight, i.object.matrix);
          } else
            i.object.isOrthographicCamera
              ? (se(
                  (ne * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    Pe.clientWidth,
                  i.object.matrix
                ),
                H(
                  (Be * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    Pe.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function ie(F) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera
        ? (c /= F)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function te(F) {
      i.object.isPerspectiveCamera || i.object.isOrthographicCamera
        ? (c *= F)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function W(F) {
      if (!i.zoomToCursor) return;
      L = !0;
      const fe = i.domElement.getBoundingClientRect(),
        ne = F.clientX - fe.left,
        Be = F.clientY - fe.top,
        Pe = fe.width,
        Le = fe.height;
      (w.x = (ne / Pe) * 2 - 1),
        (w.y = -(Be / Le) * 2 + 1),
        E.set(w.x, w.y, 1)
          .unproject(i.object)
          .sub(i.object.position)
          .normalize();
    }
    function K(F) {
      return Math.max(i.minDistance, Math.min(i.maxDistance, F));
    }
    function G(F) {
      f.set(F.clientX, F.clientY);
    }
    function z(F) {
      W(F), h.set(F.clientX, F.clientY);
    }
    function V(F) {
      v.set(F.clientX, F.clientY);
    }
    function _e(F) {
      d.set(F.clientX, F.clientY),
        p.subVectors(d, f).multiplyScalar(i.rotateSpeed);
      const fe = i.domElement;
      $((2 * Math.PI * p.x) / fe.clientHeight),
        J((2 * Math.PI * p.y) / fe.clientHeight),
        f.copy(d),
        i.update();
    }
    function ve(F) {
      _.set(F.clientX, F.clientY),
        g.subVectors(_, h),
        g.y > 0 ? ie(b()) : g.y < 0 && te(b()),
        h.copy(_),
        i.update();
    }
    function we(F) {
      x.set(F.clientX, F.clientY),
        m.subVectors(x, v).multiplyScalar(i.panSpeed),
        Q(m.x, m.y),
        v.copy(x),
        i.update();
    }
    function ye(F) {
      W(F), F.deltaY < 0 ? te(b()) : F.deltaY > 0 && ie(b()), i.update();
    }
    function ke(F) {
      let fe = !1;
      switch (F.code) {
        case i.keys.UP:
          F.ctrlKey || F.metaKey || F.shiftKey
            ? J((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : Q(0, i.keyPanSpeed),
            (fe = !0);
          break;
        case i.keys.BOTTOM:
          F.ctrlKey || F.metaKey || F.shiftKey
            ? J((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : Q(0, -i.keyPanSpeed),
            (fe = !0);
          break;
        case i.keys.LEFT:
          F.ctrlKey || F.metaKey || F.shiftKey
            ? $((2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : Q(i.keyPanSpeed, 0),
            (fe = !0);
          break;
        case i.keys.RIGHT:
          F.ctrlKey || F.metaKey || F.shiftKey
            ? $((-2 * Math.PI * i.rotateSpeed) / i.domElement.clientHeight)
            : Q(-i.keyPanSpeed, 0),
            (fe = !0);
          break;
      }
      fe && (F.preventDefault(), i.update());
    }
    function Ne() {
      if (A.length === 1) f.set(A[0].pageX, A[0].pageY);
      else {
        const F = 0.5 * (A[0].pageX + A[1].pageX),
          fe = 0.5 * (A[0].pageY + A[1].pageY);
        f.set(F, fe);
      }
    }
    function We() {
      if (A.length === 1) v.set(A[0].pageX, A[0].pageY);
      else {
        const F = 0.5 * (A[0].pageX + A[1].pageX),
          fe = 0.5 * (A[0].pageY + A[1].pageY);
        v.set(F, fe);
      }
    }
    function pt() {
      const F = A[0].pageX - A[1].pageX,
        fe = A[0].pageY - A[1].pageY,
        ne = Math.sqrt(F * F + fe * fe);
      h.set(0, ne);
    }
    function Ye() {
      i.enableZoom && pt(), i.enablePan && We();
    }
    function j() {
      i.enableZoom && pt(), i.enableRotate && Ne();
    }
    function kt(F) {
      if (A.length == 1) d.set(F.pageX, F.pageY);
      else {
        const ne = Ae(F),
          Be = 0.5 * (F.pageX + ne.x),
          Pe = 0.5 * (F.pageY + ne.y);
        d.set(Be, Pe);
      }
      p.subVectors(d, f).multiplyScalar(i.rotateSpeed);
      const fe = i.domElement;
      $((2 * Math.PI * p.x) / fe.clientHeight),
        J((2 * Math.PI * p.y) / fe.clientHeight),
        f.copy(d);
    }
    function De(F) {
      if (A.length === 1) x.set(F.pageX, F.pageY);
      else {
        const fe = Ae(F),
          ne = 0.5 * (F.pageX + fe.x),
          Be = 0.5 * (F.pageY + fe.y);
        x.set(ne, Be);
      }
      m.subVectors(x, v).multiplyScalar(i.panSpeed), Q(m.x, m.y), v.copy(x);
    }
    function He(F) {
      const fe = Ae(F),
        ne = F.pageX - fe.x,
        Be = F.pageY - fe.y,
        Pe = Math.sqrt(ne * ne + Be * Be);
      _.set(0, Pe),
        g.set(0, Math.pow(_.y / h.y, i.zoomSpeed)),
        ie(g.y),
        h.copy(_);
    }
    function Ve(F) {
      i.enableZoom && He(F), i.enablePan && De(F);
    }
    function _t(F) {
      i.enableZoom && He(F), i.enableRotate && kt(F);
    }
    function qe(F) {
      i.enabled !== !1 &&
        (A.length === 0 &&
          (i.domElement.setPointerCapture(F.pointerId),
          i.domElement.addEventListener("pointermove", Xe),
          i.domElement.addEventListener("pointerup", it)),
        he(F),
        F.pointerType === "touch" ? q(F) : Pt(F));
    }
    function Xe(F) {
      i.enabled !== !1 && (F.pointerType === "touch" ? pe(F) : Ut(F));
    }
    function it(F) {
      Ie(F),
        A.length === 0 &&
          (i.domElement.releasePointerCapture(F.pointerId),
          i.domElement.removeEventListener("pointermove", Xe),
          i.domElement.removeEventListener("pointerup", it)),
        i.dispatchEvent(Ag),
        (s = r.NONE);
    }
    function Pt(F) {
      let fe;
      switch (F.button) {
        case 0:
          fe = i.mouseButtons.LEFT;
          break;
        case 1:
          fe = i.mouseButtons.MIDDLE;
          break;
        case 2:
          fe = i.mouseButtons.RIGHT;
          break;
        default:
          fe = -1;
      }
      switch (fe) {
        case ms.DOLLY:
          if (i.enableZoom === !1) return;
          z(F), (s = r.DOLLY);
          break;
        case ms.ROTATE:
          if (F.ctrlKey || F.metaKey || F.shiftKey) {
            if (i.enablePan === !1) return;
            V(F), (s = r.PAN);
          } else {
            if (i.enableRotate === !1) return;
            G(F), (s = r.ROTATE);
          }
          break;
        case ms.PAN:
          if (F.ctrlKey || F.metaKey || F.shiftKey) {
            if (i.enableRotate === !1) return;
            G(F), (s = r.ROTATE);
          } else {
            if (i.enablePan === !1) return;
            V(F), (s = r.PAN);
          }
          break;
        default:
          s = r.NONE;
      }
      s !== r.NONE && i.dispatchEvent(Zu);
    }
    function Ut(F) {
      switch (s) {
        case r.ROTATE:
          if (i.enableRotate === !1) return;
          _e(F);
          break;
        case r.DOLLY:
          if (i.enableZoom === !1) return;
          ve(F);
          break;
        case r.PAN:
          if (i.enablePan === !1) return;
          we(F);
          break;
      }
    }
    function I(F) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        s !== r.NONE ||
        (F.preventDefault(), i.dispatchEvent(Zu), ye(F), i.dispatchEvent(Ag));
    }
    function T(F) {
      i.enabled === !1 || i.enablePan === !1 || ke(F);
    }
    function q(F) {
      switch ((ge(F), A.length)) {
        case 1:
          switch (i.touches.ONE) {
            case gs.ROTATE:
              if (i.enableRotate === !1) return;
              Ne(), (s = r.TOUCH_ROTATE);
              break;
            case gs.PAN:
              if (i.enablePan === !1) return;
              We(), (s = r.TOUCH_PAN);
              break;
            default:
              s = r.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case gs.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              Ye(), (s = r.TOUCH_DOLLY_PAN);
              break;
            case gs.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              j(), (s = r.TOUCH_DOLLY_ROTATE);
              break;
            default:
              s = r.NONE;
          }
          break;
        default:
          s = r.NONE;
      }
      s !== r.NONE && i.dispatchEvent(Zu);
    }
    function pe(F) {
      switch ((ge(F), s)) {
        case r.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          kt(F), i.update();
          break;
        case r.TOUCH_PAN:
          if (i.enablePan === !1) return;
          De(F), i.update();
          break;
        case r.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          Ve(F), i.update();
          break;
        case r.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          _t(F), i.update();
          break;
        default:
          s = r.NONE;
      }
    }
    function le(F) {
      i.enabled !== !1 && F.preventDefault();
    }
    function he(F) {
      A.push(F);
    }
    function Ie(F) {
      delete U[F.pointerId];
      for (let fe = 0; fe < A.length; fe++)
        if (A[fe].pointerId == F.pointerId) {
          A.splice(fe, 1);
          return;
        }
    }
    function ge(F) {
      let fe = U[F.pointerId];
      fe === void 0 && ((fe = new Ge()), (U[F.pointerId] = fe)),
        fe.set(F.pageX, F.pageY);
    }
    function Ae(F) {
      const fe = F.pointerId === A[0].pointerId ? A[1] : A[0];
      return U[fe.pointerId];
    }
    i.domElement.addEventListener("contextmenu", le),
      i.domElement.addEventListener("pointerdown", qe),
      i.domElement.addEventListener("pointercancel", it),
      i.domElement.addEventListener("wheel", I, { passive: !1 }),
      this.update();
  }
}
function bg(n, e) {
  if (e === hE)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      n
    );
  if (e === ed || e === lv) {
    let t = n.getIndex();
    if (t === null) {
      const o = [],
        a = n.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++) o.push(l);
        n.setIndex(o), (t = n.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          n
        );
    }
    const i = t.count - 2,
      r = [];
    if (e === ed)
      for (let o = 1; o <= i; o++)
        r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
    else
      for (let o = 0; o < i; o++)
        o % 2 === 0
          ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
          : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
    r.length / 3 !== i &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = n.clone();
    return s.setIndex(r), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      n
    );
}
class PR extends hs {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new OR(t);
      }),
      this.register(function (t) {
        return new WR(t);
      }),
      this.register(function (t) {
        return new XR(t);
      }),
      this.register(function (t) {
        return new jR(t);
      }),
      this.register(function (t) {
        return new kR(t);
      }),
      this.register(function (t) {
        return new BR(t);
      }),
      this.register(function (t) {
        return new zR(t);
      }),
      this.register(function (t) {
        return new HR(t);
      }),
      this.register(function (t) {
        return new UR(t);
      }),
      this.register(function (t) {
        return new VR(t);
      }),
      this.register(function (t) {
        return new FR(t);
      }),
      this.register(function (t) {
        return new GR(t);
      }),
      this.register(function (t) {
        return new NR(t);
      }),
      this.register(function (t) {
        return new YR(t);
      }),
      this.register(function (t) {
        return new qR(t);
      });
  }
  load(e, t, i, r) {
    const s = this;
    let o;
    this.resourcePath !== ""
      ? (o = this.resourcePath)
      : this.path !== ""
      ? (o = this.path)
      : (o = ad.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (c) {
        r ? r(c) : console.error(c),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new xh(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            s.parse(
              c,
              o,
              function (u) {
                t(u), s.manager.itemEnd(e);
              },
              a
            );
          } catch (u) {
            a(u);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, r) {
    let s;
    const o = {},
      a = {},
      l = new TextDecoder();
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === kv) {
        try {
          o[rt.KHR_BINARY_GLTF] = new KR(e);
        } catch (f) {
          r && r(f);
          return;
        }
        s = JSON.parse(o[rt.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(l.decode(e));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new lb(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const f = this.pluginCallbacks[u](c);
      f.name ||
        console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
        (a[f.name] = f),
        (o[f.name] = !0);
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const f = s.extensionsUsed[u],
          d = s.extensionsRequired || [];
        switch (f) {
          case rt.KHR_MATERIALS_UNLIT:
            o[f] = new DR();
            break;
          case rt.KHR_DRACO_MESH_COMPRESSION:
            o[f] = new ZR(s, this.dracoLoader);
            break;
          case rt.KHR_TEXTURE_TRANSFORM:
            o[f] = new $R();
            break;
          case rt.KHR_MESH_QUANTIZATION:
            o[f] = new QR();
            break;
          default:
            d.indexOf(f) >= 0 &&
              a[f] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + f + '".');
        }
      }
    c.setExtensions(o), c.setPlugins(a), c.parse(i, r);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.parse(e, t, r, s);
    });
  }
}
function IR() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const rt = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class NR {
  constructor(e) {
    (this.parser = e),
      (this.name = rt.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let r = t.cache.get(i);
    if (r) return r;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const u = new Ke(16777215);
    l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], Vt);
    const f = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new Fv(u)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new _R(u)), (c.distance = f);
        break;
      case "spot":
        (c = new mR(u)),
          (c.distance = f),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      ar(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (r = Promise.resolve(c)),
      t.cache.add(i, r),
      r
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(t.cache, a, l);
        });
  }
}
class DR {
  constructor() {
    this.name = rt.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Zr;
  }
  extendParams(e, t, i) {
    const r = [];
    (e.color = new Ke(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.setRGB(o[0], o[1], o[2], Vt), (e.opacity = o[3]);
      }
      s.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", s.baseColorTexture, Rt));
    }
    return Promise.all(r);
  }
}
class UR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class OR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Ge(a, a);
    }
    return Promise.all(s);
  }
}
class FR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class kR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Ke(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = r.extensions[this.name];
    if (o.sheenColorFactor !== void 0) {
      const a = o.sheenColorFactor;
      t.sheenColor.setRGB(a[0], a[1], a[2], Vt);
    }
    return (
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Rt)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class BR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class zR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (
      (t.attenuationColor = new Ke().setRGB(a[0], a[1], a[2], Vt)),
      Promise.all(s)
    );
  }
}
class HR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class VR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Ke().setRGB(a[0], a[1], a[2], Vt)),
      o.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "specularColorMap", o.specularColorTexture, Rt)
        ),
      Promise.all(s)
    );
  }
}
class GR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : Dr;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
      o.anisotropyRotation !== void 0 &&
        (t.anisotropyRotation = o.anisotropyRotation),
      o.anisotropyTexture !== void 0 &&
        s.push(i.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class WR {
  constructor(e) {
    (this.parser = e), (this.name = rt.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const s = r.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class XR {
  constructor(e) {
    (this.parser = e),
      (this.name = rt.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class jR {
  constructor(e) {
    (this.parser = e),
      (this.name = rt.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class YR {
  constructor(e) {
    (this.name = rt.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency("buffer", r.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          c = r.byteLength || 0,
          u = r.count,
          f = r.byteStride,
          d = new Uint8Array(a, l, c);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(u, f, d, r.mode, r.filter)
              .then(function (p) {
                return p.buffer;
              })
          : o.ready.then(function () {
              const p = new ArrayBuffer(u * f);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(p),
                  u,
                  f,
                  d,
                  r.mode,
                  r.filter
                ),
                p
              );
            });
      });
    } else return null;
  }
}
class qR {
  constructor(e) {
    (this.name = rt.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0)
      return null;
    const r = t.meshes[i.mesh];
    for (const c of r.primitives)
      if (
        c.mode !== Hn.TRIANGLES &&
        c.mode !== Hn.TRIANGLE_STRIP &&
        c.mode !== Hn.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const o = i.extensions[this.name].attributes,
      a = [],
      l = {};
    for (const c in o)
      a.push(
        this.parser
          .getDependency("accessor", o[c])
          .then((u) => ((l[c] = u), l[c]))
      );
    return a.length < 1
      ? null
      : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then((c) => {
          const u = c.pop(),
            f = u.isGroup ? u.children : [u],
            d = c[0].count,
            p = [];
          for (const v of f) {
            const x = new tt(),
              m = new B(),
              h = new Si(),
              _ = new B(1, 1, 1),
              g = new $A(v.geometry, v.material, d);
            for (let E = 0; E < d; E++)
              l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, E),
                l.ROTATION && h.fromBufferAttribute(l.ROTATION, E),
                l.SCALE && _.fromBufferAttribute(l.SCALE, E),
                g.setMatrixAt(E, x.compose(m, h, _));
            for (const E in l)
              if (E === "_COLOR_0") {
                const w = l[E];
                g.instanceColor = new sd(w.array, w.itemSize, w.normalized);
              } else
                E !== "TRANSLATION" &&
                  E !== "ROTATION" &&
                  E !== "SCALE" &&
                  v.geometry.setAttribute(E, l[E]);
            Ct.prototype.copy.call(g, v),
              this.parser.assignFinalMaterial(g),
              p.push(g);
          }
          return u.isGroup ? (u.clear(), u.add(...p), u) : p[0];
        }));
  }
}
const kv = "glTF",
  Go = 12,
  Cg = { JSON: 1313821514, BIN: 5130562 };
class KR {
  constructor(e) {
    (this.name = rt.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, Go),
      i = new TextDecoder();
    if (
      ((this.header = {
        magic: i.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== kv)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const r = this.header.length - Go,
      s = new DataView(e, Go);
    let o = 0;
    for (; o < r; ) {
      const a = s.getUint32(o, !0);
      o += 4;
      const l = s.getUint32(o, !0);
      if (((o += 4), l === Cg.JSON)) {
        const c = new Uint8Array(e, Go + o, a);
        this.content = i.decode(c);
      } else if (l === Cg.BIN) {
        const c = Go + o;
        this.body = e.slice(c, c + a);
      }
      o += a;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class ZR {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = rt.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      c = {};
    for (const u in o) {
      const f = ld[u] || u.toLowerCase();
      a[f] = o[u];
    }
    for (const u in e.attributes) {
      const f = ld[u] || u.toLowerCase();
      if (o[u] !== void 0) {
        const d = i.accessors[e.attributes[u]],
          p = to[d.componentType];
        (c[f] = p.name), (l[f] = d.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (u) {
      return new Promise(function (f) {
        r.decodeDracoFile(
          u,
          function (d) {
            for (const p in d.attributes) {
              const v = d.attributes[p],
                x = l[p];
              x !== void 0 && (v.normalized = x);
            }
            f(d);
          },
          a,
          c
        );
      });
    });
  }
}
class $R {
  constructor() {
    this.name = rt.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class QR {
  constructor() {
    this.name = rt.KHR_MESH_QUANTIZATION;
  }
}
class Bv extends Da {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r;
    for (let o = 0; o !== r; o++) t[o] = i[s + o];
    return t;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      c = a * 3,
      u = r - t,
      f = (i - t) / u,
      d = f * f,
      p = d * f,
      v = e * c,
      x = v - c,
      m = -2 * p + 3 * d,
      h = p - d,
      _ = 1 - m,
      g = h - d + f;
    for (let E = 0; E !== a; E++) {
      const w = o[x + E + a],
        L = o[x + E + l] * u,
        A = o[v + E + a],
        U = o[v + E] * u;
      s[E] = _ * w + g * L + m * A + h * U;
    }
    return s;
  }
}
const JR = new Si();
class eb extends Bv {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r);
    return JR.fromArray(s).normalize().toArray(s), s;
  }
}
const Hn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  to = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  Lg = { 9728: qt, 9729: zt, 9984: Jf, 9985: ev, 9986: Vl, 9987: br },
  Pg = { 33071: Sn, 33648: gc, 10497: fo },
  $u = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  ld = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  nr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  tb = { CUBICSPLINE: void 0, LINEAR: po, STEP: wa },
  Qu = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function nb(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new Vc({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Xi,
      })),
    n.DefaultMaterial
  );
}
function Hr(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function ar(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function ib(n, e, t) {
  let i = !1,
    r = !1,
    s = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const f = e[c];
    if (
      (f.POSITION !== void 0 && (i = !0),
      f.NORMAL !== void 0 && (r = !0),
      f.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break;
  }
  if (!i && !r && !s) return Promise.resolve(n);
  const o = [],
    a = [],
    l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const f = e[c];
    if (i) {
      const d =
        f.POSITION !== void 0
          ? t.getDependency("accessor", f.POSITION)
          : n.attributes.position;
      o.push(d);
    }
    if (r) {
      const d =
        f.NORMAL !== void 0
          ? t.getDependency("accessor", f.NORMAL)
          : n.attributes.normal;
      a.push(d);
    }
    if (s) {
      const d =
        f.COLOR_0 !== void 0
          ? t.getDependency("accessor", f.COLOR_0)
          : n.attributes.color;
      l.push(d);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (c) {
      const u = c[0],
        f = c[1],
        d = c[2];
      return (
        i && (n.morphAttributes.position = u),
        r && (n.morphAttributes.normal = f),
        s && (n.morphAttributes.color = d),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function rb(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function sb(n) {
  let e;
  const t = n.extensions && n.extensions[rt.KHR_DRACO_MESH_COMPRESSION];
  if (
    (t
      ? (e = "draco:" + t.bufferView + ":" + t.indices + ":" + Ju(t.attributes))
      : (e = n.indices + ":" + Ju(n.attributes) + ":" + n.mode),
    n.targets !== void 0)
  )
    for (let i = 0, r = n.targets.length; i < r; i++)
      e += ":" + Ju(n.targets[i]);
  return e;
}
function Ju(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function cd(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function ob(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const ab = new tt();
class lb {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new IR()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      r = !1,
      s = -1;
    typeof navigator < "u" &&
      ((i = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (r = navigator.userAgent.indexOf("Firefox") > -1),
      (s = r ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || i || (r && s < 98)
        ? (this.textureLoader = new Ov(this.options.manager))
        : (this.textureLoader = new yR(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new xh(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          return (
            Hr(s, a, r),
            ar(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              e(a);
            })
          );
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [c, u] of o.children.entries()) s(u, a.children[c]);
      };
    return s(i, r), (r.name += "_instance_" + e.uses[t]++), r;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          if (
            ((r = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !r)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[rt.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (s, o) {
      i.load(ad.resolveURL(t.uri, r.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        s = t.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0) {
      const o = $u[r.type],
        a = to[r.componentType],
        l = r.normalized === !0,
        c = new a(r.count * o);
      return Promise.resolve(new gn(c, o, l));
    }
    const s = [];
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = $u[r.type],
          c = to[r.componentType],
          u = c.BYTES_PER_ELEMENT,
          f = u * l,
          d = r.byteOffset || 0,
          p =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          v = r.normalized === !0;
        let x, m;
        if (p && p !== f) {
          const h = Math.floor(d / p),
            _ =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              h +
              ":" +
              r.count;
          let g = t.cache.get(_);
          g ||
            ((x = new c(a, h * p, (r.count * p) / u)),
            (g = new jA(x, p / u)),
            t.cache.add(_, g)),
            (m = new mh(g, l, (d % p) / u, v));
        } else a === null ? (x = new c(r.count * l)) : (x = new c(a, d, r.count * l)), (m = new gn(x, l, v));
        if (r.sparse !== void 0) {
          const h = $u.SCALAR,
            _ = to[r.sparse.indices.componentType],
            g = r.sparse.indices.byteOffset || 0,
            E = r.sparse.values.byteOffset || 0,
            w = new _(o[1], g, r.sparse.count * h),
            L = new c(o[2], E, r.sparse.count * l);
          a !== null && (m = new gn(m.array.slice(), m.itemSize, m.normalized));
          for (let A = 0, U = w.length; A < U; A++) {
            const M = w[A];
            if (
              (m.setX(M, L[A * l]),
              l >= 2 && m.setY(M, L[A * l + 1]),
              l >= 3 && m.setZ(M, L[A * l + 2]),
              l >= 4 && m.setW(M, L[A * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return m;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, i)
      .then(function (u) {
        (u.flipY = !1),
          (u.name = o.name || a.name || ""),
          u.name === "" &&
            typeof a.uri == "string" &&
            a.uri.startsWith("data:image/") === !1 &&
            (u.name = a.uri);
        const d = (s.samplers || {})[o.sampler] || {};
        return (
          (u.magFilter = Lg[d.magFilter] || zt),
          (u.minFilter = Lg[d.minFilter] || br),
          (u.wrapS = Pg[d.wrapS] || fo),
          (u.wrapT = Pg[d.wrapT] || fo),
          r.associations.set(u, { textures: e }),
          u
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((f) => f.clone());
    const o = r.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      c = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function (f) {
        c = !0;
        const d = new Blob([f], { type: o.mimeType });
        return (l = a.createObjectURL(d)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const u = Promise.resolve(l)
      .then(function (f) {
        return new Promise(function (d, p) {
          let v = d;
          t.isImageBitmapLoader === !0 &&
            (v = function (x) {
              const m = new tn(x);
              (m.needsUpdate = !0), d(m);
            }),
            t.load(ad.resolveURL(f, s.path), v, void 0, p);
        });
      })
      .then(function (f) {
        return (
          c === !0 && a.revokeObjectURL(l),
          (f.userData.mimeType = o.mimeType || ob(o.uri)),
          f
        );
      })
      .catch(function (f) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), f);
      });
    return (this.sourceCache[e] = u), u;
  }
  assignTexture(e, t, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (o) {
      if (!o) return null;
      if (
        (i.texCoord !== void 0 &&
          i.texCoord > 0 &&
          ((o = o.clone()), (o.channel = i.texCoord)),
        s.extensions[rt.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[rt.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          (o = s.extensions[rt.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l);
        }
      }
      return r !== void 0 && (o.colorSpace = r), (e[t] = o), o;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new Iv()),
        xi.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new Pv()),
        xi.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        this.cache.add(a, l)),
        (i = l);
    }
    if (r || s || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      r && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l);
    }
    e.material = i;
  }
  getMaterialType() {
    return Vc;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      c = [];
    if (l[rt.KHR_MATERIALS_UNLIT]) {
      const f = r[rt.KHR_MATERIALS_UNLIT];
      (o = f.getMaterialType()), c.push(f.extendParams(a, s, t));
    } else {
      const f = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Ke(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(f.baseColorFactor))
      ) {
        const d = f.baseColorFactor;
        a.color.setRGB(d[0], d[1], d[2], Vt), (a.opacity = d[3]);
      }
      f.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(a, "map", f.baseColorTexture, Rt)),
        (a.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1),
        (a.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1),
        f.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(a, "metalnessMap", f.metallicRoughnessTexture)
          ),
          c.push(
            t.assignTexture(a, "roughnessMap", f.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (d) {
          return d.getMaterialType && d.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (d) {
              return d.extendMaterialParams && d.extendMaterialParams(e, a);
            })
          )
        );
    }
    s.doubleSided === !0 && (a.side = oi);
    const u = s.alphaMode || Qu.OPAQUE;
    if (
      (u === Qu.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          u === Qu.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== Zr &&
        (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new Ge(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const f = s.normalTexture.scale;
      a.normalScale.set(f, f);
    }
    if (
      (s.occlusionTexture !== void 0 &&
        o !== Zr &&
        (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 && o !== Zr)
    ) {
      const f = s.emissiveFactor;
      a.emissive = new Ke().setRGB(f[0], f[1], f[2], Vt);
    }
    return (
      s.emissiveTexture !== void 0 &&
        o !== Zr &&
        c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Rt)),
      Promise.all(c).then(function () {
        const f = new o(a);
        return (
          s.name && (f.name = s.name),
          ar(f, s),
          t.associations.set(f, { materials: e }),
          s.extensions && Hr(r, f, s),
          f
        );
      })
    );
  }
  createUniqueName(e) {
    const t = ut.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache;
    function s(a) {
      return i[rt.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return Ig(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = sb(c),
        f = r[u];
      if (f) o.push(f.promise);
      else {
        let d;
        c.extensions && c.extensions[rt.KHR_DRACO_MESH_COMPRESSION]
          ? (d = s(c))
          : (d = Ig(new fi(), c, t)),
          (r[u] = { primitive: c, promise: d }),
          o.push(d);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const u =
        o[l].material === void 0
          ? nb(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(u);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const c = l.slice(0, l.length - 1),
          u = l[l.length - 1],
          f = [];
        for (let p = 0, v = u.length; p < v; p++) {
          const x = u[p],
            m = o[p];
          let h;
          const _ = c[p];
          if (
            m.mode === Hn.TRIANGLES ||
            m.mode === Hn.TRIANGLE_STRIP ||
            m.mode === Hn.TRIANGLE_FAN ||
            m.mode === void 0
          )
            (h = s.isSkinnedMesh === !0 ? new qA(x, _) : new Dn(x, _)),
              h.isSkinnedMesh === !0 && h.normalizeSkinWeights(),
              m.mode === Hn.TRIANGLE_STRIP
                ? (h.geometry = bg(h.geometry, lv))
                : m.mode === Hn.TRIANGLE_FAN &&
                  (h.geometry = bg(h.geometry, ed));
          else if (m.mode === Hn.LINES) h = new QA(x, _);
          else if (m.mode === Hn.LINE_STRIP) h = new _h(x, _);
          else if (m.mode === Hn.LINE_LOOP) h = new JA(x, _);
          else if (m.mode === Hn.POINTS) h = new eR(x, _);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + m.mode
            );
          Object.keys(h.geometry.morphAttributes).length > 0 && rb(h, s),
            (h.name = t.createUniqueName(s.name || "mesh_" + e)),
            ar(h, s),
            m.extensions && Hr(r, h, m),
            t.assignFinalMaterial(h),
            f.push(h);
        }
        for (let p = 0, v = f.length; p < v; p++)
          t.associations.set(f[p], { meshes: e, primitives: p });
        if (f.length === 1) return s.extensions && Hr(r, f[0], s), f[0];
        const d = new $r();
        s.extensions && Hr(r, d, s), t.associations.set(d, { meshes: e });
        for (let p = 0, v = f.length; p < v; p++) d.add(f[p]);
        return d;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new pn(
            uh.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (t = new hh(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      ar(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let r = 0, s = t.joints.length; r < s; r++)
      i.push(this._loadNodeShallow(t.joints[r]));
    return (
      t.inverseBindMatrices !== void 0
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (r) {
        const s = r.pop(),
          o = r,
          a = [],
          l = [];
        for (let c = 0, u = o.length; c < u; c++) {
          const f = o[c];
          if (f) {
            a.push(f);
            const d = new tt();
            s !== null && d.fromArray(s.array, c * 16), l.push(d);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[c]
            );
        }
        return new gh(a, l);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      i = this,
      r = t.animations[e],
      s = r.name ? r.name : "animation_" + e,
      o = [],
      a = [],
      l = [],
      c = [],
      u = [];
    for (let f = 0, d = r.channels.length; f < d; f++) {
      const p = r.channels[f],
        v = r.samplers[p.sampler],
        x = p.target,
        m = x.node,
        h = r.parameters !== void 0 ? r.parameters[v.input] : v.input,
        _ = r.parameters !== void 0 ? r.parameters[v.output] : v.output;
      x.node !== void 0 &&
        (o.push(this.getDependency("node", m)),
        a.push(this.getDependency("accessor", h)),
        l.push(this.getDependency("accessor", _)),
        c.push(v),
        u.push(x));
    }
    return Promise.all([
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
      Promise.all(c),
      Promise.all(u),
    ]).then(function (f) {
      const d = f[0],
        p = f[1],
        v = f[2],
        x = f[3],
        m = f[4],
        h = [];
      for (let _ = 0, g = d.length; _ < g; _++) {
        const E = d[_],
          w = p[_],
          L = v[_],
          A = x[_],
          U = m[_];
        if (E === void 0) continue;
        E.updateMatrix && E.updateMatrix();
        const M = i._createAnimationTracks(E, w, L, A, U);
        if (M) for (let b = 0; b < M.length; b++) h.push(M[b]);
      }
      return new aR(s, void 0, h);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s);
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, c = r.weights.length; l < c; l++)
                    a.morphTargetInfluences[l] = r.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e],
      s = i._loadNodeShallow(e),
      o = [],
      a = r.children || [];
    for (let c = 0, u = a.length; c < u; c++)
      o.push(i.getDependency("node", a[c]));
    const l =
      r.skin === void 0
        ? Promise.resolve(null)
        : i.getDependency("skin", r.skin);
    return Promise.all([s, Promise.all(o), l]).then(function (c) {
      const u = c[0],
        f = c[1],
        d = c[2];
      d !== null &&
        u.traverse(function (p) {
          p.isSkinnedMesh && p.bind(d, ab);
        });
      for (let p = 0, v = f.length; p < v; p++) u.add(f[p]);
      return u;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      i = this.extensions,
      r = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : "",
      a = [],
      l = r._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
    return (
      l && a.push(l),
      s.camera !== void 0 &&
        a.push(
          r.getDependency("camera", s.camera).then(function (c) {
            return r._getNodeRef(r.cameraCache, s.camera, c);
          })
        ),
      r
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        })
        .forEach(function (c) {
          a.push(c);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (c) {
        let u;
        if (
          (s.isBone === !0
            ? (u = new Cv())
            : c.length > 1
            ? (u = new $r())
            : c.length === 1
            ? (u = c[0])
            : (u = new Ct()),
          u !== c[0])
        )
          for (let f = 0, d = c.length; f < d; f++) u.add(c[f]);
        if (
          (s.name && ((u.userData.name = s.name), (u.name = o)),
          ar(u, s),
          s.extensions && Hr(i, u, s),
          s.matrix !== void 0)
        ) {
          const f = new tt();
          f.fromArray(s.matrix), u.applyMatrix4(f);
        } else s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
        return (
          r.associations.has(u) || r.associations.set(u, {}),
          (r.associations.get(u).nodes = e),
          u
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      r = this,
      s = new $r();
    i.name && (s.name = r.createUniqueName(i.name)),
      ar(s, i),
      i.extensions && Hr(t, s, i);
    const o = i.nodes || [],
      a = [];
    for (let l = 0, c = o.length; l < c; l++)
      a.push(r.getDependency("node", o[l]));
    return Promise.all(a).then(function (l) {
      for (let u = 0, f = l.length; u < f; u++) s.add(l[u]);
      const c = (u) => {
        const f = new Map();
        for (const [d, p] of r.associations)
          (d instanceof xi || d instanceof tn) && f.set(d, p);
        return (
          u.traverse((d) => {
            const p = r.associations.get(d);
            p != null && f.set(d, p);
          }),
          f
        );
      };
      return (r.associations = c(s)), s;
    });
  }
  _createAnimationTracks(e, t, i, r, s) {
    const o = [],
      a = e.name ? e.name : e.uuid,
      l = [];
    nr[s.path] === nr.weights
      ? e.traverse(function (d) {
          d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
        })
      : l.push(a);
    let c;
    switch (nr[s.path]) {
      case nr.weights:
        c = _o;
        break;
      case nr.rotation:
        c = cs;
        break;
      case nr.position:
      case nr.scale:
        c = vo;
        break;
      default:
        switch (i.itemSize) {
          case 1:
            c = _o;
            break;
          case 2:
          case 3:
          default:
            c = vo;
            break;
        }
        break;
    }
    const u = r.interpolation !== void 0 ? tb[r.interpolation] : po,
      f = this._getArrayFromAccessor(i);
    for (let d = 0, p = l.length; d < p; d++) {
      const v = new c(l[d] + "." + nr[s.path], t.array, f, u);
      r.interpolation === "CUBICSPLINE" &&
        this._createCubicSplineTrackInterpolant(v),
        o.push(v);
    }
    return o;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const i = cd(t.constructor),
        r = new Float32Array(t.length);
      for (let s = 0, o = t.length; s < o; s++) r[s] = t[s] * i;
      t = r;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (i) {
      const r = this instanceof cs ? eb : Bv;
      return new r(this.times, this.values, this.getValueSize() / 3, i);
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function cb(n, e, t) {
  const i = e.attributes,
    r = new Yi();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      l = a.min,
      c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (r.set(new B(l[0], l[1], l[2]), new B(c[0], c[1], c[2])), a.normalized)
      ) {
        const u = cd(to[a.componentType]);
        r.min.multiplyScalar(u), r.max.multiplyScalar(u);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new B(),
      l = new B();
    for (let c = 0, u = s.length; c < u; c++) {
      const f = s[c];
      if (f.POSITION !== void 0) {
        const d = t.json.accessors[f.POSITION],
          p = d.min,
          v = d.max;
        if (p !== void 0 && v !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(p[0]), Math.abs(v[0]))),
            l.setY(Math.max(Math.abs(p[1]), Math.abs(v[1]))),
            l.setZ(Math.max(Math.abs(p[2]), Math.abs(v[2]))),
            d.normalized)
          ) {
            const x = cd(to[d.componentType]);
            l.multiplyScalar(x);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    r.expandByVector(a);
  }
  n.boundingBox = r;
  const o = new Ei();
  r.getCenter(o.center),
    (o.radius = r.min.distanceTo(r.max) / 2),
    (n.boundingSphere = o);
}
function Ig(n, e, t) {
  const i = e.attributes,
    r = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      n.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = ld[o] || o.toLowerCase();
    a in n.attributes || r.push(s(i[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    r.push(o);
  }
  return (
    lt.workingColorSpace !== Vt &&
      "COLOR_0" in i &&
      console.warn(
        `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${lt.workingColorSpace}" not supported.`
      ),
    ar(n, e),
    cb(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? ib(n, e.targets, t) : n;
    })
  );
}
class ub extends Dn {
  constructor(e, t = {}) {
    const r = [e.isCubeTexture ? "#define ENVMAP_TYPE_CUBE" : ""],
      s = `
			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}
			`,
      o =
        r.join(`
`) +
        `

				varying vec3 vWorldPosition;

				uniform float radius;
				uniform float height;
				uniform float angle;

				#ifdef ENVMAP_TYPE_CUBE

					uniform samplerCube map;

				#else

					uniform sampler2D map;

				#endif

				// From: https://www.shadertoy.com/view/4tsBD7
				float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
				{

					float d = dot ( rd, n );

					if( d > 0.0 ) { return 1e6; }

					vec3 o = ro - c;
					float t = - dot( n, o ) / d;
					vec3 q = o + rd * t;

					return ( dot( q, q ) < r * r ) ? t : 1e6;

				}

				// From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
				float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) {

					vec3 oc = ro - ce;
					float b = dot( oc, rd );
					float c = dot( oc, oc ) - ra * ra;
					float h = b * b - c;

					if( h < 0.0 ) { return -1.0; }

					h = sqrt( h );

					return - b + h;

				}

				vec3 project() {

					vec3 p = normalize( vWorldPosition );
					vec3 camPos = cameraPosition;
					camPos.y -= height;

					float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
					if( intersection > 0.0 ) {

						vec3 h = vec3( 0.0, - height, 0.0 );
						float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
						p = ( camPos + min( intersection, intersection2 ) * p ) / radius;

					} else {

						p = vec3( 0.0, 1.0, 0.0 );

					}

					return p;

				}

				#include <common>

				void main() {

					vec3 projectedWorldPosition = project();

					#ifdef ENVMAP_TYPE_CUBE

						vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;

					#else

						vec3 direction = normalize( projectedWorldPosition );
						vec2 uv = equirectUv( direction );
						vec3 outcolor = texture2D( map, uv ).rgb;

					#endif

					gl_FragColor = vec4( outcolor, 1.0 );

					#include <tonemapping_fragment>
					#include <colorspace_fragment>

				}
				`,
      a = {
        map: { value: e },
        height: { value: t.height || 15 },
        radius: { value: t.radius || 100 },
      },
      l = new yh(1, 16),
      c = new Cr({ uniforms: a, fragmentShader: o, vertexShader: s, side: oi });
    super(l, c);
  }
  set radius(e) {
    this.material.uniforms.radius.value = e;
  }
  get radius() {
    return this.material.uniforms.radius.value;
  }
  set height(e) {
    this.material.uniforms.height.value = e;
  }
  get height() {
    return this.material.uniforms.height.value;
  }
}
const fb = "_loader_x92wy_1",
  db = "_three_x92wy_31",
  Ng = { loader: fb, three: db };
/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/ var Dg = function (n) {
  return URL.createObjectURL(new Blob([n], { type: "text/javascript" }));
};
try {
  URL.revokeObjectURL(Dg(""));
} catch {
  Dg = function (e) {
    return "data:application/javascript;charset=UTF-8," + encodeURI(e);
  };
}
var Wn = Uint8Array,
  hr = Uint16Array,
  ud = Uint32Array,
  zv = new Wn([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  Hv = new Wn([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  hb = new Wn([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  Vv = function (n, e) {
    for (var t = new hr(31), i = 0; i < 31; ++i) t[i] = e += 1 << n[i - 1];
    for (var r = new ud(t[30]), i = 1; i < 30; ++i)
      for (var s = t[i]; s < t[i + 1]; ++s) r[s] = ((s - t[i]) << 5) | i;
    return [t, r];
  },
  Gv = Vv(zv, 2),
  Wv = Gv[0],
  pb = Gv[1];
(Wv[28] = 258), (pb[258] = 28);
var mb = Vv(Hv, 0),
  gb = mb[0],
  fd = new hr(32768);
for (var St = 0; St < 32768; ++St) {
  var ir = ((St & 43690) >>> 1) | ((St & 21845) << 1);
  (ir = ((ir & 52428) >>> 2) | ((ir & 13107) << 2)),
    (ir = ((ir & 61680) >>> 4) | ((ir & 3855) << 4)),
    (fd[St] = (((ir & 65280) >>> 8) | ((ir & 255) << 8)) >>> 1);
}
var aa = function (n, e, t) {
    for (var i = n.length, r = 0, s = new hr(e); r < i; ++r) ++s[n[r] - 1];
    var o = new hr(e);
    for (r = 0; r < e; ++r) o[r] = (o[r - 1] + s[r - 1]) << 1;
    var a;
    if (t) {
      a = new hr(1 << e);
      var l = 15 - e;
      for (r = 0; r < i; ++r)
        if (n[r])
          for (
            var c = (r << 4) | n[r],
              u = e - n[r],
              f = o[n[r] - 1]++ << u,
              d = f | ((1 << u) - 1);
            f <= d;
            ++f
          )
            a[fd[f] >>> l] = c;
    } else
      for (a = new hr(i), r = 0; r < i; ++r)
        n[r] && (a[r] = fd[o[n[r] - 1]++] >>> (15 - n[r]));
    return a;
  },
  Ua = new Wn(288);
for (var St = 0; St < 144; ++St) Ua[St] = 8;
for (var St = 144; St < 256; ++St) Ua[St] = 9;
for (var St = 256; St < 280; ++St) Ua[St] = 7;
for (var St = 280; St < 288; ++St) Ua[St] = 8;
var Xv = new Wn(32);
for (var St = 0; St < 32; ++St) Xv[St] = 5;
var _b = aa(Ua, 9, 1),
  vb = aa(Xv, 5, 1),
  ef = function (n) {
    for (var e = n[0], t = 1; t < n.length; ++t) n[t] > e && (e = n[t]);
    return e;
  },
  ti = function (n, e, t) {
    var i = (e / 8) | 0;
    return ((n[i] | (n[i + 1] << 8)) >> (e & 7)) & t;
  },
  tf = function (n, e) {
    var t = (e / 8) | 0;
    return (n[t] | (n[t + 1] << 8) | (n[t + 2] << 16)) >> (e & 7);
  },
  yb = function (n) {
    return ((n / 8) | 0) + (n & 7 && 1);
  },
  xb = function (n, e, t) {
    (e == null || e < 0) && (e = 0),
      (t == null || t > n.length) && (t = n.length);
    var i = new (n instanceof hr ? hr : n instanceof ud ? ud : Wn)(t - e);
    return i.set(n.subarray(e, t)), i;
  },
  Sb = function (n, e, t) {
    var i = n.length;
    if (!i || (t && !t.l && i < 5)) return e || new Wn(0);
    var r = !e || t,
      s = !t || t.i;
    t || (t = {}), e || (e = new Wn(i * 3));
    var o = function (ye) {
        var ke = e.length;
        if (ye > ke) {
          var Ne = new Wn(Math.max(ke * 2, ye));
          Ne.set(e), (e = Ne);
        }
      },
      a = t.f || 0,
      l = t.p || 0,
      c = t.b || 0,
      u = t.l,
      f = t.d,
      d = t.m,
      p = t.n,
      v = i * 8;
    do {
      if (!u) {
        t.f = a = ti(n, l, 1);
        var x = ti(n, l + 1, 3);
        if (((l += 3), x))
          if (x == 1) (u = _b), (f = vb), (d = 9), (p = 5);
          else if (x == 2) {
            var g = ti(n, l, 31) + 257,
              E = ti(n, l + 10, 15) + 4,
              w = g + ti(n, l + 5, 31) + 1;
            l += 14;
            for (var L = new Wn(w), A = new Wn(19), U = 0; U < E; ++U)
              A[hb[U]] = ti(n, l + U * 3, 7);
            l += E * 3;
            for (
              var M = ef(A), b = (1 << M) - 1, $ = aa(A, M, 1), U = 0;
              U < w;

            ) {
              var J = $[ti(n, l, b)];
              l += J & 15;
              var m = J >>> 4;
              if (m < 16) L[U++] = m;
              else {
                var se = 0,
                  H = 0;
                for (
                  m == 16
                    ? ((H = 3 + ti(n, l, 3)), (l += 2), (se = L[U - 1]))
                    : m == 17
                    ? ((H = 3 + ti(n, l, 7)), (l += 3))
                    : m == 18 && ((H = 11 + ti(n, l, 127)), (l += 7));
                  H--;

                )
                  L[U++] = se;
              }
            }
            var Q = L.subarray(0, g),
              ie = L.subarray(g);
            (d = ef(Q)), (p = ef(ie)), (u = aa(Q, d, 1)), (f = aa(ie, p, 1));
          } else throw "invalid block type";
        else {
          var m = yb(l) + 4,
            h = n[m - 4] | (n[m - 3] << 8),
            _ = m + h;
          if (_ > i) {
            if (s) throw "unexpected EOF";
            break;
          }
          r && o(c + h),
            e.set(n.subarray(m, _), c),
            (t.b = c += h),
            (t.p = l = _ * 8);
          continue;
        }
        if (l > v) {
          if (s) throw "unexpected EOF";
          break;
        }
      }
      r && o(c + 131072);
      for (var te = (1 << d) - 1, W = (1 << p) - 1, K = l; ; K = l) {
        var se = u[tf(n, l) & te],
          G = se >>> 4;
        if (((l += se & 15), l > v)) {
          if (s) throw "unexpected EOF";
          break;
        }
        if (!se) throw "invalid length/literal";
        if (G < 256) e[c++] = G;
        else if (G == 256) {
          (K = l), (u = null);
          break;
        } else {
          var z = G - 254;
          if (G > 264) {
            var U = G - 257,
              V = zv[U];
            (z = ti(n, l, (1 << V) - 1) + Wv[U]), (l += V);
          }
          var _e = f[tf(n, l) & W],
            ve = _e >>> 4;
          if (!_e) throw "invalid distance";
          l += _e & 15;
          var ie = gb[ve];
          if (ve > 3) {
            var V = Hv[ve];
            (ie += tf(n, l) & ((1 << V) - 1)), (l += V);
          }
          if (l > v) {
            if (s) throw "unexpected EOF";
            break;
          }
          r && o(c + 131072);
          for (var we = c + z; c < we; c += 4)
            (e[c] = e[c - ie]),
              (e[c + 1] = e[c + 1 - ie]),
              (e[c + 2] = e[c + 2 - ie]),
              (e[c + 3] = e[c + 3 - ie]);
          c = we;
        }
      }
      (t.l = u),
        (t.p = K),
        (t.b = c),
        u && ((a = 1), (t.m = d), (t.d = f), (t.n = p));
    } while (!a);
    return c == e.length ? e : xb(e, 0, c);
  },
  Eb = new Wn(0),
  Mb = function (n) {
    if ((n[0] & 15) != 8 || n[0] >>> 4 > 7 || ((n[0] << 8) | n[1]) % 31)
      throw "invalid zlib data";
    if (n[1] & 32) throw "invalid zlib data: preset dictionaries not supported";
  };
function Cl(n, e) {
  return Sb((Mb(n), n.subarray(2, -4)), e);
}
var Tb = typeof TextDecoder < "u" && new TextDecoder(),
  wb = 0;
try {
  Tb.decode(Eb, { stream: !0 }), (wb = 1);
} catch {}
class Ab extends hR {
  constructor(e) {
    super(e), (this.type = ki);
  }
  parse(e) {
    const M = Math.pow(2.7182818, 2.2);
    function b(S, R) {
      let D = 0;
      for (let C = 0; C < 65536; ++C)
        (C == 0 || S[C >> 3] & (1 << (C & 7))) && (R[D++] = C);
      const y = D - 1;
      for (; D < 65536; ) R[D++] = 0;
      return y;
    }
    function $(S) {
      for (let R = 0; R < 16384; R++)
        (S[R] = {}), (S[R].len = 0), (S[R].lit = 0), (S[R].p = null);
    }
    const J = { l: 0, c: 0, lc: 0 };
    function se(S, R, D, y, C) {
      for (; D < S; ) (R = (R << 8) | Be(y, C)), (D += 8);
      (D -= S), (J.l = (R >> D) & ((1 << S) - 1)), (J.c = R), (J.lc = D);
    }
    const H = new Array(59);
    function Q(S) {
      for (let D = 0; D <= 58; ++D) H[D] = 0;
      for (let D = 0; D < 65537; ++D) H[S[D]] += 1;
      let R = 0;
      for (let D = 58; D > 0; --D) {
        const y = (R + H[D]) >> 1;
        (H[D] = R), (R = y);
      }
      for (let D = 0; D < 65537; ++D) {
        const y = S[D];
        y > 0 && (S[D] = y | (H[y]++ << 6));
      }
    }
    function ie(S, R, D, y, C, P) {
      const N = R;
      let O = 0,
        Y = 0;
      for (; y <= C; y++) {
        if (N.value - R.value > D) return !1;
        se(6, O, Y, S, N);
        const X = J.l;
        if (((O = J.c), (Y = J.lc), (P[y] = X), X == 63)) {
          if (N.value - R.value > D)
            throw new Error("Something wrong with hufUnpackEncTable");
          se(8, O, Y, S, N);
          let Z = J.l + 6;
          if (((O = J.c), (Y = J.lc), y + Z > C + 1))
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; Z--; ) P[y++] = 0;
          y--;
        } else if (X >= 59) {
          let Z = X - 59 + 2;
          if (y + Z > C + 1)
            throw new Error("Something wrong with hufUnpackEncTable");
          for (; Z--; ) P[y++] = 0;
          y--;
        }
      }
      Q(P);
    }
    function te(S) {
      return S & 63;
    }
    function W(S) {
      return S >> 6;
    }
    function K(S, R, D, y) {
      for (; R <= D; R++) {
        const C = W(S[R]),
          P = te(S[R]);
        if (C >> P) throw new Error("Invalid table entry");
        if (P > 14) {
          const N = y[C >> (P - 14)];
          if (N.len) throw new Error("Invalid table entry");
          if ((N.lit++, N.p)) {
            const O = N.p;
            N.p = new Array(N.lit);
            for (let Y = 0; Y < N.lit - 1; ++Y) N.p[Y] = O[Y];
          } else N.p = new Array(1);
          N.p[N.lit - 1] = R;
        } else if (P) {
          let N = 0;
          for (let O = 1 << (14 - P); O > 0; O--) {
            const Y = y[(C << (14 - P)) + N];
            if (Y.len || Y.p) throw new Error("Invalid table entry");
            (Y.len = P), (Y.lit = R), N++;
          }
        }
      }
      return !0;
    }
    const G = { c: 0, lc: 0 };
    function z(S, R, D, y) {
      (S = (S << 8) | Be(D, y)), (R += 8), (G.c = S), (G.lc = R);
    }
    const V = { c: 0, lc: 0 };
    function _e(S, R, D, y, C, P, N, O, Y) {
      if (S == R) {
        y < 8 && (z(D, y, C, P), (D = G.c), (y = G.lc)), (y -= 8);
        let X = D >> y;
        if (((X = new Uint8Array([X])[0]), O.value + X > Y)) return !1;
        const Z = N[O.value - 1];
        for (; X-- > 0; ) N[O.value++] = Z;
      } else if (O.value < Y) N[O.value++] = S;
      else return !1;
      (V.c = D), (V.lc = y);
    }
    function ve(S) {
      return S & 65535;
    }
    function we(S) {
      const R = ve(S);
      return R > 32767 ? R - 65536 : R;
    }
    const ye = { a: 0, b: 0 };
    function ke(S, R) {
      const D = we(S),
        C = we(R),
        P = D + (C & 1) + (C >> 1),
        N = P,
        O = P - C;
      (ye.a = N), (ye.b = O);
    }
    function Ne(S, R) {
      const D = ve(S),
        y = ve(R),
        C = (D - (y >> 1)) & 65535,
        P = (y + C - 32768) & 65535;
      (ye.a = P), (ye.b = C);
    }
    function We(S, R, D, y, C, P, N) {
      const O = N < 16384,
        Y = D > C ? C : D;
      let X = 1,
        Z,
        re;
      for (; X <= Y; ) X <<= 1;
      for (X >>= 1, Z = X, X >>= 1; X >= 1; ) {
        re = 0;
        const ae = re + P * (C - Z),
          de = P * X,
          Se = P * Z,
          Ee = y * X,
          be = y * Z;
        let Oe, at, je, ze;
        for (; re <= ae; re += Se) {
          let ct = re;
          const Fe = re + y * (D - Z);
          for (; ct <= Fe; ct += be) {
            const mt = ct + Ee,
              un = ct + de,
              Mt = un + Ee;
            O
              ? (ke(S[ct + R], S[un + R]),
                (Oe = ye.a),
                (je = ye.b),
                ke(S[mt + R], S[Mt + R]),
                (at = ye.a),
                (ze = ye.b),
                ke(Oe, at),
                (S[ct + R] = ye.a),
                (S[mt + R] = ye.b),
                ke(je, ze),
                (S[un + R] = ye.a),
                (S[Mt + R] = ye.b))
              : (Ne(S[ct + R], S[un + R]),
                (Oe = ye.a),
                (je = ye.b),
                Ne(S[mt + R], S[Mt + R]),
                (at = ye.a),
                (ze = ye.b),
                Ne(Oe, at),
                (S[ct + R] = ye.a),
                (S[mt + R] = ye.b),
                Ne(je, ze),
                (S[un + R] = ye.a),
                (S[Mt + R] = ye.b));
          }
          if (D & X) {
            const mt = ct + de;
            O ? ke(S[ct + R], S[mt + R]) : Ne(S[ct + R], S[mt + R]),
              (Oe = ye.a),
              (S[mt + R] = ye.b),
              (S[ct + R] = Oe);
          }
        }
        if (C & X) {
          let ct = re;
          const Fe = re + y * (D - Z);
          for (; ct <= Fe; ct += be) {
            const mt = ct + Ee;
            O ? ke(S[ct + R], S[mt + R]) : Ne(S[ct + R], S[mt + R]),
              (Oe = ye.a),
              (S[mt + R] = ye.b),
              (S[ct + R] = Oe);
          }
        }
        (Z = X), (X >>= 1);
      }
      return re;
    }
    function pt(S, R, D, y, C, P, N, O, Y) {
      let X = 0,
        Z = 0;
      const re = N,
        ae = Math.trunc(y.value + (C + 7) / 8);
      for (; y.value < ae; )
        for (z(X, Z, D, y), X = G.c, Z = G.lc; Z >= 14; ) {
          const Se = (X >> (Z - 14)) & 16383,
            Ee = R[Se];
          if (Ee.len)
            (Z -= Ee.len),
              _e(Ee.lit, P, X, Z, D, y, O, Y, re),
              (X = V.c),
              (Z = V.lc);
          else {
            if (!Ee.p) throw new Error("hufDecode issues");
            let be;
            for (be = 0; be < Ee.lit; be++) {
              const Oe = te(S[Ee.p[be]]);
              for (; Z < Oe && y.value < ae; )
                z(X, Z, D, y), (X = G.c), (Z = G.lc);
              if (
                Z >= Oe &&
                W(S[Ee.p[be]]) == ((X >> (Z - Oe)) & ((1 << Oe) - 1))
              ) {
                (Z -= Oe),
                  _e(Ee.p[be], P, X, Z, D, y, O, Y, re),
                  (X = V.c),
                  (Z = V.lc);
                break;
              }
            }
            if (be == Ee.lit) throw new Error("hufDecode issues");
          }
        }
      const de = (8 - C) & 7;
      for (X >>= de, Z -= de; Z > 0; ) {
        const Se = R[(X << (14 - Z)) & 16383];
        if (Se.len)
          (Z -= Se.len),
            _e(Se.lit, P, X, Z, D, y, O, Y, re),
            (X = V.c),
            (Z = V.lc);
        else throw new Error("hufDecode issues");
      }
      return !0;
    }
    function Ye(S, R, D, y, C, P) {
      const N = { value: 0 },
        O = D.value,
        Y = ne(R, D),
        X = ne(R, D);
      D.value += 4;
      const Z = ne(R, D);
      if (((D.value += 4), Y < 0 || Y >= 65537 || X < 0 || X >= 65537))
        throw new Error("Something wrong with HUF_ENCSIZE");
      const re = new Array(65537),
        ae = new Array(16384);
      $(ae);
      const de = y - (D.value - O);
      if ((ie(S, D, de, Y, X, re), Z > 8 * (y - (D.value - O))))
        throw new Error("Something wrong with hufUncompress");
      K(re, Y, X, ae), pt(re, ae, S, D, Z, X, P, C, N);
    }
    function j(S, R, D) {
      for (let y = 0; y < D; ++y) R[y] = S[R[y]];
    }
    function kt(S) {
      for (let R = 1; R < S.length; R++) {
        const D = S[R - 1] + S[R] - 128;
        S[R] = D;
      }
    }
    function De(S, R) {
      let D = 0,
        y = Math.floor((S.length + 1) / 2),
        C = 0;
      const P = S.length - 1;
      for (; !(C > P || ((R[C++] = S[D++]), C > P)); ) R[C++] = S[y++];
    }
    function He(S) {
      let R = S.byteLength;
      const D = new Array();
      let y = 0;
      const C = new DataView(S);
      for (; R > 0; ) {
        const P = C.getInt8(y++);
        if (P < 0) {
          const N = -P;
          R -= N + 1;
          for (let O = 0; O < N; O++) D.push(C.getUint8(y++));
        } else {
          const N = P;
          R -= 2;
          const O = C.getUint8(y++);
          for (let Y = 0; Y < N + 1; Y++) D.push(O);
        }
      }
      return D;
    }
    function Ve(S, R, D, y, C, P) {
      let N = new DataView(P.buffer);
      const O = D[S.idx[0]].width,
        Y = D[S.idx[0]].height,
        X = 3,
        Z = Math.floor(O / 8),
        re = Math.ceil(O / 8),
        ae = Math.ceil(Y / 8),
        de = O - (re - 1) * 8,
        Se = Y - (ae - 1) * 8,
        Ee = { value: 0 },
        be = new Array(X),
        Oe = new Array(X),
        at = new Array(X),
        je = new Array(X),
        ze = new Array(X);
      for (let Fe = 0; Fe < X; ++Fe)
        (ze[Fe] = R[S.idx[Fe]]),
          (be[Fe] = Fe < 1 ? 0 : be[Fe - 1] + re * ae),
          (Oe[Fe] = new Float32Array(64)),
          (at[Fe] = new Uint16Array(64)),
          (je[Fe] = new Uint16Array(re * 64));
      for (let Fe = 0; Fe < ae; ++Fe) {
        let mt = 8;
        Fe == ae - 1 && (mt = Se);
        let un = 8;
        for (let st = 0; st < re; ++st) {
          st == re - 1 && (un = de);
          for (let Ze = 0; Ze < X; ++Ze)
            at[Ze].fill(0),
              (at[Ze][0] = C[be[Ze]++]),
              _t(Ee, y, at[Ze]),
              qe(at[Ze], Oe[Ze]),
              Xe(Oe[Ze]);
          it(Oe);
          for (let Ze = 0; Ze < X; ++Ze) Pt(Oe[Ze], je[Ze], st * 64);
        }
        let Mt = 0;
        for (let st = 0; st < X; ++st) {
          const Ze = D[S.idx[st]].type;
          for (let Qt = 8 * Fe; Qt < 8 * Fe + mt; ++Qt) {
            Mt = ze[st][Qt];
            for (let wi = 0; wi < Z; ++wi) {
              const Tt = wi * 64 + (Qt & 7) * 8;
              N.setUint16(Mt + 0 * 2 * Ze, je[st][Tt + 0], !0),
                N.setUint16(Mt + 1 * 2 * Ze, je[st][Tt + 1], !0),
                N.setUint16(Mt + 2 * 2 * Ze, je[st][Tt + 2], !0),
                N.setUint16(Mt + 3 * 2 * Ze, je[st][Tt + 3], !0),
                N.setUint16(Mt + 4 * 2 * Ze, je[st][Tt + 4], !0),
                N.setUint16(Mt + 5 * 2 * Ze, je[st][Tt + 5], !0),
                N.setUint16(Mt + 6 * 2 * Ze, je[st][Tt + 6], !0),
                N.setUint16(Mt + 7 * 2 * Ze, je[st][Tt + 7], !0),
                (Mt += 8 * 2 * Ze);
            }
          }
          if (Z != re)
            for (let Qt = 8 * Fe; Qt < 8 * Fe + mt; ++Qt) {
              const wi = ze[st][Qt] + 8 * Z * 2 * Ze,
                Tt = Z * 64 + (Qt & 7) * 8;
              for (let Ki = 0; Ki < un; ++Ki)
                N.setUint16(wi + Ki * 2 * Ze, je[st][Tt + Ki], !0);
            }
        }
      }
      const ct = new Uint16Array(O);
      N = new DataView(P.buffer);
      for (let Fe = 0; Fe < X; ++Fe) {
        D[S.idx[Fe]].decoded = !0;
        const mt = D[S.idx[Fe]].type;
        if (D[Fe].type == 2)
          for (let un = 0; un < Y; ++un) {
            const Mt = ze[Fe][un];
            for (let st = 0; st < O; ++st)
              ct[st] = N.getUint16(Mt + st * 2 * mt, !0);
            for (let st = 0; st < O; ++st)
              N.setFloat32(Mt + st * 2 * mt, oe(ct[st]), !0);
          }
      }
    }
    function _t(S, R, D) {
      let y,
        C = 1;
      for (; C < 64; )
        (y = R[S.value]),
          y == 65280
            ? (C = 64)
            : y >> 8 == 255
            ? (C += y & 255)
            : ((D[C] = y), C++),
          S.value++;
    }
    function qe(S, R) {
      (R[0] = oe(S[0])),
        (R[1] = oe(S[1])),
        (R[2] = oe(S[5])),
        (R[3] = oe(S[6])),
        (R[4] = oe(S[14])),
        (R[5] = oe(S[15])),
        (R[6] = oe(S[27])),
        (R[7] = oe(S[28])),
        (R[8] = oe(S[2])),
        (R[9] = oe(S[4])),
        (R[10] = oe(S[7])),
        (R[11] = oe(S[13])),
        (R[12] = oe(S[16])),
        (R[13] = oe(S[26])),
        (R[14] = oe(S[29])),
        (R[15] = oe(S[42])),
        (R[16] = oe(S[3])),
        (R[17] = oe(S[8])),
        (R[18] = oe(S[12])),
        (R[19] = oe(S[17])),
        (R[20] = oe(S[25])),
        (R[21] = oe(S[30])),
        (R[22] = oe(S[41])),
        (R[23] = oe(S[43])),
        (R[24] = oe(S[9])),
        (R[25] = oe(S[11])),
        (R[26] = oe(S[18])),
        (R[27] = oe(S[24])),
        (R[28] = oe(S[31])),
        (R[29] = oe(S[40])),
        (R[30] = oe(S[44])),
        (R[31] = oe(S[53])),
        (R[32] = oe(S[10])),
        (R[33] = oe(S[19])),
        (R[34] = oe(S[23])),
        (R[35] = oe(S[32])),
        (R[36] = oe(S[39])),
        (R[37] = oe(S[45])),
        (R[38] = oe(S[52])),
        (R[39] = oe(S[54])),
        (R[40] = oe(S[20])),
        (R[41] = oe(S[22])),
        (R[42] = oe(S[33])),
        (R[43] = oe(S[38])),
        (R[44] = oe(S[46])),
        (R[45] = oe(S[51])),
        (R[46] = oe(S[55])),
        (R[47] = oe(S[60])),
        (R[48] = oe(S[21])),
        (R[49] = oe(S[34])),
        (R[50] = oe(S[37])),
        (R[51] = oe(S[47])),
        (R[52] = oe(S[50])),
        (R[53] = oe(S[56])),
        (R[54] = oe(S[59])),
        (R[55] = oe(S[61])),
        (R[56] = oe(S[35])),
        (R[57] = oe(S[36])),
        (R[58] = oe(S[48])),
        (R[59] = oe(S[49])),
        (R[60] = oe(S[57])),
        (R[61] = oe(S[58])),
        (R[62] = oe(S[62])),
        (R[63] = oe(S[63]));
    }
    function Xe(S) {
      const R = 0.5 * Math.cos(0.7853975),
        D = 0.5 * Math.cos(3.14159 / 16),
        y = 0.5 * Math.cos(3.14159 / 8),
        C = 0.5 * Math.cos((3 * 3.14159) / 16),
        P = 0.5 * Math.cos((5 * 3.14159) / 16),
        N = 0.5 * Math.cos((3 * 3.14159) / 8),
        O = 0.5 * Math.cos((7 * 3.14159) / 16),
        Y = new Array(4),
        X = new Array(4),
        Z = new Array(4),
        re = new Array(4);
      for (let ae = 0; ae < 8; ++ae) {
        const de = ae * 8;
        (Y[0] = y * S[de + 2]),
          (Y[1] = N * S[de + 2]),
          (Y[2] = y * S[de + 6]),
          (Y[3] = N * S[de + 6]),
          (X[0] =
            D * S[de + 1] + C * S[de + 3] + P * S[de + 5] + O * S[de + 7]),
          (X[1] =
            C * S[de + 1] - O * S[de + 3] - D * S[de + 5] - P * S[de + 7]),
          (X[2] =
            P * S[de + 1] - D * S[de + 3] + O * S[de + 5] + C * S[de + 7]),
          (X[3] =
            O * S[de + 1] - P * S[de + 3] + C * S[de + 5] - D * S[de + 7]),
          (Z[0] = R * (S[de + 0] + S[de + 4])),
          (Z[3] = R * (S[de + 0] - S[de + 4])),
          (Z[1] = Y[0] + Y[3]),
          (Z[2] = Y[1] - Y[2]),
          (re[0] = Z[0] + Z[1]),
          (re[1] = Z[3] + Z[2]),
          (re[2] = Z[3] - Z[2]),
          (re[3] = Z[0] - Z[1]),
          (S[de + 0] = re[0] + X[0]),
          (S[de + 1] = re[1] + X[1]),
          (S[de + 2] = re[2] + X[2]),
          (S[de + 3] = re[3] + X[3]),
          (S[de + 4] = re[3] - X[3]),
          (S[de + 5] = re[2] - X[2]),
          (S[de + 6] = re[1] - X[1]),
          (S[de + 7] = re[0] - X[0]);
      }
      for (let ae = 0; ae < 8; ++ae)
        (Y[0] = y * S[16 + ae]),
          (Y[1] = N * S[16 + ae]),
          (Y[2] = y * S[48 + ae]),
          (Y[3] = N * S[48 + ae]),
          (X[0] =
            D * S[8 + ae] + C * S[24 + ae] + P * S[40 + ae] + O * S[56 + ae]),
          (X[1] =
            C * S[8 + ae] - O * S[24 + ae] - D * S[40 + ae] - P * S[56 + ae]),
          (X[2] =
            P * S[8 + ae] - D * S[24 + ae] + O * S[40 + ae] + C * S[56 + ae]),
          (X[3] =
            O * S[8 + ae] - P * S[24 + ae] + C * S[40 + ae] - D * S[56 + ae]),
          (Z[0] = R * (S[ae] + S[32 + ae])),
          (Z[3] = R * (S[ae] - S[32 + ae])),
          (Z[1] = Y[0] + Y[3]),
          (Z[2] = Y[1] - Y[2]),
          (re[0] = Z[0] + Z[1]),
          (re[1] = Z[3] + Z[2]),
          (re[2] = Z[3] - Z[2]),
          (re[3] = Z[0] - Z[1]),
          (S[0 + ae] = re[0] + X[0]),
          (S[8 + ae] = re[1] + X[1]),
          (S[16 + ae] = re[2] + X[2]),
          (S[24 + ae] = re[3] + X[3]),
          (S[32 + ae] = re[3] - X[3]),
          (S[40 + ae] = re[2] - X[2]),
          (S[48 + ae] = re[1] - X[1]),
          (S[56 + ae] = re[0] - X[0]);
    }
    function it(S) {
      for (let R = 0; R < 64; ++R) {
        const D = S[0][R],
          y = S[1][R],
          C = S[2][R];
        (S[0][R] = D + 1.5747 * C),
          (S[1][R] = D - 0.1873 * y - 0.4682 * C),
          (S[2][R] = D + 1.8556 * y);
      }
    }
    function Pt(S, R, D) {
      for (let y = 0; y < 64; ++y) R[D + y] = Pm.toHalfFloat(Ut(S[y]));
    }
    function Ut(S) {
      return S <= 1
        ? Math.sign(S) * Math.pow(Math.abs(S), 2.2)
        : Math.sign(S) * Math.pow(M, Math.abs(S) - 1);
    }
    function I(S) {
      return new DataView(S.array.buffer, S.offset.value, S.size);
    }
    function T(S) {
      const R = S.viewer.buffer.slice(S.offset.value, S.offset.value + S.size),
        D = new Uint8Array(He(R)),
        y = new Uint8Array(D.length);
      return kt(D), De(D, y), new DataView(y.buffer);
    }
    function q(S) {
      const R = S.array.slice(S.offset.value, S.offset.value + S.size),
        D = Cl(R),
        y = new Uint8Array(D.length);
      return kt(D), De(D, y), new DataView(y.buffer);
    }
    function pe(S) {
      const R = S.viewer,
        D = { value: S.offset.value },
        y = new Uint16Array(
          S.width * S.scanlineBlockSize * (S.channels * S.type)
        ),
        C = new Uint8Array(8192);
      let P = 0;
      const N = new Array(S.channels);
      for (let Se = 0; Se < S.channels; Se++)
        (N[Se] = {}),
          (N[Se].start = P),
          (N[Se].end = N[Se].start),
          (N[Se].nx = S.width),
          (N[Se].ny = S.lines),
          (N[Se].size = S.type),
          (P += N[Se].nx * N[Se].ny * N[Se].size);
      const O = k(R, D),
        Y = k(R, D);
      if (Y >= 8192)
        throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
      if (O <= Y) for (let Se = 0; Se < Y - O + 1; Se++) C[Se + O] = Pe(R, D);
      const X = new Uint16Array(65536),
        Z = b(C, X),
        re = ne(R, D);
      Ye(S.array, R, D, re, y, P);
      for (let Se = 0; Se < S.channels; ++Se) {
        const Ee = N[Se];
        for (let be = 0; be < N[Se].size; ++be)
          We(y, Ee.start + be, Ee.nx, Ee.size, Ee.ny, Ee.nx * Ee.size, Z);
      }
      j(X, y, P);
      let ae = 0;
      const de = new Uint8Array(y.buffer.byteLength);
      for (let Se = 0; Se < S.lines; Se++)
        for (let Ee = 0; Ee < S.channels; Ee++) {
          const be = N[Ee],
            Oe = be.nx * be.size,
            at = new Uint8Array(y.buffer, be.end * 2, Oe * 2);
          de.set(at, ae), (ae += Oe * 2), (be.end += Oe);
        }
      return new DataView(de.buffer);
    }
    function le(S) {
      const R = S.array.slice(S.offset.value, S.offset.value + S.size),
        D = Cl(R),
        y = S.lines * S.channels * S.width,
        C = S.type == 1 ? new Uint16Array(y) : new Uint32Array(y);
      let P = 0,
        N = 0;
      const O = new Array(4);
      for (let Y = 0; Y < S.lines; Y++)
        for (let X = 0; X < S.channels; X++) {
          let Z = 0;
          switch (S.type) {
            case 1:
              (O[0] = P), (O[1] = O[0] + S.width), (P = O[1] + S.width);
              for (let re = 0; re < S.width; ++re) {
                const ae = (D[O[0]++] << 8) | D[O[1]++];
                (Z += ae), (C[N] = Z), N++;
              }
              break;
            case 2:
              (O[0] = P),
                (O[1] = O[0] + S.width),
                (O[2] = O[1] + S.width),
                (P = O[2] + S.width);
              for (let re = 0; re < S.width; ++re) {
                const ae =
                  (D[O[0]++] << 24) | (D[O[1]++] << 16) | (D[O[2]++] << 8);
                (Z += ae), (C[N] = Z), N++;
              }
              break;
          }
        }
      return new DataView(C.buffer);
    }
    function he(S) {
      const R = S.viewer,
        D = { value: S.offset.value },
        y = new Uint8Array(S.width * S.lines * (S.channels * S.type * 2)),
        C = {
          version: Le(R, D),
          unknownUncompressedSize: Le(R, D),
          unknownCompressedSize: Le(R, D),
          acCompressedSize: Le(R, D),
          dcCompressedSize: Le(R, D),
          rleCompressedSize: Le(R, D),
          rleUncompressedSize: Le(R, D),
          rleRawSize: Le(R, D),
          totalAcUncompressedCount: Le(R, D),
          totalDcUncompressedCount: Le(R, D),
          acCompression: Le(R, D),
        };
      if (C.version < 2)
        throw new Error(
          "EXRLoader.parse: " +
            qi.compression +
            " version " +
            C.version +
            " is unsupported"
        );
      const P = new Array();
      let N = k(R, D) - 2;
      for (; N > 0; ) {
        const Ee = Ie(R.buffer, D),
          be = Pe(R, D),
          Oe = (be >> 2) & 3,
          at = (be >> 4) - 1,
          je = new Int8Array([at])[0],
          ze = Pe(R, D);
        P.push({ name: Ee, index: je, type: ze, compression: Oe }),
          (N -= Ee.length + 3);
      }
      const O = qi.channels,
        Y = new Array(S.channels);
      for (let Ee = 0; Ee < S.channels; ++Ee) {
        const be = (Y[Ee] = {}),
          Oe = O[Ee];
        (be.name = Oe.name),
          (be.compression = 0),
          (be.decoded = !1),
          (be.type = Oe.pixelType),
          (be.pLinear = Oe.pLinear),
          (be.width = S.width),
          (be.height = S.lines);
      }
      const X = { idx: new Array(3) };
      for (let Ee = 0; Ee < S.channels; ++Ee) {
        const be = Y[Ee];
        for (let Oe = 0; Oe < P.length; ++Oe) {
          const at = P[Oe];
          be.name == at.name &&
            ((be.compression = at.compression),
            at.index >= 0 && (X.idx[at.index] = Ee),
            (be.offset = Ee));
        }
      }
      let Z, re, ae;
      if (C.acCompressedSize > 0)
        switch (C.acCompression) {
          case 0:
            (Z = new Uint16Array(C.totalAcUncompressedCount)),
              Ye(
                S.array,
                R,
                D,
                C.acCompressedSize,
                Z,
                C.totalAcUncompressedCount
              );
            break;
          case 1:
            const Ee = S.array.slice(
                D.value,
                D.value + C.totalAcUncompressedCount
              ),
              be = Cl(Ee);
            (Z = new Uint16Array(be.buffer)),
              (D.value += C.totalAcUncompressedCount);
            break;
        }
      if (C.dcCompressedSize > 0) {
        const Ee = { array: S.array, offset: D, size: C.dcCompressedSize };
        (re = new Uint16Array(q(Ee).buffer)), (D.value += C.dcCompressedSize);
      }
      if (C.rleRawSize > 0) {
        const Ee = S.array.slice(D.value, D.value + C.rleCompressedSize),
          be = Cl(Ee);
        (ae = He(be.buffer)), (D.value += C.rleCompressedSize);
      }
      let de = 0;
      const Se = new Array(Y.length);
      for (let Ee = 0; Ee < Se.length; ++Ee) Se[Ee] = new Array();
      for (let Ee = 0; Ee < S.lines; ++Ee)
        for (let be = 0; be < Y.length; ++be)
          Se[be].push(de), (de += Y[be].width * S.type * 2);
      Ve(X, Se, Y, Z, re, y);
      for (let Ee = 0; Ee < Y.length; ++Ee) {
        const be = Y[Ee];
        if (!be.decoded)
          switch (be.compression) {
            case 2:
              let Oe = 0,
                at = 0;
              for (let je = 0; je < S.lines; ++je) {
                let ze = Se[Ee][Oe];
                for (let ct = 0; ct < be.width; ++ct) {
                  for (let Fe = 0; Fe < 2 * be.type; ++Fe)
                    y[ze++] = ae[at + Fe * be.width * be.height];
                  at++;
                }
                Oe++;
              }
              break;
            case 1:
            default:
              throw new Error(
                "EXRLoader.parse: unsupported channel compression"
              );
          }
      }
      return new DataView(y.buffer);
    }
    function Ie(S, R) {
      const D = new Uint8Array(S);
      let y = 0;
      for (; D[R.value + y] != 0; ) y += 1;
      const C = new TextDecoder().decode(D.slice(R.value, R.value + y));
      return (R.value = R.value + y + 1), C;
    }
    function ge(S, R, D) {
      const y = new TextDecoder().decode(
        new Uint8Array(S).slice(R.value, R.value + D)
      );
      return (R.value = R.value + D), y;
    }
    function Ae(S, R) {
      const D = fe(S, R),
        y = ne(S, R);
      return [D, y];
    }
    function F(S, R) {
      const D = ne(S, R),
        y = ne(S, R);
      return [D, y];
    }
    function fe(S, R) {
      const D = S.getInt32(R.value, !0);
      return (R.value = R.value + 4), D;
    }
    function ne(S, R) {
      const D = S.getUint32(R.value, !0);
      return (R.value = R.value + 4), D;
    }
    function Be(S, R) {
      const D = S[R.value];
      return (R.value = R.value + 1), D;
    }
    function Pe(S, R) {
      const D = S.getUint8(R.value);
      return (R.value = R.value + 1), D;
    }
    const Le = function (S, R) {
      let D;
      return (
        "getBigInt64" in DataView.prototype
          ? (D = Number(S.getBigInt64(R.value, !0)))
          : (D =
              S.getUint32(R.value + 4, !0) +
              Number(S.getUint32(R.value, !0) << 32)),
        (R.value += 8),
        D
      );
    };
    function Te(S, R) {
      const D = S.getFloat32(R.value, !0);
      return (R.value += 4), D;
    }
    function Re(S, R) {
      return Pm.toHalfFloat(Te(S, R));
    }
    function oe(S) {
      const R = (S & 31744) >> 10,
        D = S & 1023;
      return (
        (S >> 15 ? -1 : 1) *
        (R
          ? R === 31
            ? D
              ? NaN
              : 1 / 0
            : Math.pow(2, R - 15) * (1 + D / 1024)
          : 6103515625e-14 * (D / 1024))
      );
    }
    function k(S, R) {
      const D = S.getUint16(R.value, !0);
      return (R.value += 2), D;
    }
    function xe(S, R) {
      return oe(k(S, R));
    }
    function ce(S, R, D, y) {
      const C = D.value,
        P = [];
      for (; D.value < C + y - 1; ) {
        const N = Ie(R, D),
          O = fe(S, D),
          Y = Pe(S, D);
        D.value += 3;
        const X = fe(S, D),
          Z = fe(S, D);
        P.push({
          name: N,
          pixelType: O,
          pLinear: Y,
          xSampling: X,
          ySampling: Z,
        });
      }
      return (D.value += 1), P;
    }
    function ee(S, R) {
      const D = Te(S, R),
        y = Te(S, R),
        C = Te(S, R),
        P = Te(S, R),
        N = Te(S, R),
        O = Te(S, R),
        Y = Te(S, R),
        X = Te(S, R);
      return {
        redX: D,
        redY: y,
        greenX: C,
        greenY: P,
        blueX: N,
        blueY: O,
        whiteX: Y,
        whiteY: X,
      };
    }
    function me(S, R) {
      const D = [
          "NO_COMPRESSION",
          "RLE_COMPRESSION",
          "ZIPS_COMPRESSION",
          "ZIP_COMPRESSION",
          "PIZ_COMPRESSION",
          "PXR24_COMPRESSION",
          "B44_COMPRESSION",
          "B44A_COMPRESSION",
          "DWAA_COMPRESSION",
          "DWAB_COMPRESSION",
        ],
        y = Pe(S, R);
      return D[y];
    }
    function Ue(S, R) {
      const D = ne(S, R),
        y = ne(S, R),
        C = ne(S, R),
        P = ne(S, R);
      return { xMin: D, yMin: y, xMax: C, yMax: P };
    }
    function Je(S, R) {
      const D = ["INCREASING_Y"],
        y = Pe(S, R);
      return D[y];
    }
    function It(S, R) {
      const D = Te(S, R),
        y = Te(S, R);
      return [D, y];
    }
    function yn(S, R) {
      const D = Te(S, R),
        y = Te(S, R),
        C = Te(S, R);
      return [D, y, C];
    }
    function dt(S, R, D, y, C) {
      if (y === "string" || y === "stringvector" || y === "iccProfile")
        return ge(R, D, C);
      if (y === "chlist") return ce(S, R, D, C);
      if (y === "chromaticities") return ee(S, D);
      if (y === "compression") return me(S, D);
      if (y === "box2i") return Ue(S, D);
      if (y === "lineOrder") return Je(S, D);
      if (y === "float") return Te(S, D);
      if (y === "v2f") return It(S, D);
      if (y === "v3f") return yn(S, D);
      if (y === "int") return fe(S, D);
      if (y === "rational") return Ae(S, D);
      if (y === "timecode") return F(S, D);
      if (y === "preview") return (D.value += C), "skipped";
      D.value += C;
    }
    function $t(S, R, D) {
      const y = {};
      if (S.getUint32(0, !0) != 20000630)
        throw new Error(
          "THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format."
        );
      y.version = S.getUint8(4);
      const C = S.getUint8(5);
      (y.spec = {
        singleTile: !!(C & 2),
        longName: !!(C & 4),
        deepFormat: !!(C & 8),
        multiPart: !!(C & 16),
      }),
        (D.value = 8);
      let P = !0;
      for (; P; ) {
        const N = Ie(R, D);
        if (N == 0) P = !1;
        else {
          const O = Ie(R, D),
            Y = ne(S, D),
            X = dt(S, R, D, O, Y);
          X === void 0
            ? console.warn(
                `THREE.EXRLoader: Skipped unknown header attribute type '${O}'.`
              )
            : (y[N] = X);
        }
      }
      if (C & -5)
        throw (
          (console.error("THREE.EXRHeader:", y),
          new Error("THREE.EXRLoader: Provided file is currently unsupported."))
        );
      return y;
    }
    function Bn(S, R, D, y, C) {
      const P = {
        size: 0,
        viewer: R,
        array: D,
        offset: y,
        width: S.dataWindow.xMax - S.dataWindow.xMin + 1,
        height: S.dataWindow.yMax - S.dataWindow.yMin + 1,
        channels: S.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: S.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        colorSpace: Vt,
      };
      switch (S.compression) {
        case "NO_COMPRESSION":
          (P.lines = 1), (P.uncompress = I);
          break;
        case "RLE_COMPRESSION":
          (P.lines = 1), (P.uncompress = T);
          break;
        case "ZIPS_COMPRESSION":
          (P.lines = 1), (P.uncompress = q);
          break;
        case "ZIP_COMPRESSION":
          (P.lines = 16), (P.uncompress = q);
          break;
        case "PIZ_COMPRESSION":
          (P.lines = 32), (P.uncompress = pe);
          break;
        case "PXR24_COMPRESSION":
          (P.lines = 16), (P.uncompress = le);
          break;
        case "DWAA_COMPRESSION":
          (P.lines = 32), (P.uncompress = he);
          break;
        case "DWAB_COMPRESSION":
          (P.lines = 256), (P.uncompress = he);
          break;
        default:
          throw new Error(
            "EXRLoader.parse: " + S.compression + " is unsupported"
          );
      }
      if (((P.scanlineBlockSize = P.lines), P.type == 1))
        switch (C) {
          case jn:
            (P.getter = xe), (P.inputSize = 2);
            break;
          case ki:
            (P.getter = k), (P.inputSize = 2);
            break;
        }
      else if (P.type == 2)
        switch (C) {
          case jn:
            (P.getter = Te), (P.inputSize = 4);
            break;
          case ki:
            (P.getter = Re), (P.inputSize = 4);
        }
      else
        throw new Error(
          "EXRLoader.parse: unsupported pixelType " +
            P.type +
            " for " +
            S.compression +
            "."
        );
      P.blockCount = (S.dataWindow.yMax + 1) / P.scanlineBlockSize;
      for (let O = 0; O < P.blockCount; O++) Le(R, y);
      P.outputChannels = P.channels == 3 ? 4 : P.channels;
      const N = P.width * P.height * P.outputChannels;
      switch (C) {
        case jn:
          (P.byteArray = new Float32Array(N)),
            P.channels < P.outputChannels && P.byteArray.fill(1, 0, N);
          break;
        case ki:
          (P.byteArray = new Uint16Array(N)),
            P.channels < P.outputChannels && P.byteArray.fill(15360, 0, N);
          break;
        default:
          console.error("THREE.EXRLoader: unsupported type: ", C);
          break;
      }
      return (
        (P.bytesPerLine = P.width * P.inputSize * P.channels),
        P.outputChannels == 4
          ? ((P.format = Pn), (P.colorSpace = Vt))
          : ((P.format = rv), (P.colorSpace = In)),
        P
      );
    }
    const Or = new DataView(e),
      Gc = new Uint8Array(e),
      di = { value: 0 },
      qi = $t(Or, e, di),
      $e = Bn(qi, Or, Gc, di, this.type),
      Ro = { value: 0 },
      Oa = { R: 0, G: 1, B: 2, A: 3, Y: 0 };
    for (let S = 0; S < $e.height / $e.scanlineBlockSize; S++) {
      const R = ne(Or, di);
      ($e.size = ne(Or, di)),
        ($e.lines =
          R + $e.scanlineBlockSize > $e.height
            ? $e.height - R
            : $e.scanlineBlockSize);
      const y =
        $e.size < $e.lines * $e.bytesPerLine ? $e.uncompress($e) : I($e);
      di.value += $e.size;
      for (let C = 0; C < $e.scanlineBlockSize; C++) {
        const P = C + S * $e.scanlineBlockSize;
        if (P >= $e.height) break;
        for (let N = 0; N < $e.channels; N++) {
          const O = Oa[qi.channels[N].name];
          for (let Y = 0; Y < $e.width; Y++) {
            Ro.value =
              (C * ($e.channels * $e.width) + N * $e.width + Y) * $e.inputSize;
            const X =
              ($e.height - 1 - P) * ($e.width * $e.outputChannels) +
              Y * $e.outputChannels +
              O;
            $e.byteArray[X] = $e.getter(y, Ro);
          }
        }
      }
    }
    return {
      header: qi,
      width: $e.width,
      height: $e.height,
      data: $e.byteArray,
      format: $e.format,
      colorSpace: $e.colorSpace,
      type: this.type,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, i, r) {
    function s(o, a) {
      (o.colorSpace = a.colorSpace),
        (o.minFilter = zt),
        (o.magFilter = zt),
        (o.generateMipmaps = !1),
        (o.flipY = !1),
        t && t(o, a);
    }
    return super.load(e, s, i, r);
  }
}
const Rb = new PR(),
  bb = new Ab(),
  Cb = new Ov(),
  jv = {},
  Ao = new XA();
jv.envMapIntensity = 0.7;
function Yv() {
  Ao.traverse((n) => {
    n.isMesh &&
      n.material.isMeshStandardMaterial &&
      ((n.material.envMapIntensity = jv.envMapIntensity),
      (n.castShadow = !0),
      (n.receiveShadow = !0));
  });
}
const wh = Cb.load(
  "../files/threeJS/environmentMaps/venice_equirectangular.png"
);
wh.colorSpace = Rt;
wh.generateMipmaps = !1;
const qv = new ub(wh);
qv.scale.setScalar(20);
Ao.add(qv);
bb.load(
  "../files/threeJS/environmentMaps/hdri-exr_venice_compressed.exr",
  (n) => {
    (n.mapping = mc), (Ao.environment = n);
  }
);
const Lb = new Vc({ color: "#dddddd" });
Rb.load("../files/threeJS/models/gondola_lowPoly.glb", (n) => {
  n.scene.traverse((e) => {
    e.isMesh && (e.material = Lb);
  }),
    Ao.add(n.scene),
    Yv();
});
const wr = new pn(
  75,
  document.documentElement.clientWidth / document.documentElement.clientHeight,
  0.1,
  500
);
wr.position.x = 11;
wr.position.z = 0;
wr.position.y = 5;
const Ti = new Fv("#ffffff", 5);
Ti.position.set(0, 12, -10);
Ti.castShadow = !0;
Ti.target.position.set(0, 2, 2);
Ti.shadow.camera.far = 21;
Ti.shadow.mapSize.set(1024, 1024);
Ti.target.updateWorldMatrix();
Ao.add(Ti);
Ti.shadow.normalBias = 0.027;
Ti.shadow.bias = -0.004;
const Lr = new bv({ alpha: !1, antialias: !0 });
Lr.toneMapping = Q0;
Lr.toneMappingExposure = 2;
Lr.shadowMap.enabled = !0;
Lr.shadowMap.type = Z0;
Ti.castShadow = !0;
const Ur = new LR(wr, Lr.domElement);
Ur.enableDamping = !0;
Ur.target.y = 4;
Ur.rotateSpeed = 0.4;
Ur.maxDistance = 10;
Ur.minDistance = 5;
Ur.maxPolarAngle = uh.degToRad(110);
Ur.enablePan = !1;
function Kv() {
  Ur.update(), requestAnimationFrame(Kv), Lr.render(Ao, wr);
}
function Pb() {
  const [n, e] = jt.useState(!0),
    [t, i] = jt.useState(!1),
    [r, s] = jt.useState(0.8),
    { clientHeight: o, clientWidth: a } = wS(),
    l = jt.useRef(null);
  function c() {
    t
      ? (document.exitFullscreen(), s(0.8))
      : (l.current.requestFullscreen(), s(1));
  }
  return (
    jt.useEffect(() => {
      (Uv.onLoad = function () {
        e(!1);
      }),
        wr.updateProjectionMatrix(),
        l.current.appendChild(Lr.domElement),
        Kv(),
        Yv();
    }, []),
    jt.useEffect(() => {
      function u() {
        i(!!document.fullscreenElement);
      }
      return (
        document.addEventListener("fullscreenchange", u),
        () => document.removeEventListener("fullscreenchange", u)
      );
    }, []),
    jt.useEffect(() => {
      document.fullscreenElement ? s(1) : s(0.8);
    }, [t]),
    jt.useEffect(() => {
      Lr.setSize(a * r, o * r),
        (wr.aspect = a / o),
        wr.updateProjectionMatrix();
    }, [a, o, r]),
    Ln.jsxs(Ln.Fragment, {
      children: [
        n && Ln.jsx("div", { className: Ng.loader, children: "Is Loading..." }),
        Ln.jsxs("div", {
          className: Ng.three,
          ref: l,
          children: [
            Ln.jsx("button", {
              onClick: c,
              children: t ? "Exit Full Screen" : "Full Screen",
            }),
            t
              ? null
              : Ln.jsx("a", {
                  href: "https://github.com/kenarp/ThreeJS-Venice-Gondola-Design",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: Ln.jsx("img", {
                    src: "../files/threeJS/github-mark.svg",
                    alt: "Github Repo",
                  }),
                }),
          ],
        }),
      ],
    })
  );
}
function Ib() {
  return Ln.jsx("div", { children: Ln.jsx(TS, { children: Ln.jsx(Pb, {}) }) });
}
nf.createRoot(document.getElementById("root")).render(
  Ln.jsx(hy.StrictMode, { children: Ln.jsx(Ib, {}) })
);
